<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns#" lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta http-equiv="x-ua-compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Hack Note (old posts, page 9) | Hack Note</title>
<meta name="description" content="Personal handnote on software development">
<meta name="theme-color" content="#04519b">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" href="/rss.xml">
<link href="/assets/css/minima.min.css" rel="stylesheet" type="text/css">
<link rel="canonical" href="https://blog.wangzhl.com/index-9.html">
<link rel="icon" href="/favicon.ico" sizes="64x64">
<link rel="prev" href="/index-8.html" type="text/html">
<link rel="next" href="/index-10.html" type="text/html">
</head>
<body>
  <header class="site-header nav-custom"><div class="wrapper">
      <a class="site-title" rel="author" href="/">Hack Note</a>
      <nav class="site-nav"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger">
          <span class="menu-icon">
            <svg viewbox="0 0 18 15" width="18px" height="15px"><use href="/assets/svg/theme.svg#menu-icon"></use></svg></span>
        </label>
        <div class="trigger">
          
            <a class="page-link" href="/">Home</a>
            <a class="page-link" href="/archive/">Archive</a>
            <a class="page-link" href="/tags/">Tags</a>
            <a class="page-link" href="/about/">About</a>

        </div>
      </nav>
</div>
  </header><main class="page-content" aria-label="Content"><div class="wrapper">

    

    


  



  


<div class="home">
  <ul class="post-list">
<li>
    <span class="post-meta">Jul 23, 2018</span>
    <h3>
      <a class="post-link" href="/posts/notes-on-libshmcache/">libshmcache源码阅读笔记</a>
    </h3>

    <div id="outline-container-orgd748daf" class="outline-2">
<h2 id="orgd748daf">引言</h2>
<div class="outline-text-2" id="text-orgd748daf">
<p>
由于在工作中需要开发一套内存缓存服务，使用了共享内存作为多进程间的数据共享。为了提高共享内存缓存服务的性能，我找了一个类似的较为成熟的开源项目 <a href="https://github.com/happyfish100/libshmcache">libshmcache</a> ，通过研究源码学习其中的优点并改进自己的模块。<br></p>

<p>
libshmcache与redis相似的是都使用内存进行数据缓存；与redis不同的是，redis使用的进程自己申请的动态内存，而libshmcache使用的是共享内存。使用共享内存就意味着libshmcache主要的应用场景是同一台主机上的数据缓存。<br></p>

<p>
我花了一周时间阅读了比较感兴趣的部分代码，收获不少，现就以下几个方面总结一下自己的心得：<br></p>
<ul class="org-ul">
<li>纯C语言开发的代码风格<br>
</li>
<li>hash table的原理和实现<br>
</li>
<li>gcc原子化操作接口<br>
</li>
<li>有锁写和无锁读的实现细节<br>
</li>
<li>共享内存的两套函数接口(POSIX和SystemV)<br>
</li>
</ul>
</div>
</div>


<div id="outline-container-org0e936a6" class="outline-2">
<h2 id="org0e936a6">纯C语言开发时的代码风格</h2>
<div class="outline-text-2" id="text-org0e936a6">
<p>
我在工作中使用比较多的开发语言是C++，对于C语言编写的这样规模的项目，还是第一次仔细深入地研究。C语言使用 <code>struct</code> 作为大多数自定义数据结构的关键字，相对于C++能够使用成员函数能够对类进行功能拓展，C语言比较常用的是将这个对象作为输入参数传到函数中。<br></p>

<p>
纵观所有项目代码，我感受比较深的就是使用结构体中嵌套匿名结构体，这样做能够增强数据结构的层次感，示例代码如下：<br></p>
<div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">shmcache_context</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">pid_t</span><span class="w"> </span><span class="n">pid</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">lock_fd</span><span class="p">;</span><span class="w">    </span><span class="c1">//for file lock</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">detect_deadlock_clocks</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">shmcache_config</span><span class="w"> </span><span class="n">config</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">shm_memory_info</span><span class="w"> </span><span class="o">*</span><span class="n">memory</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="nc">shmcache_segment_info</span><span class="w"> </span><span class="n">hashtable</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	    </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="p">;</span><span class="w"></span>
<span class="w">	    </span><span class="k">struct</span><span class="w"> </span><span class="nc">shmcache_segment_info</span><span class="w"> </span><span class="o">*</span><span class="n">items</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"> </span><span class="n">values</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">segments</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">shmcache_value_allocator_context</span><span class="w"> </span><span class="n">value_allocator</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">shmcache_list</span><span class="w"> </span><span class="n">list</span><span class="p">;</span><span class="w">   </span><span class="c1">//for value recycle</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">create_segment</span><span class="p">;</span><span class="w">  </span><span class="c1">//if check segment size                                  </span>
<span class="p">};</span><span class="w"></span>
</pre></div>
<p>
注意 <code>shmcache_context</code> 中的匿名结构体 <code>segments</code> 和 <code>values</code> ，这样的写法体现了相互包含关系，也使后续的操作该数据结构的语句更加容易理解。<br></p>

<p>
另外对于联合体和位域这两种技术也是我在之前开发中使用比较少的，通过阅读源码能够让我对其有了更深刻的理解。示例代码如下：<br></p>
<div class="highlight"><pre><span></span><span class="k">union</span><span class="w"> </span><span class="nc">shm_hentry_offset</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">offset</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">:</span><span class="mi">16</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">int64_t</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">:</span><span class="mi">48</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">segment</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
<p>
这段代码使用了联合体赋予了 <code>shm_hentry_offset</code> 两种访问方式，又使用了位域将 <code>int64_t</code> 分割为两段。<br></p>
</div>
</div>


<div id="outline-container-orgbb30529" class="outline-2">
<h2 id="orgbb30529">hash table的原理和实现</h2>
<div class="outline-text-2" id="text-orgbb30529">
<p>
libshmcache内部使用的是hash table做内部缓存的数据结构，这使查找的时间复杂度是O(1)。<br>
之前看过一些介绍hash table的资料，对hash table的工作原理是有过一个基础的了解的，这次通过阅读源码，能够了解到hash table在代码实现上更加细节的内容。<br>
对于hash计算中出现的hash值冲突，即在hash计算时出现了两个不同的key在经过hash计算后得到的bucket相同，libshmcache采用的解决方案是使用linked list来存放这些相同bucket对应的value。<br></p>
</div>
</div>


<div id="outline-container-org2ef63d2" class="outline-2">
<h2 id="org2ef63d2">gcc原子化操作接口</h2>
<div class="outline-text-2" id="text-org2ef63d2">
<p>
使用原子化操作接口能够解决一些并发读写问题，原子化操作相对于互斥锁执行更快。原子化操作也是一种无锁编程的方式。<br></p>
</div>
</div>


<div id="outline-container-orgef3c728" class="outline-2">
<h2 id="orgef3c728">有锁写和无锁读的实现</h2>
<div class="outline-text-2" id="text-orgef3c728">
<p>
在libshmcache中，写操作通过 <code>pthread_mutex_t</code> 进行同步，而读操作是无锁的。<br>
对于写操作来说，需要对hash table进行操作，这肯定是需要同步的。<br>
将 <code>pthread_mutex_t</code> 保存在共享内存中，不同的进程通过映射共享内存就能获得同一个互斥量，通过这个互斥量就能完成进程间同步。<br></p>
</div>
</div>


<div id="outline-container-orgbbc6a6c" class="outline-2">
<h2 id="orgbbc6a6c">共享内存的两套函数接口(POSIX和SystemV)</h2>
<div class="outline-text-2" id="text-orgbbc6a6c">
<p>
在linux上使用共享内存时有两套接口 <code>mmap</code> 和 <code>shmget</code> 。 <code>mmap</code> 是 <code>POSIX</code> 标准的接口，而 <code>shmget</code> 是 <code>System V</code> 标准的接口，两者都能够实现进程间共享内存，但他们在使用上还是有些区别的。对于 <code>mmap</code> 来说，需要在硬盘上创建一个文件，再将该文件映射到内存中。对于 <code>shmget</code> 来说，需要指定一个key，不同的进程通过相同的key就能映射到同一片内存。<br></p>
</div>
</div>

  </li>


  <li>
    <span class="post-meta">Jul 11, 2018</span>
    <h3>
      <a class="post-link" href="/posts/cpp-bit-field/">C/C++中的位域</a>
    </h3>

    <div id="outline-container-org912927e" class="outline-2">
<h2 id="org912927e">什么是位域</h2>
<div class="outline-text-2" id="text-org912927e">
<p>
<a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E6%AE%B5">维基百科</a> 给出了以下解释<br></p>
<blockquote>
<p>
位域（或称“位段”，bit field）为一种数据结构，可以把数据以位的形式紧凑的储存，并允许程序员对此结构的位进行操作。<br></p>
</blockquote>

<p>
<a href="https://en.cppreference.com/w/cpp/language/bit_field">cppreference</a> 给出了以下定义<br></p>
<blockquote>
<p>
Declares a class data member with explicit size, in bits. Adjacent bit field members may be packed to share and straddle the individual bytes.<br></p>
</blockquote>

<p>
这种数据结构的好处：<br></p>
<ul class="org-ul">
<li>可以使数据单元节省储存空间，当程序需要成千上万个数据单元时，这种方法就显得尤为重要。<br>
</li>
<li>位段可以很方便的访问一个整数值的部分内容从而可以简化程序源代码。<br>
</li>
</ul>
<p>
而位域这种数据结构的缺点在于，其内存分配与内存对齐的实现方式依赖于具体的机器和系统，在不同的平台可能有不同的结果，这导致了位域在本质上是不可移植的。<br></p>
</div>
</div>


<div id="outline-container-org070d6fa" class="outline-2">
<h2 id="org070d6fa">位域的语法</h2>
<div class="outline-text-2" id="text-org070d6fa">
<p>
下面就是位域的语法格式。<br></p>
<div class="highlight"><pre><span></span><span class="n">identifier</span><span class="p">(</span><span class="n">optional</span><span class="p">)</span><span class="w"> </span><span class="n">attr</span><span class="p">(</span><span class="n">optional</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">size</span><span class="w"></span>
</pre></div>

<p>
<b>注意</b> ：<br></p>
<ul class="org-ul">
<li>
<code>size</code> 的大小不能超过 <code>identifier</code> 所包含最大比特位个数。<br>
</li>
<li>
<code>identifier</code> 为空时表示对应的 <code>size</code> 个数的比特位不使用<br>
</li>
<li>
<code>size</code> 为0时表示根据前类型强制补齐<br>
</li>
</ul>
<p>
以下为代码示例。<br></p>

<div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">S1</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// will usually occupy 2 bytes:</span>
<span class="w">    </span><span class="c1">// 3 bits: value of b1</span>
<span class="w">    </span><span class="c1">// 2 bits: unused</span>
<span class="w">    </span><span class="c1">// 6 bits: value of b2</span>
<span class="w">    </span><span class="c1">// 2 bits: value of b3</span>
<span class="w">    </span><span class="c1">// 3 bits: unused</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">b1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">b2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="n">b3</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="nc">S2</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// will usually occupy 2 bytes:</span>
<span class="w">    </span><span class="c1">// 3 bits: value of b1</span>
<span class="w">    </span><span class="c1">// 5 bits: unused</span>
<span class="w">    </span><span class="c1">// 6 bits: value of b2</span>
<span class="w">    </span><span class="c1">// 2 bits: value of b3</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">b1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">:</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// start a new byte</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">b2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">b3</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>


<div id="outline-container-org8e6ab9a" class="outline-3">
<h3 id="org8e6ab9a">在 <code>size</code> 取0时如何理解</h3>
<div class="outline-text-3" id="text-org8e6ab9a">
<p>
对于 <code>size</code> 取0时的各种情况进行了尝试，详细用例如下。思路是使用联合体能比较方便地将内存分布表示出来。<br>
如下所示，定义了如下几种情况。<br></p>

<p>
<b>case1</b><br></p>
<div class="highlight"><pre><span></span><span class="k">union</span><span class="w"> </span><span class="nc">un1</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="n">nn1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="nl">int</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="n">nn2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">st</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>

<p>
对联合体中的结构体位段进行赋值，并将联合体中的内容打印出来。<br></p>
<div class="highlight"><pre><span></span><span class="k">union</span><span class="w"> </span><span class="nc">un1</span><span class="w"> </span><span class="n">u1</span><span class="p">;</span><span class="w"></span>
<span class="n">u1</span><span class="p">.</span><span class="n">st</span><span class="p">.</span><span class="n">nn1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="n">u1</span><span class="p">.</span><span class="n">st</span><span class="p">.</span><span class="n">nn2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="n">printf</span><span class="p">(</span><span class="s">"union u1.n1=0x%08x sizeof(un1)=%zu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">u1</span><span class="p">.</span><span class="n">n1</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">un1</span><span class="p">));</span><span class="w"></span>
</pre></div>

<p>
输出结果为<br></p>
<div class="highlight"><pre><span></span><span class="k">union</span><span class="w"> </span><span class="nc">un1</span><span class="p">.</span><span class="n">n1</span><span class="o">=</span><span class="mh">0x00000001</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">un1</span><span class="p">)</span><span class="o">=</span><span class="mi">8</span><span class="w"></span>
</pre></div>

<p>
<b>case2</b><br></p>
<div class="highlight"><pre><span></span><span class="k">union</span><span class="w"> </span><span class="nc">un1</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="n">nn1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="nl">char</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="n">nn2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">st</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>

<p>
输出结果为<br></p>
<div class="highlight"><pre><span></span><span class="k">union</span><span class="w"> </span><span class="nc">un1</span><span class="p">.</span><span class="n">n1</span><span class="o">=</span><span class="mh">0x00000101</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">un1</span><span class="p">)</span><span class="o">=</span><span class="mi">4</span><span class="w"></span>
</pre></div>

<p>
<b>case3</b><br></p>
<div class="highlight"><pre><span></span><span class="k">union</span><span class="w"> </span><span class="nc">un1</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="n">nn1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="nl">short</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="n">nn2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">st</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>

<p>
输出结果为<br></p>
<div class="highlight"><pre><span></span><span class="k">union</span><span class="w"> </span><span class="nc">un1</span><span class="p">.</span><span class="n">n1</span><span class="o">=</span><span class="mh">0x00010001</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">un1</span><span class="p">)</span><span class="o">=</span><span class="mi">4</span><span class="w"></span>
</pre></div>


<p>
<b>case4</b><br></p>
<div class="highlight"><pre><span></span><span class="k">union</span><span class="w"> </span><span class="nc">un1</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="n">nn1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="nl">char</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="n">nn2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">st</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>

<p>
输出结果为<br></p>
<div class="highlight"><pre><span></span><span class="k">union</span><span class="w"> </span><span class="nc">un1</span><span class="p">.</span><span class="n">n1</span><span class="o">=</span><span class="mh">0x00000101</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">un1</span><span class="p">)</span><span class="o">=</span><span class="mi">4</span><span class="w"></span>
</pre></div>
</div>
</div>


<div id="outline-container-orgb9843a3" class="outline-3">
<h3 id="orgb9843a3">
<code>struct</code> 与 <code>class</code> 关键字</h3>
<div class="outline-text-3" id="text-orgb9843a3">
<p>
多数例子都是以 <code>struct</code> 作为位域的组织标识，在C++中能否使用 <code>class</code> 作为位域的标识符呢？<br>
经过测试，是可以使用 <code>class</code> 关键字的，但是需要注意 <code>class</code> 的默认访问控制属性为 <code>private</code> 。<br></p>
</div>
</div>
</div>


<div id="outline-container-org69284db" class="outline-2">
<h2 id="org69284db">位域的常见应用场景</h2>
<div class="outline-text-2" id="text-org69284db">
<p>
为什么要使用位域？位域适合那些情况？<br></p>

<p>
位域的主要使用目的是节省对象的内存使用。在存放一些比较小的数据时，使用位域能够使字节中的每个比特位合理地利用起来，避免内存浪费。<br></p>

<p>
比较典型的应用是描述硬件寄存器。如果有32个一组的寄存器，每个寄存器代表一个比特位，就可以使用位域表示这组寄存器。<br></p>
</div>
</div>


<div id="outline-container-org283ebbd" class="outline-2">
<h2 id="org283ebbd">C++中的位操作接口</h2>
<div class="outline-text-2" id="text-org283ebbd">
<p>
C++中也提供了一套位操作的接口 <code>std::bitset</code> ，这套接口提供了指定比特位数据的操作接口。<br></p>
</div>
</div>


<div id="outline-container-org03da74b" class="outline-2">
<h2 id="org03da74b">参考资料</h2>
<div class="outline-text-2" id="text-org03da74b">
<ul class="org-ul">
<li>
<a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E6%AE%B5">wikipedia - bit field</a><br>
</li>
<li>
<a href="https://en.cppreference.com/w/cpp/language/bit_field">cppreference - bit field</a><br>
</li>
<li>
<a href="https://msdn.microsoft.com/zh-cn/library/ewwyfdbe.aspx">microsoft msdn - C++ bit fileds</a><br>
</li>
<li>
<a href="https://stackoverflow.com/questions/24933242/when-to-use-bit-fields-in-c">stackoverflow - how to use bit field</a><br>
</li>
<li>
<a href="https://en.cppreference.com/w/cpp/utility/bitset">cppreference - <code>std::bitset</code></a><br>
</li>
</ul>
<p>
（全文完）<br></p>
</div>
</div>

  </li>


  <li>
    <span class="post-meta">Jul 02, 2018</span>
    <h3>
      <a class="post-link" href="/posts/gcc-built-in-functions-for-atomic-memory-access/">GCC的内存原子化操作函数接口</a>
    </h3>

    <div id="outline-container-org3ebf5b1" class="outline-2">
<h2 id="org3ebf5b1">
<span class="section-number-2">1</span> 原子化操作</h2>
<div class="outline-text-2" id="text-1">
<p>
在并发编程中，一个操作或一组操作是原子操作、可线性化操作、不可分操作或不可中断操作（atomic, linearizable, indivisible, uniterruptible），表示该操作执行时不可被中断的。操作的原子性能够保证操作在执行时免受中断、信号、并发进程线程的影响。另外，原子操作大多只有两种结果，要么成功并改变系统中对应的状态，要么没有相关效果。<br></p>

</div>
</div>

  </li>


  <li>
    <span class="post-meta">Jun 29, 2018</span>
    <h3>
      <a class="post-link" href="/posts/gdb-display-contents-of-memory-address/">在gdb中查看指定内存地址的内容</a>
    </h3>

    <p>
调试 C/C++ 程序时，需要打印指定内存地址的内容。我最近调试程序中的序列化模块时，需要将类对象按照指定的格式转化为二进制流，为了验证转化结果，在调试时就需要将指定内存地址中的内容打印出来。<br></p>

  </li>


  <li>
    <span class="post-meta">Jun 26, 2018</span>
    <h3>
      <a class="post-link" href="/posts/asynchronous-synchronous-and-blocking-unblocking/">同步和异步、阻塞和非阻塞</a>
    </h3>

    <div id="outline-container-orgce6c910" class="outline-2">
<h2 id="orgce6c910">
<span class="section-number-2">1</span> 同步和异步</h2>
<div class="outline-text-2" id="text-1">
<p>
同步和异步指的是在进行I/O操作完成之前，是否允许其他处理步骤继续执行。<br>
计算机中的I/O操作相对于数据处理操作时十分耗时的。<br></p>

<p>
一个简单的I/O操作方式就是启动连接并等待操作完成，但是这样的操作（同步阻塞I/O）在通信过程中会阻塞进程的处理进度。<br>
相应的，可以在启动通信的同时进行其他的处理，并不需要等待I/O操作的完成，这样的操作就被称作是异步I/O。那些依赖于I/O操作执行完成的任务会阻塞等待I/O操作的完成，其他不依赖与I/O操作的任务能够继续执行。<br></p>

<p>
同步模型常用的函数接口： <code>read</code> , <code>write</code> , <code>send</code> , <code>recv</code><br>
异步模型常用的函数接口： <code>aio_write</code> , <code>aio_read</code><br></p>
</div>

<div id="outline-container-org95109b2" class="outline-3">
<h3 id="org95109b2">
<span class="section-number-3">1.1</span> POSIX AIO</h3>
<div class="outline-text-3" id="text-1-1">
<p>
在头文件 <code>aio.h</code> 中定义，链接时使用 <code>-lrt</code><br></p>

<p>
<b>函数接口</b><br>
异步写操作<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">aio_read</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">aiocb</span><span class="o">*</span><span class="w"> </span><span class="n">aiocbp</span><span class="p">);</span><span class="w"></span>
</pre></div>

<p>
异步读操作<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">aio_write</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">aiocb</span><span class="o">*</span><span class="w"> </span><span class="n">aiocbp</span><span class="p">);</span><span class="w"></span>
</pre></div>

<p>
获取异步操作结果<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">aio_return</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">aiocb</span><span class="o">*</span><span class="w"> </span><span class="n">aiocbp</span><span class="p">);</span><span class="w"></span>
</pre></div>

<p>
获取异步操作中的错误<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">aio_error</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">aiocb</span><span class="o">*</span><span class="w"> </span><span class="n">aiocbp</span><span class="p">);</span><span class="w"></span>
</pre></div>

<p>
示例代码： <a href="https://gist.github.com/rsms/771059">github gist</a><br></p>
</div>
</div>

<div id="outline-container-org822edac" class="outline-3">
<h3 id="org822edac">
<span class="section-number-3">1.2</span> Linux AIO</h3>
<div class="outline-text-3" id="text-1-2">
<p>
在头文件 <code>libaio.h</code> 中定义，链接时使用 <code>-laio</code><br></p>

<p>
<b>函数接口</b><br>
需要注意的是aio的函数接口需要借助 <code>syscall</code> 进行调用。<br>
创建aio context对象<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">io_setup</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">nr</span><span class="p">,</span><span class="w"> </span><span class="n">aio_context_t</span><span class="o">*</span><span class="w"> </span><span class="n">ctxp</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>
销毁aio context对象<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">io_destroy</span><span class="p">(</span><span class="n">aio_context_t</span><span class="w"> </span><span class="n">ctx</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>
提交异步操作<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">io_submit</span><span class="p">(</span><span class="n">aio_context_t</span><span class="w"> </span><span class="n">ctx</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">nr</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">iocb</span><span class="o">**</span><span class="w"> </span><span class="n">iocbpp</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>
获取异步操作结果<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">io_getevents</span><span class="p">(</span><span class="n">aio_context_t</span><span class="w"> </span><span class="n">ctx</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">min_nr</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">max_nr</span><span class="p">,</span><span class="w"></span>
<span class="w">		 </span><span class="n">io_event</span><span class="o">*</span><span class="w"> </span><span class="n">events</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">timespec</span><span class="o">*</span><span class="w"> </span><span class="n">timeout</span><span class="p">);</span><span class="w"></span>
</pre></div>

<p>
示例代码:<br></p>
<ul class="org-ul">
<li>
<a href="https://gist.github.com/larytet/87f90b08643ac3de934df2cadff4989c">github gist</a><br>
</li>
<li>
<a href="http://www.xmailserver.org/eventfd-aio-test.c">xmailserver.org</a><br>
</li>
</ul>
</div>
</div>

<div id="outline-container-org427fd61" class="outline-3">
<h3 id="org427fd61">
<span class="section-number-3">1.3</span> POSIX AIO与Linux AIO的区别</h3>
<div class="outline-text-3" id="text-1-3">
<p>
摘自 <a href="https://stackoverflow.com/questions/8768083/difference-between-posix-aio-and-libaio-on-linux">stackoverflow.com</a><br></p>
<blockquote>
<p>
On linux, the two AIO implementations are fundamentally different.<br>
The POSIX AIO is a user-level implementation that performs normal blocking I/O in multiple threads, hence giving the illusion that the I/Os are asynchronous. The main reason to do this is that:<br></p>
<ul class="org-ul">
<li>it works with any filesystem<br>
</li>
<li>it works (essentially) on any operating system (keep in mind that gnu's libc is portable)<br>
</li>
<li>it works on files with buffering enabled (i.e. no O<sub>DIRECT</sub> flag set)<br>
</li>
</ul>
<p>
The main drawback is that your queue depth (i.e. the number of outstanding operations you can have in practice) is limited by the number of threads you choose to have, which also means that a slow operation on one disk may block an operation going to a different disk. It also affects which I/Os (or how many) is seen by the kernel and the disk scheduler as well.<br>
The kernel AIO (i.e. io<sub>submit</sub>() et.al.) is kernel support for asynchronous I/O operations, where the io requests are actually queued up in the kernel, sorted by whatever disk scheduler you have, presumably some of them are forwarded (in somewhat optimal order one would hope) to the actual disk as asynchronous operations (using TCQ or NCQ). The main restriction with this approach is that not all filesystems work that well or at all with async I/O (and may fall back to blocking semantics), files have to be opened with O<sub>DIRECT</sub> which comes with a whole lot of other restrictions on the I/O requests. If you fail to open your files with O<sub>DIRECT</sub>, it may still "work", as in you get the right data back, but it probably isn't done asynchronously, but is falling back to blocking semantics.<br>
Also keep in mind that io<sub>submit</sub>() can actually block on the disk under certain circumstances.<br></p>
</blockquote>
<p>
在Linux上两种AIO是完全不同的；<br>
POSIX AIO实现在用户层，实际上进行的操作是普通的多线程阻塞操作，表现为I/O操作是异步的，这种AIO的优点是兼容性和可移植性好，缺点是操作队列长度受限于最大线程数量。<br>
Linux AIO是内核提供的AIO函数接口，I/O操作请求的队列在内核中维护，这种AIO的缺点是并不支持所有的文件系统，Linux AIO在某些情况下的磁盘操作是会阻塞的。<br></p>
</div>
</div>
</div>

<div id="outline-container-org925dd54" class="outline-2">
<h2 id="org925dd54">
<span class="section-number-2">2</span> 阻塞和非阻塞</h2>
<div class="outline-text-2" id="text-2">
<p>
阻塞与非阻塞的概念针对的是函数是否会立即返回。<br>
非阻塞模型常与IO复用技术组合使用。<br>
可以通过函数将IO设备设置为非阻塞模式。<br></p>
</div>
</div>


<div id="outline-container-org2db8ee6" class="outline-2">
<h2 id="org2db8ee6">
<span class="section-number-2">3</span> 如何理解阻塞非阻塞与同步异步的区别</h2>
<div class="outline-text-2" id="text-3">
<p>
在处理 IO 的时候，阻塞和非阻塞都是同步 IO。<br>
只有使用了特殊的 API 才是异步 IO。<br></p>
</div>
</div>


<div id="outline-container-orgc39a4f5" class="outline-2">
<h2 id="orgc39a4f5">
<span class="section-number-2">4</span> 参考资料</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li>
<a href="https://blog.csdn.net/hguisu/article/details/38638183">csdn.net</a><br>
</li>
<li>
<a href="https://github.com/littledan/linux-aio%20repo">github.com linux-aio</a><br>
</li>
<li>
<a href="https://www.ibm.com/developerworks/linux/library/l-async/index.html">ibm developerworks</a><br>
</li>
</ul>
</div>
</div>

  </li>


  <li>
    <span class="post-meta">Jun 20, 2018</span>
    <h3>
      <a class="post-link" href="/posts/check-system-information-on-linux/">查看Linux系统的相关信息</a>
    </h3>

    <p>
查看Linux系统相关信息有助于排查和解决软件和硬件的兼容性问题。系统信息包括硬件信息和软件信息，硬件信息主要有CPU信息、内存信息、PCI信息、USB信息、硬盘信息等等。软件信息主要有系统版本、分区使用状态等等。本文主要介绍了获取当前Linux系统信息的命令。<br></p>

<div id="outline-container-orge2935a1" class="outline-2">
<h2 id="orge2935a1">查看系统相关信息</h2>
<div class="outline-text-2" id="text-orge2935a1">
<p>
<code>uname</code> 指令提供了查询系统信息的功能，使用该命令能够快速获取操作系统信息概览。<br></p>

<p>
查看内核名称<br></p>
<div class="highlight"><pre><span></span>uname -s
</pre></div>

<p>
查看处理器类型<br></p>
<div class="highlight"><pre><span></span>uname -p
</pre></div>

<p>
查看硬件架构<br></p>
<div class="highlight"><pre><span></span>uname -i
</pre></div>

<p>
查看内核版本<br></p>
<div class="highlight"><pre><span></span>uname -r
</pre></div>

<p>
查看所有系统信息<br></p>
<div class="highlight"><pre><span></span>uname -a
</pre></div>

<p>
查看操作系统信息（发行版信息）<br></p>
<div class="highlight"><pre><span></span>cat /etc/os-release
cat /proc/version
lsb_release -a
hostnamectl
</pre></div>
</div>
</div>

<div id="outline-container-org67a632f" class="outline-2">
<h2 id="org67a632f">查看CPU相关信息</h2>
<div class="outline-text-2" id="text-org67a632f">
<p>
<code>lscpu</code> 指令能够查看当前系统中CPU的详细信息，包括型号、主频、构架、大小端等信息。<br></p>
</div>
</div>

<div id="outline-container-org8fe4dc7" class="outline-2">
<h2 id="org8fe4dc7">查看硬盘相关信息</h2>
<div class="outline-text-2" id="text-org8fe4dc7">
<p>
<code>lsblk</code> 指令能够查看块设备（block device）的详细信息，块设备主要指系统中的存储设备如硬盘和闪存。<br></p>
</div>
</div>

<div id="outline-container-orge37453b" class="outline-2">
<h2 id="orge37453b">查看PCI设备的相关信息</h2>
<div class="outline-text-2" id="text-orge37453b">
<p>
<code>lspci</code> 指令能够查看PCI设备的信息，PCI设备包括USB、显卡、串口、网卡等其他外围设备。<br></p>

<p>
输出树形结果<br></p>
<div class="highlight"><pre><span></span>lspci -t
</pre></div>

<p>
输出详细信息<br></p>
<div class="highlight"><pre><span></span>lspci -v
lspci -vv
</pre></div>
</div>
</div>

<div id="outline-container-org5c0fd69" class="outline-2">
<h2 id="org5c0fd69">查看USB设备的相关信息</h2>
<div class="outline-text-2" id="text-org5c0fd69">
<p>
<code>lsusb</code> 指令能够查看USBS设备的信息。<br></p>
</div>
</div>

<div id="outline-container-org1df1c43" class="outline-2">
<h2 id="org1df1c43">查看文件系统相关信息</h2>
<div class="outline-text-2" id="text-org1df1c43">
<p>
<code>fdisk</code> 命令能够查看和操作linux系统的分区表。<br></p>

<p>
查看文件系统信息<br></p>
<div class="highlight"><pre><span></span>fdisk -l
</pre></div>

<p>
<code>df</code> 命令能够查看分区信息和硬盘使用信息<br></p>

<p>
使输出信息更容易理解<br></p>
<div class="highlight"><pre><span></span>df -h
</pre></div>
</div>
</div>

<div id="outline-container-orgb864330" class="outline-2">
<h2 id="orgb864330">参考资料</h2>
<div class="outline-text-2" id="text-orgb864330">
<ul class="org-ul">
<li>
<a href="https://www.tecmint.com/commands-to-collect-system-and-hardware-information-in-linux/">tecmint.com</a><br>
</li>
<li>
<a href="https://www.binarytides.com/linux-commands-hardware-info/">binarytides.com</a><br>
</li>
</ul>
</div>
</div>

  </li>


  <li>
    <span class="post-meta">Jun 14, 2018</span>
    <h3>
      <a class="post-link" href="/posts/linux-command-examples-top/">Linux常用命令行指令 - top</a>
    </h3>

    <p>
linux的top命令能够动态显示当前系统的运行状态。它能够显示操作系统的汇总信息和当前系统上的正在运行的进程列表。<br></p>

<div id="outline-container-org11691b9" class="outline-2">
<h2 id="org11691b9">统计信息说明</h2>
<div class="outline-text-2" id="text-org11691b9">
<p>
(可以通过配置文件修改通计信息区的显示格式，下文所描述的都是在默认配置下的显示内容)<br></p>
</div>
<div id="outline-container-orgd61a176" class="outline-3">
<h3 id="orgd61a176">第1行</h3>
<div class="outline-text-3" id="text-orgd61a176">
<ul class="org-ul">
<li>当前系统时间<br>
</li>
<li>当前系统的启动时长<br>
</li>
<li>当前登录的用户数量<br>
</li>
<li>当前系统的平均负载（分别是1min,5min,10min的平均负载）<br>
</li>
</ul>
<p>
这一行信息也可以通过 <code>uptime</code> 和 <code>w</code> 指令获得<br></p>
</div>
</div>
<div id="outline-container-org7dfba21" class="outline-3">
<h3 id="org7dfba21">第2行</h3>
<div class="outline-text-3" id="text-org7dfba21">
<ul class="org-ul">
<li>总进程数<br>
</li>
<li>正在运行的进程数<br>
</li>
<li>休眠的进程数<br>
</li>
<li>停止的进程数<br>
</li>
<li>僵尸进程数<br>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgcad8741" class="outline-3">
<h3 id="orgcad8741">第3行</h3>
<div class="outline-text-3" id="text-orgcad8741">
<ul class="org-ul">
<li>us 用户空间占用CPU百分比<br>
</li>
<li>sy 内核空间占用CPU百分比<br>
</li>
<li>ni 用户进程空间内改变过优先级的进程占用CPU百分比<br>
</li>
<li>id 空闲CPU百分比<br>
</li>
<li>wa 等待输入输出的CPU时间百分比<br>
</li>
<li>hi CPU服务于硬件中断所耗费的时间总额<br>
</li>
<li>si CPU服务软中断所耗费的时间总额<br>
</li>
<li>st Steal time 虚拟机被hypervisor偷去的CPU时间（如果当前处于一个hypervisor下的vm，实际上hypervisor也是要消耗一部分CPU处理时间的）<br>
</li>
</ul>
</div>
</div>

<div id="outline-container-org6c671cb" class="outline-3">
<h3 id="org6c671cb">第4行</h3>
<div class="outline-text-3" id="text-org6c671cb">
<ul class="org-ul">
<li>物理内存总量<br>
</li>
<li>使用的物理内存总量<br>
</li>
<li>空闲内存总量<br>
</li>
<li>用作内核缓存的内存量<br>
</li>
</ul>
</div>
</div>

<div id="outline-container-org5bc1396" class="outline-3">
<h3 id="org5bc1396">第5行</h3>
<div class="outline-text-3" id="text-org5bc1396">
<ul class="org-ul">
<li>交换区总量<br>
</li>
<li>使用的交换区总量<br>
</li>
<li>空间交换区总量<br>
</li>
<li>缓冲交换区总量<br>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgdf68826" class="outline-2">
<h2 id="orgdf68826">进程信息</h2>
<div class="outline-text-2" id="text-orgdf68826">
<p>
在top命令中按f按可以查看显示的列信息，按对应字母来开启/关闭列，大写字母表示开启，小写字母表示关闭。带*号的是默认列。<br></p>

<p>
A: PID = (Process Id) 进程Id；<br>
E: USER = (User Name) 进程所有者的用户名；<br>
H: PR = (Priority) 优先级<br>
I: NI = (Nice value) nice值。负值表示高优先级，正值表示低优先级<br>
O: VIRT = (Virtual Image (kb)) 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES<br>
Q: RES = (Resident size (kb)) 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA<br>
T: SHR = (Shared Mem size (kb)) 共享内存大小，单位kb<br>
W: S = (Process Status) 进程状态。D=不可中断的睡眠状态,R=运行,S=睡眠,T=跟踪/停止,Z=僵尸进程<br>
K: %CPU = (CPU usage) 上次更新到现在的CPU时间占用百分比<br>
N: %MEM = (Memory usage (RES)) 进程使用的物理内存百分比<br>
M: TIME+ = (CPU Time, hundredths) 进程使用的CPU时间总计，单位1/100秒<br>
b: PPID = (Parent Process Pid) 父进程Id<br>
c: RUSER = (Real user name)<br>
d: UID = (User Id) 进程所有者的用户id<br>
f: GROUP = (Group Name) 进程所有者的组名<br>
g: TTY = (Controlling Tty) 启动进程的终端名。不是从终端启动的进程则显示为 ?<br>
j: P = (Last used cpu (SMP)) 最后使用的CPU，仅在多CPU环境下有意义<br>
p: SWAP = (Swapped size (kb)) 进程使用的虚拟内存中，被换出的大小，单位kb<br>
l: TIME = (CPU Time) 进程使用的CPU时间总计，单位秒<br>
r: CODE = (Code size (kb)) 可执行代码占用的物理内存大小，单位kb<br>
s: DATA = (Data+Stack size (kb)) 可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb<br>
u: nFLT = (Page Fault count) 页面错误次数<br>
v: nDRT = (Dirty Pages count) 最后一次写入到现在，被修改过的页面数<br>
y: WCHAN = (Sleeping in Function) 若该进程在睡眠，则显示睡眠中的系统函数名<br>
z: Flags = (Task Flags &lt;sched.h&gt;) 任务标志，参考 sched.h<br>
X: COMMAND = (Command name/line) 命令名/命令行<br></p>
</div>
</div>


<div id="outline-container-orgbeb9fa7" class="outline-2">
<h2 id="orgbeb9fa7">参考资料</h2>
<div class="outline-text-2" id="text-orgbeb9fa7">
<ul class="org-ul">
<li>
<a href="https://www.tecmint.com/12-top-command-examples-in-linux/">tecmint.com</a><br>
</li>
<li>
<a href="https://blog.csdn.net/sanshiqiduer/article/details/1933625">csdn blog</a><br>
</li>
</ul>
</div>
</div>

  </li>


  <li>
    <span class="post-meta">Jun 07, 2018</span>
    <h3>
      <a class="post-link" href="/posts/cloud-server-security/">云服务器安全相关配置</a>
    </h3>

    <p>
我所租用的云服务器操作系统为CentOS Linux，在使用云服务器的过程中为了保证服务器的安全，进行了一些简单的配置，这样能够增加服务器被破解的难度。<br></p>

  </li>


  <li>
    <span class="post-meta">May 16, 2018</span>
    <h3>
      <a class="post-link" href="/posts/c-style-and-cpp-style-file-api/">C风格和C++风格的文件操作库函数总结</a>
    </h3>

    <p>
由于C++是兼容C的，所以使用C++进行文件操作时，会发现有两套库函数可以使用，它们分别是C风格的和C++风格的。<br></p>

<div id="outline-container-orgfde043c" class="outline-2">
<h2 id="orgfde043c">C风格的文件操作函数</h2>
<div class="outline-text-2" id="text-orgfde043c">
<p>
<b>打开文件，关闭文件</b><br></p>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="nf">fopen</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">path</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">mode</span><span class="p">);</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">fclose</span><span class="p">(</span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">fp</span><span class="p">);</span><span class="w"></span>
</pre></div>

<p>
<b>读取文件，写入文件</b><br></p>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="kt">size_t</span><span class="w"> </span><span class="nf">fread</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">nmemb</span><span class="p">,</span><span class="w"> </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
<span class="kt">size_t</span><span class="w"> </span><span class="nf">fwrite</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">nmemb</span><span class="p">,</span><span class="w"> </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>
关于fread中两个表示大小的参数，在这个 <a href="https://stackoverflow.com/questions/8589425/how-does-fread-really-work">stackoverflow</a> 问题中得到了比较好的解答。<br></p>


<p>
<b>改变文件指示器的位置</b><br></p>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">fseek</span><span class="p">(</span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">whence</span><span class="p">);</span><span class="w"></span>
<span class="kt">long</span><span class="w"> </span><span class="nf">ftell</span><span class="p">(</span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">rewind</span><span class="p">(</span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</div>


<div id="outline-container-orgb5017a5" class="outline-2">
<h2 id="orgb5017a5">C++风格的文件操作函数</h2>
<div class="outline-text-2" id="text-orgb5017a5">
<p>
C++将文件操作函数封装为 <code>fstream</code> 操作类，一个文件实际上就会对应一个 <code>fstream</code> 对象，一下函数都是 <code>fstream</code> 的成员函数。<br>
文件打开和关闭<br></p>
<div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">open</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="n">ios_base</span><span class="o">::</span><span class="n">openmode</span><span class="w"> </span><span class="n">mode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ios_base</span><span class="o">::</span><span class="n">in</span><span class="o">|</span><span class="n">ios_base</span><span class="o">::</span><span class="n">out</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">open</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="n">ios_base</span><span class="o">::</span><span class="n">openmode</span><span class="w"> </span><span class="n">mode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ios_base</span><span class="o">::</span><span class="n">in</span><span class="o">|</span><span class="n">ios_base</span><span class="o">::</span><span class="n">out</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">close</span><span class="p">();</span><span class="w"></span>
</pre></div>

<p>
对于文件的读写可以才采用流运算符重载的方法完成。<br></p>
<div class="highlight"><pre><span></span><span class="k">friend</span><span class="w"> </span><span class="n">fstream</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">fstream</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ofs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">CRecord</span><span class="o">&amp;</span><span class="w"> </span><span class="n">objRecord</span><span class="p">);</span><span class="w"></span>
<span class="k">friend</span><span class="w"> </span><span class="n">fstream</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">fstream</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ifs</span><span class="p">,</span><span class="w"> </span><span class="n">CRecord</span><span class="o">&amp;</span><span class="w"> </span><span class="n">objRecord</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</div>


<div id="outline-container-org412075a" class="outline-2">
<h2 id="org412075a">题外话</h2>
<div class="outline-text-2" id="text-org412075a">
<p>
在liunx下，可以使用wc命令查看文件中的相关信息。wc命令会打印出该文件的行数、单词数、字符数。<br></p>
</div>
</div>

  </li>


  <li>
    <span class="post-meta">May 11, 2018</span>
    <h3>
      <a class="post-link" href="/posts/endianness-and-union-type/">字节序与union类型</a>
    </h3>

    <div id="outline-container-orgc1aa66c" class="outline-2">
<h2 id="orgc1aa66c">字节序是什么</h2>
<div class="outline-text-2" id="text-orgc1aa66c">
<p>
字节序是指在数据传输时，高位字节存储在内存中的较高位地址还是较低位地址。字节序分为大端字节序和小端字节序，两种字节序不能混用。<br></p>

<ul class="org-ul">
<li>大端字节序 ：高位字节保存在较低位地址的内存中<br>
</li>
<li>小端字节序 ：高位字节保存在较高位地址的内存中<br>
</li>
</ul>
<p>
以 <code>int n = 0x12345678;</code> 为例，大端字节序内存中的存储的顺序为 <code>0x12 0x34 0x56 0x78</code> ，小端字节序内存中的存储顺序为 <code>0x78 0x56 0x34 0x12</code> 。很明显可以看出大端字节序更符合人类的阅读习惯。<br></p>

<ul class="org-ul">
<li>常见的大端系统CPU：IBM z/Atchitecture<br>
</li>
<li>常见的小端系统CPU：intel x86<br>
</li>
</ul>
<p>
网络字节序使用的大端字节序，常用网络协议如IPv4、IPv6、TCP和UDP协议都是使用大端字节序进行数据传输的。<br></p>
</div>
</div>



<div id="outline-container-orgb6e5f39" class="outline-2">
<h2 id="orgb6e5f39">提供字节序转换功能的函数接口</h2>
<div class="outline-text-2" id="text-orgb6e5f39">
<p>
在网络通信接口中提供了转换主机字节序和网络字节序之间的函数接口，如下所示。<br></p>
<div class="highlight"><pre><span></span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">htonl</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">hostlong</span><span class="p">);</span><span class="w"></span>
<span class="kt">uint16_t</span><span class="w"> </span><span class="nf">htons</span><span class="p">(</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">hostshort</span><span class="p">);</span><span class="w"></span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="nf">ntohl</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">netlong</span><span class="p">);</span><span class="w"></span>
<span class="kt">uint16_t</span><span class="w"> </span><span class="nf">ntohs</span><span class="p">(</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">netshort</span><span class="p">);</span><span class="w"></span>
</pre></div>

<p>
有些时候，我们需要手动转换内存字节流，可以使用以下接口帮助实现指定字节序的转换。<br></p>

<p>
小端字节序的函数实现如下：<br></p>
<div class="highlight"><pre><span></span><span class="c1">// small endian</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="w"> </span><span class="nf">SE_GetStreamU16</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">pTemp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="p">(</span><span class="n">pTemp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">pTemp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">SE_GetStreamU32</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">pTemp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="p">(</span><span class="n">pTemp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"></span>
<span class="w">			 </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">pTemp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"></span>
<span class="w">			 </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">pTemp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"></span>
<span class="w">			 </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">pTemp</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">24</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">SE_SetStreamU16</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">pTemp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">pTemp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">pTemp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">SE_SetStreamU32</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">pTemp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">pTemp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">pTemp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">pTemp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">16</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">pTemp</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">24</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<p>
大端字节序的函数实现如下：<br></p>
<div class="highlight"><pre><span></span><span class="c1">// big endian</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="w"> </span><span class="nf">BE_GetStreamU16</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">pTemp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="p">(</span><span class="n">pTemp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">pTemp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">BE_GetStreamU32</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">pTemp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="p">(</span><span class="n">pTemp</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"></span>
<span class="w">			 </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">pTemp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"></span>
<span class="w">			 </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">pTemp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"></span>
<span class="w">			 </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">pTemp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">24</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">BE_SetStreamU16</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">pTemp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">pTemp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">pTemp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">BE_SetStreamU32</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">pTemp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">pTemp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">24</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">pTemp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">16</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">pTemp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">pTemp</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>



<div id="outline-container-orgc89e32a" class="outline-2">
<h2 id="orgc89e32a">查看当前系统的字节序</h2>
<div class="outline-text-2" id="text-orgc89e32a">
<p>
通过 <code>lscpu</code> 命令，能得到cpu的大端和小端信息。<br></p>
<div class="highlight"><pre><span></span>lscpu <span class="p">|</span> grep -i endian
</pre></div>

<p>
通过常用shell命令，在大端系统中会输出0，在小端系统中会输出1。<br></p>
<div class="highlight"><pre><span></span><span class="nb">echo</span> -n I <span class="p">|</span> od -to2 <span class="p">|</span> head -n1 <span class="p">|</span> cut -f2 -d<span class="s2">" "</span> <span class="p">|</span> cut -c6
</pre></div>

<p>
借助python进行判断。<br></p>
<div class="highlight"><pre><span></span>python -c <span class="s2">"import sys; print(sys.byteorder)"</span>
<span class="c1"># or</span>
python -c <span class="s2">"import sys;sys.exit(0 if sys.byteorder=='big' else 1)"</span>
</pre></div>

<p>
借助linux的ELF进行判断，查看第6个字节，小端系统中为1，大端系统中为2。<br></p>
<div class="highlight"><pre><span></span>xxd -c <span class="m">1</span> -l <span class="m">6</span> /bin/bash
<span class="c1"># or</span>
hexdump -n <span class="m">6</span> -C /bin/bash
</pre></div>

<p>
可以使用union类型验证字节序，以下示例代码在不同的字节序下会有不同的输出。<br></p>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;inttypes.h&gt;</span><span class="cp"></span>

<span class="k">typedef</span><span class="w"> </span><span class="k">union</span><span class="w"> </span><span class="nc">un</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">ch</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">un</span><span class="p">;</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">un</span><span class="w"> </span><span class="n">u</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">u</span><span class="p">.</span><span class="n">ch</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">u</span><span class="p">.</span><span class="n">ch</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">u</span><span class="p">.</span><span class="n">ch</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">u</span><span class="p">.</span><span class="n">ch</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">"u.x=0x%x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">u</span><span class="p">.</span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>


<div id="outline-container-org343e20f" class="outline-2">
<h2 id="org343e20f">参考资料</h2>
<div class="outline-text-2" id="text-org343e20f">
<ul class="org-ul">
<li>
<a href="https://en.wikipedia.org/wiki/Endianness">wikipedia.com - endianness</a><br>
</li>
<li>
<a href="https://serverfault.com/questions/163487/how-to-tell-if-a-linux-system-is-big-endian-or-little-endian">serverfault.com - how to check endian</a><br>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">wikipedia.com - ELF format</a><br>
</li>
</ul>
<p>
（全文完）<br></p>
</div>
</div>

  </li>


  <li>
    <span class="post-meta">May 05, 2018</span>
    <h3>
      <a class="post-link" href="/posts/python-logging-with-function-name/">在Python日志中输出文件名和函数名</a>
    </h3>

    <p>
Python内置了日志模块，在默认情况下输出的日志是不带文件名和函数名的，这样在排查问题时，遇到相似的日志就变得容易混淆，可以通过设置将输出的日志中带有文件名和函数名。参考了stackoverflow的回答，详细代码如下。<br></p>

<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">logging</span>
<span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">'root'</span><span class="p">)</span>
<span class="n">LOG_FORMAT</span> <span class="o">=</span> <span class="s2">"</span><span class="si">%(filename)s</span><span class="s2">:</span><span class="si">%(lineno)s</span><span class="s2"> </span><span class="si">%(funcName)s</span><span class="s2">() </span><span class="si">%(message)s</span><span class="s2">"</span>
<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="n">LOG_FORMAT</span><span class="p">)</span>
<span class="n">log</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
</pre></div>

<p>
<b>参考资料</b><br><a href="https://stackoverflow.com/questions/10973362/python-logging-function-name-file-name-line-number-using-a-single-file">stackoverflow</a><br></p>

  </li>


  <li>
    <span class="post-meta">Apr 27, 2018</span>
    <h3>
      <a class="post-link" href="/posts/linux-command-examples-xargs/">Linux常用命令行指令 - xargs</a>
    </h3>

    <div id="outline-container-org2bb7c50" class="outline-2">
<h2 id="org2bb7c50">基础用法</h2>
<div class="outline-text-2" id="text-org2bb7c50">
<p>
<code>xargs</code> 指令默认情况下从 <code>stdin</code> 中读取信息，按照空格分或换行区分开，并且执行输入的命令（默认的命令是 <code>/bin/echo</code> ）。命令可以通过 <code>xargs</code> 的参数指定执行一次或多次，命令的执行参数为自身初始参数追加上由 <code>stdin</code> 读到的内容，命令在执行时会忽略空行。<br></p>

<blockquote>
<p>
xargs reads items from the standard input, delimited by blanks (which can be protected with double or single quotes or a backslash) or newlines, and executes the command (default is /bin/echo) one or more times with any initial-arguments followed by items read from standard input. Blank lines on the standard input are ignored.<br></p>
</blockquote>

<p>
在命令行输入 <code>xargs</code> 命令，输入 “a b c d” 后按回车，再按 <code>ctrl+d</code> 完成本次输入，则 <code>xargs</code> 的默认 <code>echo</code> 命令会将接收到的字符串打印出来，效果如下所示。<br></p>
<div class="highlight"><pre><span></span># xargs
a b c d
a b c d
</pre></div>

<p>
<code>xargs</code> 单独使用时功能比较单一，但是它与其他指令一起使用十分强大。<br></p>
</div>
</div>

<div id="outline-container-orgf4cf6a6" class="outline-2">
<h2 id="orgf4cf6a6">
<code>xargs</code> 与 <code>find</code> 组合使用</h2>
<div class="outline-text-2" id="text-orgf4cf6a6">
<p>
常见的使用方法是使用 <code>find</code> 指令找到指定的文件，组合以 <code>xargs</code> 指令实现对指定文件的操作。<br></p>
<div class="highlight"><pre><span></span>find . -name "demo_" | xargs file -i
</pre></div>
<p>
由于 <code>xargs</code> 是使用空格作为各个参数的分隔符，如果遇到的文件名中含有空格，则并不能按照预期处理。这时，可以使用 <code>find</code> 指令的 <code>-print0</code> 将含有空格的文件名转化为字符串，再结合 <code>xargs</code> 的 <code>-0</code> 参数就能完成文件名中含有空格的处理，改进后的命令如下。<br></p>
<div class="highlight"><pre><span></span>find . -name "demo_" -print0 | xargs -0 file -i
</pre></div>
</div>
</div>

<div id="outline-container-org5596e15" class="outline-2">
<h2 id="org5596e15">
<code>xargs</code> 与 <code>grep</code> 组合使用</h2>
<div class="outline-text-2" id="text-org5596e15">
<p>
常用命令如下，能够实现对指定规则文件的搜索匹配。<br></p>
<div class="highlight"><pre><span></span>find . -name "*.log" | xargs grep error
</pre></div>
</div>
</div>

<div id="outline-container-org42cbf76" class="outline-2">
<h2 id="org42cbf76">使用 <code>-n</code> 参数让 <code>xargs</code> 的命令重复执行</h2>
<div class="outline-text-2" id="text-org42cbf76">
<p>
如果想用 <code>find</code> 指令完成多个匹配规则的搜索，则可以使用 <code>-n</code> 参数将 <code>xargs</code> 的内容分割成多个。<br>
下面的命令会执行3次 <code>find</code> 命令， <code>xargs</code> 会将接收的到的内容按照单词数为“1”分割，分3次传送给 <code>find</code> 指令。<br></p>
<div class="highlight"><pre><span></span>echo "*.c" "*.cpp" "*.h" | xargs -n 1 find . -name
</pre></div>
</div>
</div>

<div id="outline-container-orgb1f8903" class="outline-2">
<h2 id="orgb1f8903">使用 <code>-t</code> 参数让 <code>xargs</code> 打印将要执行的命令</h2>
<div class="outline-text-2" id="text-orgb1f8903">
<p>
让 <code>xargs</code> 将指令的命令打印出来主要是方便查看命令执行情况，也方便在出现错误时进行调试。<br></p>
<div class="highlight"><pre><span></span>find . -name *.log | xargs -t rm -f
</pre></div>
</div>
</div>

<div id="outline-container-org3a9c44f" class="outline-2">
<h2 id="org3a9c44f">使用 <code>-p</code> 参数让 <code>xargs</code> 在执行命令前询问用户</h2>
<div class="outline-text-2" id="text-org3a9c44f">
<p>
增加 <code>-p</code> 参数后， <code>xargs</code> 在每次执行命令前会将指令打印出来并询问用户，只有用户输入 “y” 时才会真正执行该条命令。<br></p>
<div class="highlight"><pre><span></span>echo "*.c" "*.cpp" "*.h" | xargs -n 1 -p find . -name
</pre></div>
</div>
</div>

<div id="outline-container-orgb1fdc2a" class="outline-2">
<h2 id="orgb1fdc2a">使用 <code>-I</code> 参数让 <code>xargs</code> 进行参数替换</h2>
<div class="outline-text-2" id="text-orgb1fdc2a">
<p>
<code>xargs</code> 默认会将读取到的内容追加在指令命令后面作为参数，使用 <code>-I</code> 参数能够控制命令参数的组合方式。<br>
以下命令会将当前目录中的可执行文件移动到bin文件夹下。<br></p>
<div class="highlight"><pre><span></span>find . -executable -type f -print0 | xargs -0 -I {} mv {} ./bin
</pre></div>
</div>
</div>

<div id="outline-container-org3deba85" class="outline-2">
<h2 id="org3deba85">参考资料</h2>
<div class="outline-text-2" id="text-org3deba85">
<ol class="org-ol">
<li>
<a href="http://man7.org/linux/man-pages/man1/xargs.1.html">http://man7.org/linux/man-pages/man1/xargs.1.html</a><br>
</li>
<li>
<a href="https://www.howtoforge.com/tutorial/linux-xargs-command/">https://www.howtoforge.com/tutorial/linux-xargs-command/</a><br>
</li>
<li>
<a href="https://www.thegeekstuff.com/2013/12/xargs-examples">https://www.thegeekstuff.com/2013/12/xargs-examples</a><br>
</li>
</ol>
<p>
（全文完）<br></p>
</div>
</div>

  </li>

</ul>
</div>




    

  <ul class="index-pager hidden-print">
<li class="previous">
        <a href="/index-10.html" rel="next">&lt; Older posts</a>
    </li>
    <li class="next">
        <a href="/index-8.html" rel="prev">Newer posts &gt;</a>
    </li>
  </ul>
</div>
  </main><footer class="site-footer h-card"><div class="wrapper">
      <div class="footer-col-wrapper">

        <div class="footer-col">
          <p class="site-desc">Personal handnote on software development</p>
        </div>

        <div class="footer-col">
          <div class="p-name">Samson Wang</div>
          <div class="copyright">Copyright 2023, all rights reserved.</div>
          <div class="social-links">
            <ul class="social-media-list">
<li><a rel="me" href="/rss.xml">
                <svg class="svg-icon grey"><use href="/assets/svg/social-icons.svg#rss"></use></svg></a></li>
              <li><a rel="nofollow" href="https://github.com/samsonwang">
                <svg class="svg-icon grey"><use href="/assets/svg/social-icons.svg#github"></use></svg></a></li>
              <li><a rel="nofollow" href="https://twitter.com/samsonwangcn">
                <svg class="svg-icon grey"><use href="/assets/svg/social-icons.svg#twitter"></use></svg></a></li>
              <li><a rel="nofollow" href="https://facebook.com/samsonwangcn">
                 <svg class="svg-icon grey"><use href="/assets/svg/social-icons.svg#facebook"></use></svg></a></li>
            </ul>
</div>

        </div>

      </div>

    </div>

  </footer><div id="scroll-top" title="back to top">
  <div id="scroll-top-arrow"></div>
  <div id="scroll-top-stick"></div>
</div>


      <script src="/assets/js/lazyload.min.js"></script><script src="/assets/js/minima.min.js"></script><!-- google adsense --><script data-ad-client="ca-pub-6303134192857919" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- Google Analytics - Global site tag (gtag.js) --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-108507797-1"></script><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-108507797-1');
</script><!-- baidu tongji --><script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?1dcffb5494ab56e69005c957d7320ad1";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>
</body>
</html>
