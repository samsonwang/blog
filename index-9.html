<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns#" lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta http-equiv="x-ua-compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Hack Note (old posts, page 9) | Hack Note</title>
<meta name="description" content="Personal handnote on software development">
<meta name="theme-color" content="#04519b">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" href="/rss.xml">
<link href="/assets/css/minima.min.css" rel="stylesheet" type="text/css">
<link rel="canonical" href="https://blog.wangzhl.com/index-9.html">
<link rel="icon" href="/favicon.ico" sizes="64x64">
<link rel="prev" href="/index-8.html" type="text/html">
<link rel="next" href="/index-10.html" type="text/html">
</head>
<body>
  <header class="site-header nav-custom"><div class="wrapper">
      <a class="site-title" rel="author" href="/">Hack Note</a>
      <nav class="site-nav"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger">
          <span class="menu-icon">
            <svg viewbox="0 0 18 15" width="18px" height="15px"><use href="/assets/svg/theme.svg#menu-icon"></use></svg></span>
        </label>
        <div class="trigger">
          
            <a class="page-link" href="/">Home</a>
            <a class="page-link" href="/archive/">Archive</a>
            <a class="page-link" href="/tags/">Tags</a>
            <a class="page-link" href="/about/">About</a>

        </div>
      </nav>
</div>
  </header><main class="page-content" aria-label="Content"><div class="wrapper">

    

    


  



  


<div class="home">
  <ul class="post-list">
<li>
    <span class="post-meta">Jul 30, 2018</span>
    <h3>
      <a class="post-link" href="/posts/navigation-and-selection-effectively-in-emacs/">提高emacs中浏览和选择操作效率的技巧</a>
    </h3>

    <div id="outline-container-org82fda75" class="outline-2">
<h2 id="org82fda75">
<span class="section-number-2">1</span> 引言</h2>
<div class="outline-text-2" id="text-1">
<p>
Gaurab Paul的 <a href="https://lorefnon.tech/2018/07/14/getting-productive-with-selection-and-navigation-in-emacs/">一篇博文</a> 给了我很大的启发，他详细地介绍了emacs中的相关概念，并提供了许多充满想象力的小技巧。作为emacs的入门级选手确实学到了很多，也拓宽了自己的思路。<br></p>

<p>
我最初的开发环境是Visual Studio，这一类比较大型的IDE集成了许多功能，但同时也会束缚住使用者的想法。通过这篇文章我感受到的由普通操作指令能组合成的新编辑方式。<br></p>

<p>
如果英文水平允许的话，非常推荐阅读一下原版的博文，原文中有更加丰富形象的图片示例，无论是跟我一样刚刚入门emacs的新手，还是经验丰富的老兵，都能够从中获得启发。下面，我结合自己的理解和收获谈谈emacs中操作的体会。<br></p>
</div>
</div>


<div id="outline-container-org88aae62" class="outline-2">
<h2 id="org88aae62">
<span class="section-number-2">2</span> <code>point</code> 、 <code>mark</code> 和 <code>region</code> 的概念</h2>
<div class="outline-text-2" id="text-2">
<p>
我之前进行代码段复制的操作是十分基础的，用 <code>C-@</code> 模拟鼠标按下，方向键模拟鼠标拖动，在鼠标拖动的过程中就形成了一个选区，然后用 <code>M-w</code> 对这个选区进行复制操作，用 <code>C-y</code> 粘贴被复制的内容。<br></p>

<p>
以上操作带出了几个非常重要的概念 。在emacs中，鼠标光标所在位置被称作 <code>point</code> ；组合键 <code>C-@</code> 执行的是 <code>set-mark-command</code> 命令，就是将 <code>point</code> 所在位置标记为 <code>mark</code> ；通过移动光标，也就是移动 <code>point</code> 后，在 <code>point</code> 与 <code>mark</code> 之间就形成了 <code>region</code> 。<br></p>
</div>
</div>


<div id="outline-container-org11a6b12" class="outline-2">
<h2 id="org11a6b12">
<span class="section-number-2">3</span> <code>region</code> 操作技巧</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-orgc1affd2" class="outline-3">
<h3 id="orgc1affd2">
<span class="section-number-3">3.1</span> 调整 <code>region</code> 的大小</h3>
<div class="outline-text-3" id="text-3-1">
<p>
下面就来介绍一个非常重要的命令 <code>exchange-point-and-mark</code> ，这个命令默认被绑定在组合键 <code>C-x C-x</code> 上，从字面意思上很容易理解这条指令的作用，就是交换 <code>mark</code> 和 <code>point</code> 的位置。这样做的意义在于能够方便地切换 <code>region</code> 的可动边界，这样能够使 <code>region</code> 方便地分别从两端调整大小。<br>
下面的示例是截取自Paul的博文，需要注意的是，他习惯于使用 <code>C-SPC</code> 调用 <code>set-mark-command</code> 。<br></p>

<div class="highlight"><pre><span></span>Lorem ipsum dolor sit amet
      ^ Cursor


      Point
      |
      Mark
      |
Lorem ipsum dolor sit amet
      ^ C-spc


      Mark          Point
      | ----region--|
      |             |
Lorem ipsum dolor sit amet
	 move       ^
	 forward -&gt;


      Mark          Point
      | ----region--|
      |             |
Lorem ipsum dolor sit amet
		    ^
		    C-x C-x


      Point         Mark
      | ----region--|
      |             |
Lorem ipsum dolor sit amet

Point and mark interchanged
</pre></div>
</div>
</div>

<div id="outline-container-org945b366" class="outline-3">
<h3 id="org945b366">
<span class="section-number-3">3.2</span> 使用 <code>region</code> 进行重复性输入</h3>
<div class="outline-text-3" id="text-3-2">
<p>
对于 <code>region</code> 相关的操作，通常是对已经存在的代码段进行编辑的，如果我们在输入之前就知道有许多字段是需要重复输入的，那么就可以在输入之前设置好 <code>mark</code> ，对输入后形成的 <code>region</code> 完成复制。这个技巧在特定情况能够很大地提升输入效率，但是我个人认为，想要在实战中完成这个操作，还需要保证非常清晰的思路。可以通过下面的示例感受这种操作带来的方便(示例截取自Paul的博文)。<br></p>

<p>
<img src="/assets/images/spinner.svg" data-src="/images/post-navigation-and-selection-effectively-in-emacs-1.gif" alt="nil"><br></p>

<p>
下面给出了详细的操作解析<br></p>

<div class="highlight"><pre><span></span>class
      ^ C-spc =&gt; Activate mark

class Foo
	  ^ M-w =&gt; Foo has now been killed (copied)

class Foo extends React.Component&lt;
				  ^ C-spc =&gt; Activate mark

class Foo extends React.Component&lt;
				  ^ C-y =&gt; Yank (paste) Foo

class Foo extends React.Component&lt;FooProps
					  ^ M-w =&gt; FooProps has now been killed (copied)

class Foo extends React.Component&lt;FooProps&gt;

// Later
interface
	   ^ C-y =&gt; Yank FooProps

interface FooProps {}
</pre></div>
</div>
</div>

<div id="outline-container-org1174322" class="outline-3">
<h3 id="org1174322">
<span class="section-number-3">3.3</span> 框选一个矩形的 <code>region</code>
</h3>
<div class="outline-text-3" id="text-3-3">
<p>
使用 <code>rectangle-mark-mode</code> 命令，默认快捷键 <code>C-x-SPC</code> ，能够框选出一个矩形的 <code>region</code> 。对于矩形 <code>region</code> ，Paul给出的示例是复制 <code>dired</code> 中的多个文件名称，貌似其他合适的使用场景不太多。<br></p>

<p>
<img src="/assets/images/spinner.svg" data-src="/images/post-navigation-and-selection-effectively-in-emacs-2.gif" alt="nil"><br></p>
</div>
</div>
</div>


<div id="outline-container-orge315351" class="outline-2">
<h2 id="orge315351">
<span class="section-number-2">4</span> 其他插件支持</h2>
<div class="outline-text-2" id="text-4">
<p>
有些插件拓展能够实现光标的快速定位，如 <a href="https://github.com/ShingoFukuyama/helm-swoop">helm-swoop</a> 和 <a href="https://github.com/abo-abo/avy">avy</a> 。<br></p>
</div>

<div id="outline-container-org05c9e04" class="outline-3">
<h3 id="org05c9e04">
<span class="section-number-3">4.1</span> helm swoop</h3>
<div class="outline-text-3" id="text-4-1">
<p>
从我个人的使用体验来看 <a href="https://github.com/ShingoFukuyama/helm-swoop">helm-swoop</a> 和helm occur的功能十分相似，它们都提供了方便的关键词跳转功能。<br></p>

<p>
下面的图片来自helm swoop的 <a href="https://github.com/ShingoFukuyama/helm-swoop">主页</a><br></p>

<p>
<img src="/assets/images/spinner.svg" data-src="/images/post-navigation-and-selection-effectively-in-emacs-3.gif" alt="nil"><br></p>
</div>
</div>

<div id="outline-container-org64b48a9" class="outline-3">
<h3 id="org64b48a9">
<span class="section-number-3">4.2</span> avy</h3>
<div class="outline-text-3" id="text-4-2">
<p>
<a href="https://github.com/abo-abo/avy">avy</a> 的思路非常独特，这样的跳转和定位让我想起了Chrome浏览器中的Vimium插件，他允许我们使用更少的按键就能跳转到当前buffer中的任意位置，略微遗憾的是它只支持拉丁字母，不过在编写代码的大多数情况下是够用的。<br></p>

<p>
下面的图片来自Paul的博文<br></p>

<p>
<img src="/assets/images/spinner.svg" data-src="/images/post-navigation-and-selection-effectively-in-emacs-4.gif" alt="nil"><br></p>
</div>
</div>
</div>


<div id="outline-container-org27a43b2" class="outline-2">
<h2 id="org27a43b2">
<span class="section-number-2">5</span> 参考资料</h2>
<div class="outline-text-2" id="text-5">
<ul class="org-ul">
<li>
<a href="https://lorefnon.tech/2018/07/14/getting-productive-with-selection-and-navigation-in-emacs/">lorefnon.tech</a><br>
</li>
<li>
<a href="https://github.com/ShingoFukuyama/helm-swoop">helm-swoop</a><br>
</li>
<li>
<a href="https://github.com/abo-abo/avy">avy</a><br>
</li>
</ul>
</div>
</div>

  </li>


  <li>
    <span class="post-meta">Jul 26, 2018</span>
    <h3>
      <a class="post-link" href="/posts/shell-output-redirections/">shell的输出重定向</a>
    </h3>

    <div id="outline-container-org4ebd261" class="outline-2">
<h2 id="org4ebd261">引言</h2>
<div class="outline-text-2" id="text-org4ebd261">
<p>
在linux中借助shell等命令行工具能够很方便地与操作系统交互，可以在shell中将命令或程序的输入结果重定向到特定地方，很方便地实现一些功能。这个技巧十分实用，使用输出重定向能够极大地简化我们的日常操作。<br></p>
</div>
</div>

<div id="outline-container-org50a5801" class="outline-2">
<h2 id="org50a5801">使用尖括号完成重定向</h2>
<div class="outline-text-2" id="text-org50a5801">
<p>
示例如下，运行下面的命令能够把 <code>ls</code> 命令的运行结果写入到 <code>ls-output.txt</code> 中。使用 <code>&gt;</code> 会把程序运行时本该输出到 <code>stdout</code> 的内容重定向到指定名称的文件中。<br></p>
<div class="highlight"><pre><span></span>ls . &gt; ls-output.txt
</pre></div>
<p>
可以在 <code>&gt;</code> 左面写上数字和 <code>&amp;</code> ，用以标识在重定向时的特殊用法。下面会给出一些特殊用法的实例。<br></p>
</div>

<div id="outline-container-org2b94f10" class="outline-3">
<h3 id="org2b94f10">重定向 <code>stdout</code> 到指定文件中</h3>
<div class="outline-text-3" id="text-org2b94f10">
<div class="highlight"><pre><span></span>ls . <span class="m">1</span>&gt; ls-output.txt
</pre></div>
</div>
</div>

<div id="outline-container-org336e828" class="outline-3">
<h3 id="org336e828">重定向 <code>stderr</code> 到指定文件中</h3>
<div class="outline-text-3" id="text-org336e828">
<div class="highlight"><pre><span></span>ls . <span class="m">2</span>&gt; ls-error.txt
</pre></div>
</div>
</div>

<div id="outline-container-org091336a" class="outline-3">
<h3 id="org091336a">将 <code>stdout</code> 和 <code>stdout</code> 合并再重定向到指定文件中</h3>
<div class="outline-text-3" id="text-org091336a">
<div class="highlight"><pre><span></span>ls . <span class="m">2</span>&gt;<span class="p">&amp;</span><span class="m">1</span> ls-output-and-error.txt
</pre></div>
<p>
以下命令具有相同的效果<br></p>
<div class="highlight"><pre><span></span>ls . <span class="p">&amp;</span>&gt; ls-output-and-error.txt
</pre></div>
</div>
</div>

<div id="outline-container-org053a1e0" class="outline-3">
<h3 id="org053a1e0">将程序的输出丢掉</h3>
<div class="outline-text-3" id="text-org053a1e0">
<p>
可以将输出重定向到一个特殊的文件 <code>/dev/null</code> ，所有写入到这个文件的内容都会被丢弃掉。<br></p>
<div class="highlight"><pre><span></span>program &gt; /dev/null
</pre></div>
</div>
</div>

<div id="outline-container-orga4eb2cd" class="outline-3">
<h3 id="orga4eb2cd">将输出追加到指定文件尾部</h3>
<div class="outline-text-3" id="text-orga4eb2cd">
<p>
使用一个尖括号（ <code>&gt;</code> ）能够将输出重定向到文件中，在写入文件时会覆盖掉其中的内容。如果想保留文件中的原始内容，则可以用两个尖括号（ <code>&gt;&gt;</code> ），这样就能将输出追加到文件的尾部。示例代码如下：<br></p>
<div class="highlight"><pre><span></span><span class="nb">echo</span> <span class="nb">test</span> &gt;&gt; file-output.txt
</pre></div>
</div>
</div>
</div>

<div id="outline-container-org29bc9ae" class="outline-2">
<h2 id="org29bc9ae">使用管道完成重定向</h2>
<div class="outline-text-2" id="text-org29bc9ae">
<p>
使用管道符号 <code>|</code> 能够将一个程序的输出重定向到另一个程序的输入中去。下面的命令会将 <code>ls</code> 的输出（ <code>stdout</code> ）重定向到 <code>grep</code> 的输入（ <code>stdin</code> ）中去。管道命令在linux中是最常见的用法。<br></p>
<div class="highlight"><pre><span></span>ls <span class="p">|</span> grep &lt;pattern&gt;
</pre></div>
</div>
</div>

  </li>


  <li>
    <span class="post-meta">Jul 23, 2018</span>
    <h3>
      <a class="post-link" href="/posts/notes-on-libshmcache/">libshmcache源码阅读笔记</a>
    </h3>

    <div id="outline-container-orga142ca5" class="outline-2">
<h2 id="orga142ca5">引言</h2>
<div class="outline-text-2" id="text-orga142ca5">
<p>
由于在工作中需要开发一套内存缓存服务，使用了共享内存作为多进程间的数据共享。为了提高共享内存缓存服务的性能，我找了一个类似的较为成熟的开源项目 <a href="https://github.com/happyfish100/libshmcache">libshmcache</a> ，通过研究源码学习其中的优点并改进自己的模块。<br></p>

<p>
libshmcache与redis相似的是都使用内存进行数据缓存；与redis不同的是，redis使用的进程自己申请的动态内存，而libshmcache使用的是共享内存。使用共享内存就意味着libshmcache主要的应用场景是同一台主机上的数据缓存。<br></p>

<p>
我花了一周时间阅读了比较感兴趣的部分代码，收获不少，现就以下几个方面总结一下自己的心得：<br></p>
<ul class="org-ul">
<li>纯C语言开发的代码风格<br>
</li>
<li>hash table的原理和实现<br>
</li>
<li>gcc原子化操作接口<br>
</li>
<li>有锁写和无锁读的实现细节<br>
</li>
<li>共享内存的两套函数接口(POSIX和SystemV)<br>
</li>
</ul>
</div>
</div>


<div id="outline-container-orgd9d6e29" class="outline-2">
<h2 id="orgd9d6e29">纯C语言开发时的代码风格</h2>
<div class="outline-text-2" id="text-orgd9d6e29">
<p>
我在工作中使用比较多的开发语言是C++，对于C语言编写的这样规模的项目，还是第一次仔细深入地研究。C语言使用 <code>struct</code> 作为大多数自定义数据结构的关键字，相对于C++能够使用成员函数能够对类进行功能拓展，C语言比较常用的是将这个对象作为输入参数传到函数中。<br></p>

<p>
纵观所有项目代码，我感受比较深的就是使用结构体中嵌套匿名结构体，这样做能够增强数据结构的层次感，示例代码如下：<br></p>
<div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">shmcache_context</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">pid_t</span><span class="w"> </span><span class="n">pid</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">lock_fd</span><span class="p">;</span><span class="w">    </span><span class="c1">//for file lock</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">detect_deadlock_clocks</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">shmcache_config</span><span class="w"> </span><span class="n">config</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">shm_memory_info</span><span class="w"> </span><span class="o">*</span><span class="n">memory</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="nc">shmcache_segment_info</span><span class="w"> </span><span class="n">hashtable</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	    </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="p">;</span><span class="w"></span>
<span class="w">	    </span><span class="k">struct</span><span class="w"> </span><span class="nc">shmcache_segment_info</span><span class="w"> </span><span class="o">*</span><span class="n">items</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"> </span><span class="n">values</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">segments</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">shmcache_value_allocator_context</span><span class="w"> </span><span class="n">value_allocator</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">shmcache_list</span><span class="w"> </span><span class="n">list</span><span class="p">;</span><span class="w">   </span><span class="c1">//for value recycle</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">create_segment</span><span class="p">;</span><span class="w">  </span><span class="c1">//if check segment size                                  </span>
<span class="p">};</span><span class="w"></span>
</pre></div>
<p>
注意 <code>shmcache_context</code> 中的匿名结构体 <code>segments</code> 和 <code>values</code> ，这样的写法体现了相互包含关系，也使后续的操作该数据结构的语句更加容易理解。<br></p>

<p>
另外对于联合体和位域这两种技术也是我在之前开发中使用比较少的，通过阅读源码能够让我对其有了更深刻的理解。示例代码如下：<br></p>
<div class="highlight"><pre><span></span><span class="k">union</span><span class="w"> </span><span class="nc">shm_hentry_offset</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">offset</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">:</span><span class="mi">16</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">int64_t</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">:</span><span class="mi">48</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">segment</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
<p>
这段代码使用了联合体赋予了 <code>shm_hentry_offset</code> 两种访问方式，又使用了位域将 <code>int64_t</code> 分割为两段。<br></p>
</div>
</div>


<div id="outline-container-org0a61f57" class="outline-2">
<h2 id="org0a61f57">hash table的原理和实现</h2>
<div class="outline-text-2" id="text-org0a61f57">
<p>
libshmcache内部使用的是hash table做内部缓存的数据结构，这使查找的时间复杂度是O(1)。<br>
之前看过一些介绍hash table的资料，对hash table的工作原理是有过一个基础的了解的，这次通过阅读源码，能够了解到hash table在代码实现上更加细节的内容。<br>
对于hash计算中出现的hash值冲突，即在hash计算时出现了两个不同的key在经过hash计算后得到的bucket相同，libshmcache采用的解决方案是使用linked list来存放这些相同bucket对应的value。<br></p>
</div>
</div>


<div id="outline-container-org67ec345" class="outline-2">
<h2 id="org67ec345">gcc原子化操作接口</h2>
<div class="outline-text-2" id="text-org67ec345">
<p>
使用原子化操作接口能够解决一些并发读写问题，原子化操作相对于互斥锁执行更快。原子化操作也是一种无锁编程的方式。<br></p>
</div>
</div>


<div id="outline-container-org7ce762b" class="outline-2">
<h2 id="org7ce762b">有锁写和无锁读的实现</h2>
<div class="outline-text-2" id="text-org7ce762b">
<p>
在libshmcache中，写操作通过 <code>pthread_mutex_t</code> 进行同步，而读操作是无锁的。<br>
对于写操作来说，需要对hash table进行操作，这肯定是需要同步的。<br>
将 <code>pthread_mutex_t</code> 保存在共享内存中，不同的进程通过映射共享内存就能获得同一个互斥量，通过这个互斥量就能完成进程间同步。<br></p>
</div>
</div>


<div id="outline-container-org4fda0e2" class="outline-2">
<h2 id="org4fda0e2">共享内存的两套函数接口(POSIX和SystemV)</h2>
<div class="outline-text-2" id="text-org4fda0e2">
<p>
在linux上使用共享内存时有两套接口 <code>mmap</code> 和 <code>shmget</code> 。 <code>mmap</code> 是 <code>POSIX</code> 标准的接口，而 <code>shmget</code> 是 <code>System V</code> 标准的接口，两者都能够实现进程间共享内存，但他们在使用上还是有些区别的。对于 <code>mmap</code> 来说，需要在硬盘上创建一个文件，再将该文件映射到内存中。对于 <code>shmget</code> 来说，需要指定一个key，不同的进程通过相同的key就能映射到同一片内存。<br></p>
</div>
</div>

  </li>


  <li>
    <span class="post-meta">Jul 11, 2018</span>
    <h3>
      <a class="post-link" href="/posts/cpp-bit-field/">C/C++中的位域</a>
    </h3>

    <div id="outline-container-orgb264228" class="outline-2">
<h2 id="orgb264228">什么是位域</h2>
<div class="outline-text-2" id="text-orgb264228">
<p>
<a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E6%AE%B5">维基百科</a> 给出了以下解释<br></p>
<blockquote>
<p>
位域（或称“位段”，bit field）为一种数据结构，可以把数据以位的形式紧凑的储存，并允许程序员对此结构的位进行操作。<br></p>
</blockquote>

<p>
<a href="https://en.cppreference.com/w/cpp/language/bit_field">cppreference</a> 给出了以下定义<br></p>
<blockquote>
<p>
Declares a class data member with explicit size, in bits. Adjacent bit field members may be packed to share and straddle the individual bytes.<br></p>
</blockquote>

<p>
这种数据结构的好处：<br></p>
<ul class="org-ul">
<li>可以使数据单元节省储存空间，当程序需要成千上万个数据单元时，这种方法就显得尤为重要。<br>
</li>
<li>位段可以很方便的访问一个整数值的部分内容从而可以简化程序源代码。<br>
</li>
</ul>
<p>
而位域这种数据结构的缺点在于，其内存分配与内存对齐的实现方式依赖于具体的机器和系统，在不同的平台可能有不同的结果，这导致了位域在本质上是不可移植的。<br></p>
</div>
</div>


<div id="outline-container-org25b0f69" class="outline-2">
<h2 id="org25b0f69">位域的语法</h2>
<div class="outline-text-2" id="text-org25b0f69">
<p>
下面就是位域的语法格式。<br></p>
<div class="highlight"><pre><span></span><span class="n">identifier</span><span class="p">(</span><span class="n">optional</span><span class="p">)</span><span class="w"> </span><span class="n">attr</span><span class="p">(</span><span class="n">optional</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">size</span><span class="w"></span>
</pre></div>

<p>
<b>注意</b> ：<br></p>
<ul class="org-ul">
<li>
<code>size</code> 的大小不能超过 <code>identifier</code> 所包含最大比特位个数。<br>
</li>
<li>
<code>identifier</code> 为空时表示对应的 <code>size</code> 个数的比特位不使用<br>
</li>
<li>
<code>size</code> 为0时表示根据前类型强制补齐<br>
</li>
</ul>
<p>
以下为代码示例。<br></p>

<div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">S1</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// will usually occupy 2 bytes:</span>
<span class="w">    </span><span class="c1">// 3 bits: value of b1</span>
<span class="w">    </span><span class="c1">// 2 bits: unused</span>
<span class="w">    </span><span class="c1">// 6 bits: value of b2</span>
<span class="w">    </span><span class="c1">// 2 bits: value of b3</span>
<span class="w">    </span><span class="c1">// 3 bits: unused</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">b1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">b2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="n">b3</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="nc">S2</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// will usually occupy 2 bytes:</span>
<span class="w">    </span><span class="c1">// 3 bits: value of b1</span>
<span class="w">    </span><span class="c1">// 5 bits: unused</span>
<span class="w">    </span><span class="c1">// 6 bits: value of b2</span>
<span class="w">    </span><span class="c1">// 2 bits: value of b3</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">b1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">:</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// start a new byte</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">b2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">b3</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>


<div id="outline-container-org4c18538" class="outline-3">
<h3 id="org4c18538">在 <code>size</code> 取0时如何理解</h3>
<div class="outline-text-3" id="text-org4c18538">
<p>
对于 <code>size</code> 取0时的各种情况进行了尝试，详细用例如下。思路是使用联合体能比较方便地将内存分布表示出来。<br>
如下所示，定义了如下几种情况。<br></p>

<p>
<b>case1</b><br></p>
<div class="highlight"><pre><span></span><span class="k">union</span><span class="w"> </span><span class="nc">un1</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="n">nn1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="nl">int</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="n">nn2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">st</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>

<p>
对联合体中的结构体位段进行赋值，并将联合体中的内容打印出来。<br></p>
<div class="highlight"><pre><span></span><span class="k">union</span><span class="w"> </span><span class="nc">un1</span><span class="w"> </span><span class="n">u1</span><span class="p">;</span><span class="w"></span>
<span class="n">u1</span><span class="p">.</span><span class="n">st</span><span class="p">.</span><span class="n">nn1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="n">u1</span><span class="p">.</span><span class="n">st</span><span class="p">.</span><span class="n">nn2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="n">printf</span><span class="p">(</span><span class="s">"union u1.n1=0x%08x sizeof(un1)=%zu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">u1</span><span class="p">.</span><span class="n">n1</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">un1</span><span class="p">));</span><span class="w"></span>
</pre></div>

<p>
输出结果为<br></p>
<div class="highlight"><pre><span></span><span class="k">union</span><span class="w"> </span><span class="nc">un1</span><span class="p">.</span><span class="n">n1</span><span class="o">=</span><span class="mh">0x00000001</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">un1</span><span class="p">)</span><span class="o">=</span><span class="mi">8</span><span class="w"></span>
</pre></div>

<p>
<b>case2</b><br></p>
<div class="highlight"><pre><span></span><span class="k">union</span><span class="w"> </span><span class="nc">un1</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="n">nn1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="nl">char</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="n">nn2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">st</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>

<p>
输出结果为<br></p>
<div class="highlight"><pre><span></span><span class="k">union</span><span class="w"> </span><span class="nc">un1</span><span class="p">.</span><span class="n">n1</span><span class="o">=</span><span class="mh">0x00000101</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">un1</span><span class="p">)</span><span class="o">=</span><span class="mi">4</span><span class="w"></span>
</pre></div>

<p>
<b>case3</b><br></p>
<div class="highlight"><pre><span></span><span class="k">union</span><span class="w"> </span><span class="nc">un1</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="n">nn1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="nl">short</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="n">nn2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">st</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>

<p>
输出结果为<br></p>
<div class="highlight"><pre><span></span><span class="k">union</span><span class="w"> </span><span class="nc">un1</span><span class="p">.</span><span class="n">n1</span><span class="o">=</span><span class="mh">0x00010001</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">un1</span><span class="p">)</span><span class="o">=</span><span class="mi">4</span><span class="w"></span>
</pre></div>


<p>
<b>case4</b><br></p>
<div class="highlight"><pre><span></span><span class="k">union</span><span class="w"> </span><span class="nc">un1</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="n">nn1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="nl">char</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="n">nn2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">st</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>

<p>
输出结果为<br></p>
<div class="highlight"><pre><span></span><span class="k">union</span><span class="w"> </span><span class="nc">un1</span><span class="p">.</span><span class="n">n1</span><span class="o">=</span><span class="mh">0x00000101</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">un1</span><span class="p">)</span><span class="o">=</span><span class="mi">4</span><span class="w"></span>
</pre></div>
</div>
</div>


<div id="outline-container-org2786752" class="outline-3">
<h3 id="org2786752">
<code>struct</code> 与 <code>class</code> 关键字</h3>
<div class="outline-text-3" id="text-org2786752">
<p>
多数例子都是以 <code>struct</code> 作为位域的组织标识，在C++中能否使用 <code>class</code> 作为位域的标识符呢？<br>
经过测试，是可以使用 <code>class</code> 关键字的，但是需要注意 <code>class</code> 的默认访问控制属性为 <code>private</code> 。<br></p>
</div>
</div>
</div>


<div id="outline-container-org5a51a90" class="outline-2">
<h2 id="org5a51a90">位域的常见应用场景</h2>
<div class="outline-text-2" id="text-org5a51a90">
<p>
为什么要使用位域？位域适合那些情况？<br></p>

<p>
位域的主要使用目的是节省对象的内存使用。在存放一些比较小的数据时，使用位域能够使字节中的每个比特位合理地利用起来，避免内存浪费。<br></p>

<p>
比较典型的应用是描述硬件寄存器。如果有32个一组的寄存器，每个寄存器代表一个比特位，就可以使用位域表示这组寄存器。<br></p>
</div>
</div>


<div id="outline-container-orgb92977a" class="outline-2">
<h2 id="orgb92977a">C++中的位操作接口</h2>
<div class="outline-text-2" id="text-orgb92977a">
<p>
C++中也提供了一套位操作的接口 <code>std::bitset</code> ，这套接口提供了指定比特位数据的操作接口。<br></p>
</div>
</div>


<div id="outline-container-orgc3d61e7" class="outline-2">
<h2 id="orgc3d61e7">参考资料</h2>
<div class="outline-text-2" id="text-orgc3d61e7">
<ul class="org-ul">
<li>
<a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E6%AE%B5">wikipedia - bit field</a><br>
</li>
<li>
<a href="https://en.cppreference.com/w/cpp/language/bit_field">cppreference - bit field</a><br>
</li>
<li>
<a href="https://msdn.microsoft.com/zh-cn/library/ewwyfdbe.aspx">microsoft msdn - C++ bit fileds</a><br>
</li>
<li>
<a href="https://stackoverflow.com/questions/24933242/when-to-use-bit-fields-in-c">stackoverflow - how to use bit field</a><br>
</li>
<li>
<a href="https://en.cppreference.com/w/cpp/utility/bitset">cppreference - <code>std::bitset</code></a><br>
</li>
</ul>
<p>
（全文完）<br></p>
</div>
</div>

  </li>


  <li>
    <span class="post-meta">Jul 02, 2018</span>
    <h3>
      <a class="post-link" href="/posts/gcc-built-in-functions-for-atomic-memory-access/">GCC的内存原子化操作函数接口</a>
    </h3>

    <div id="outline-container-org1544c89" class="outline-2">
<h2 id="org1544c89">
<span class="section-number-2">1</span> 原子化操作</h2>
<div class="outline-text-2" id="text-1">
<p>
在并发编程中，一个操作或一组操作是原子操作、可线性化操作、不可分操作或不可中断操作（atomic, linearizable, indivisible, uniterruptible），表示该操作执行时不可被中断的。操作的原子性能够保证操作在执行时免受中断、信号、并发进程线程的影响。另外，原子操作大多只有两种结果，要么成功并改变系统中对应的状态，要么没有相关效果。<br></p>

</div>
</div>

  </li>


  <li>
    <span class="post-meta">Jun 29, 2018</span>
    <h3>
      <a class="post-link" href="/posts/gdb-display-contents-of-memory-address/">在gdb中查看指定内存地址的内容</a>
    </h3>

    <p>
调试 C/C++ 程序时，需要打印指定内存地址的内容。我最近调试程序中的序列化模块时，需要将类对象按照指定的格式转化为二进制流，为了验证转化结果，在调试时就需要将指定内存地址中的内容打印出来。<br></p>

  </li>


  <li>
    <span class="post-meta">Jun 26, 2018</span>
    <h3>
      <a class="post-link" href="/posts/asynchronous-synchronous-and-blocking-unblocking/">同步和异步、阻塞和非阻塞</a>
    </h3>

    <div id="outline-container-orge7085f5" class="outline-2">
<h2 id="orge7085f5">
<span class="section-number-2">1</span> 同步和异步</h2>
<div class="outline-text-2" id="text-1">
<p>
同步和异步指的是在进行I/O操作完成之前，是否允许其他处理步骤继续执行。<br>
计算机中的I/O操作相对于数据处理操作时十分耗时的。<br></p>

<p>
一个简单的I/O操作方式就是启动连接并等待操作完成，但是这样的操作（同步阻塞I/O）在通信过程中会阻塞进程的处理进度。<br>
相应的，可以在启动通信的同时进行其他的处理，并不需要等待I/O操作的完成，这样的操作就被称作是异步I/O。那些依赖于I/O操作执行完成的任务会阻塞等待I/O操作的完成，其他不依赖与I/O操作的任务能够继续执行。<br></p>

<p>
同步模型常用的函数接口： <code>read</code> , <code>write</code> , <code>send</code> , <code>recv</code><br>
异步模型常用的函数接口： <code>aio_write</code> , <code>aio_read</code><br></p>
</div>

<div id="outline-container-orgae52439" class="outline-3">
<h3 id="orgae52439">
<span class="section-number-3">1.1</span> POSIX AIO</h3>
<div class="outline-text-3" id="text-1-1">
<p>
在头文件 <code>aio.h</code> 中定义，链接时使用 <code>-lrt</code><br></p>

<p>
<b>函数接口</b><br>
异步写操作<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">aio_read</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">aiocb</span><span class="o">*</span><span class="w"> </span><span class="n">aiocbp</span><span class="p">);</span><span class="w"></span>
</pre></div>

<p>
异步读操作<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">aio_write</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">aiocb</span><span class="o">*</span><span class="w"> </span><span class="n">aiocbp</span><span class="p">);</span><span class="w"></span>
</pre></div>

<p>
获取异步操作结果<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">aio_return</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">aiocb</span><span class="o">*</span><span class="w"> </span><span class="n">aiocbp</span><span class="p">);</span><span class="w"></span>
</pre></div>

<p>
获取异步操作中的错误<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">aio_error</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">aiocb</span><span class="o">*</span><span class="w"> </span><span class="n">aiocbp</span><span class="p">);</span><span class="w"></span>
</pre></div>

<p>
示例代码： <a href="https://gist.github.com/rsms/771059">github gist</a><br></p>
</div>
</div>

<div id="outline-container-org96ca98e" class="outline-3">
<h3 id="org96ca98e">
<span class="section-number-3">1.2</span> Linux AIO</h3>
<div class="outline-text-3" id="text-1-2">
<p>
在头文件 <code>libaio.h</code> 中定义，链接时使用 <code>-laio</code><br></p>

<p>
<b>函数接口</b><br>
需要注意的是aio的函数接口需要借助 <code>syscall</code> 进行调用。<br>
创建aio context对象<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">io_setup</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">nr</span><span class="p">,</span><span class="w"> </span><span class="n">aio_context_t</span><span class="o">*</span><span class="w"> </span><span class="n">ctxp</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>
销毁aio context对象<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">io_destroy</span><span class="p">(</span><span class="n">aio_context_t</span><span class="w"> </span><span class="n">ctx</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>
提交异步操作<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">io_submit</span><span class="p">(</span><span class="n">aio_context_t</span><span class="w"> </span><span class="n">ctx</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">nr</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">iocb</span><span class="o">**</span><span class="w"> </span><span class="n">iocbpp</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>
获取异步操作结果<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">io_getevents</span><span class="p">(</span><span class="n">aio_context_t</span><span class="w"> </span><span class="n">ctx</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">min_nr</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">max_nr</span><span class="p">,</span><span class="w"></span>
<span class="w">		 </span><span class="n">io_event</span><span class="o">*</span><span class="w"> </span><span class="n">events</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">timespec</span><span class="o">*</span><span class="w"> </span><span class="n">timeout</span><span class="p">);</span><span class="w"></span>
</pre></div>

<p>
示例代码:<br></p>
<ul class="org-ul">
<li>
<a href="https://gist.github.com/larytet/87f90b08643ac3de934df2cadff4989c">github gist</a><br>
</li>
<li>
<a href="http://www.xmailserver.org/eventfd-aio-test.c">xmailserver.org</a><br>
</li>
</ul>
</div>
</div>

<div id="outline-container-org30ef3dd" class="outline-3">
<h3 id="org30ef3dd">
<span class="section-number-3">1.3</span> POSIX AIO与Linux AIO的区别</h3>
<div class="outline-text-3" id="text-1-3">
<p>
摘自 <a href="https://stackoverflow.com/questions/8768083/difference-between-posix-aio-and-libaio-on-linux">stackoverflow.com</a><br></p>
<blockquote>
<p>
On linux, the two AIO implementations are fundamentally different.<br>
The POSIX AIO is a user-level implementation that performs normal blocking I/O in multiple threads, hence giving the illusion that the I/Os are asynchronous. The main reason to do this is that:<br></p>
<ul class="org-ul">
<li>it works with any filesystem<br>
</li>
<li>it works (essentially) on any operating system (keep in mind that gnu's libc is portable)<br>
</li>
<li>it works on files with buffering enabled (i.e. no O<sub>DIRECT</sub> flag set)<br>
</li>
</ul>
<p>
The main drawback is that your queue depth (i.e. the number of outstanding operations you can have in practice) is limited by the number of threads you choose to have, which also means that a slow operation on one disk may block an operation going to a different disk. It also affects which I/Os (or how many) is seen by the kernel and the disk scheduler as well.<br>
The kernel AIO (i.e. io<sub>submit</sub>() et.al.) is kernel support for asynchronous I/O operations, where the io requests are actually queued up in the kernel, sorted by whatever disk scheduler you have, presumably some of them are forwarded (in somewhat optimal order one would hope) to the actual disk as asynchronous operations (using TCQ or NCQ). The main restriction with this approach is that not all filesystems work that well or at all with async I/O (and may fall back to blocking semantics), files have to be opened with O<sub>DIRECT</sub> which comes with a whole lot of other restrictions on the I/O requests. If you fail to open your files with O<sub>DIRECT</sub>, it may still "work", as in you get the right data back, but it probably isn't done asynchronously, but is falling back to blocking semantics.<br>
Also keep in mind that io<sub>submit</sub>() can actually block on the disk under certain circumstances.<br></p>
</blockquote>
<p>
在Linux上两种AIO是完全不同的；<br>
POSIX AIO实现在用户层，实际上进行的操作是普通的多线程阻塞操作，表现为I/O操作是异步的，这种AIO的优点是兼容性和可移植性好，缺点是操作队列长度受限于最大线程数量。<br>
Linux AIO是内核提供的AIO函数接口，I/O操作请求的队列在内核中维护，这种AIO的缺点是并不支持所有的文件系统，Linux AIO在某些情况下的磁盘操作是会阻塞的。<br></p>
</div>
</div>
</div>

<div id="outline-container-org003c8fc" class="outline-2">
<h2 id="org003c8fc">
<span class="section-number-2">2</span> 阻塞和非阻塞</h2>
<div class="outline-text-2" id="text-2">
<p>
阻塞与非阻塞的概念针对的是函数是否会立即返回。<br>
非阻塞模型常与IO复用技术组合使用。<br>
可以通过函数将IO设备设置为非阻塞模式。<br></p>
</div>
</div>


<div id="outline-container-org441007d" class="outline-2">
<h2 id="org441007d">
<span class="section-number-2">3</span> 如何理解阻塞非阻塞与同步异步的区别</h2>
<div class="outline-text-2" id="text-3">
<p>
在处理 IO 的时候，阻塞和非阻塞都是同步 IO。<br>
只有使用了特殊的 API 才是异步 IO。<br></p>
</div>
</div>


<div id="outline-container-org7e932e8" class="outline-2">
<h2 id="org7e932e8">
<span class="section-number-2">4</span> 参考资料</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li>
<a href="https://blog.csdn.net/hguisu/article/details/38638183">csdn.net</a><br>
</li>
<li>
<a href="https://github.com/littledan/linux-aio%20repo">github.com linux-aio</a><br>
</li>
<li>
<a href="https://www.ibm.com/developerworks/linux/library/l-async/index.html">ibm developerworks</a><br>
</li>
</ul>
</div>
</div>

  </li>


  <li>
    <span class="post-meta">Jun 20, 2018</span>
    <h3>
      <a class="post-link" href="/posts/check-system-information-on-linux/">查看Linux系统的相关信息</a>
    </h3>

    <p>
查看Linux系统相关信息有助于排查和解决软件和硬件的兼容性问题。系统信息包括硬件信息和软件信息，硬件信息主要有CPU信息、内存信息、PCI信息、USB信息、硬盘信息等等。软件信息主要有系统版本、分区使用状态等等。本文主要介绍了获取当前Linux系统信息的命令。<br></p>

<div id="outline-container-org7f2253f" class="outline-2">
<h2 id="org7f2253f">查看系统相关信息</h2>
<div class="outline-text-2" id="text-org7f2253f">
<p>
<code>uname</code> 指令提供了查询系统信息的功能，使用该命令能够快速获取操作系统信息概览。<br></p>

<p>
查看内核名称<br></p>
<div class="highlight"><pre><span></span>uname -s
</pre></div>

<p>
查看处理器类型<br></p>
<div class="highlight"><pre><span></span>uname -p
</pre></div>

<p>
查看硬件架构<br></p>
<div class="highlight"><pre><span></span>uname -i
</pre></div>

<p>
查看内核版本<br></p>
<div class="highlight"><pre><span></span>uname -r
</pre></div>

<p>
查看所有系统信息<br></p>
<div class="highlight"><pre><span></span>uname -a
</pre></div>

<p>
查看操作系统信息（发行版信息）<br></p>
<div class="highlight"><pre><span></span>cat /etc/os-release
cat /proc/version
lsb_release -a
hostnamectl
</pre></div>
</div>
</div>

<div id="outline-container-org39ae7c9" class="outline-2">
<h2 id="org39ae7c9">查看CPU相关信息</h2>
<div class="outline-text-2" id="text-org39ae7c9">
<p>
<code>lscpu</code> 指令能够查看当前系统中CPU的详细信息，包括型号、主频、构架、大小端等信息。<br></p>
</div>
</div>

<div id="outline-container-org1dd8773" class="outline-2">
<h2 id="org1dd8773">查看硬盘相关信息</h2>
<div class="outline-text-2" id="text-org1dd8773">
<p>
<code>lsblk</code> 指令能够查看块设备（block device）的详细信息，块设备主要指系统中的存储设备如硬盘和闪存。<br></p>
</div>
</div>

<div id="outline-container-orgf8b19b4" class="outline-2">
<h2 id="orgf8b19b4">查看PCI设备的相关信息</h2>
<div class="outline-text-2" id="text-orgf8b19b4">
<p>
<code>lspci</code> 指令能够查看PCI设备的信息，PCI设备包括USB、显卡、串口、网卡等其他外围设备。<br></p>

<p>
输出树形结果<br></p>
<div class="highlight"><pre><span></span>lspci -t
</pre></div>

<p>
输出详细信息<br></p>
<div class="highlight"><pre><span></span>lspci -v
lspci -vv
</pre></div>
</div>
</div>

<div id="outline-container-orgb7091a9" class="outline-2">
<h2 id="orgb7091a9">查看USB设备的相关信息</h2>
<div class="outline-text-2" id="text-orgb7091a9">
<p>
<code>lsusb</code> 指令能够查看USBS设备的信息。<br></p>
</div>
</div>

<div id="outline-container-org3e58a5a" class="outline-2">
<h2 id="org3e58a5a">查看文件系统相关信息</h2>
<div class="outline-text-2" id="text-org3e58a5a">
<p>
<code>fdisk</code> 命令能够查看和操作linux系统的分区表。<br></p>

<p>
查看文件系统信息<br></p>
<div class="highlight"><pre><span></span>fdisk -l
</pre></div>

<p>
<code>df</code> 命令能够查看分区信息和硬盘使用信息<br></p>

<p>
使输出信息更容易理解<br></p>
<div class="highlight"><pre><span></span>df -h
</pre></div>
</div>
</div>

<div id="outline-container-orga639c84" class="outline-2">
<h2 id="orga639c84">参考资料</h2>
<div class="outline-text-2" id="text-orga639c84">
<ul class="org-ul">
<li>
<a href="https://www.tecmint.com/commands-to-collect-system-and-hardware-information-in-linux/">tecmint.com</a><br>
</li>
<li>
<a href="https://www.binarytides.com/linux-commands-hardware-info/">binarytides.com</a><br>
</li>
</ul>
</div>
</div>

  </li>


  <li>
    <span class="post-meta">Jun 14, 2018</span>
    <h3>
      <a class="post-link" href="/posts/linux-command-examples-top/">Linux常用命令行指令 - top</a>
    </h3>

    <p>
linux的top命令能够动态显示当前系统的运行状态。它能够显示操作系统的汇总信息和当前系统上的正在运行的进程列表。<br></p>

<div id="outline-container-orgde1b207" class="outline-2">
<h2 id="orgde1b207">统计信息说明</h2>
<div class="outline-text-2" id="text-orgde1b207">
<p>
(可以通过配置文件修改通计信息区的显示格式，下文所描述的都是在默认配置下的显示内容)<br></p>
</div>
<div id="outline-container-org05d04a4" class="outline-3">
<h3 id="org05d04a4">第1行</h3>
<div class="outline-text-3" id="text-org05d04a4">
<ul class="org-ul">
<li>当前系统时间<br>
</li>
<li>当前系统的启动时长<br>
</li>
<li>当前登录的用户数量<br>
</li>
<li>当前系统的平均负载（分别是1min,5min,10min的平均负载）<br>
</li>
</ul>
<p>
这一行信息也可以通过 <code>uptime</code> 和 <code>w</code> 指令获得<br></p>
</div>
</div>
<div id="outline-container-org9f2e896" class="outline-3">
<h3 id="org9f2e896">第2行</h3>
<div class="outline-text-3" id="text-org9f2e896">
<ul class="org-ul">
<li>总进程数<br>
</li>
<li>正在运行的进程数<br>
</li>
<li>休眠的进程数<br>
</li>
<li>停止的进程数<br>
</li>
<li>僵尸进程数<br>
</li>
</ul>
</div>
</div>
<div id="outline-container-org8515f03" class="outline-3">
<h3 id="org8515f03">第3行</h3>
<div class="outline-text-3" id="text-org8515f03">
<ul class="org-ul">
<li>us 用户空间占用CPU百分比<br>
</li>
<li>sy 内核空间占用CPU百分比<br>
</li>
<li>ni 用户进程空间内改变过优先级的进程占用CPU百分比<br>
</li>
<li>id 空闲CPU百分比<br>
</li>
<li>wa 等待输入输出的CPU时间百分比<br>
</li>
<li>hi CPU服务于硬件中断所耗费的时间总额<br>
</li>
<li>si CPU服务软中断所耗费的时间总额<br>
</li>
<li>st Steal time 虚拟机被hypervisor偷去的CPU时间（如果当前处于一个hypervisor下的vm，实际上hypervisor也是要消耗一部分CPU处理时间的）<br>
</li>
</ul>
</div>
</div>

<div id="outline-container-orge1cc82c" class="outline-3">
<h3 id="orge1cc82c">第4行</h3>
<div class="outline-text-3" id="text-orge1cc82c">
<ul class="org-ul">
<li>物理内存总量<br>
</li>
<li>使用的物理内存总量<br>
</li>
<li>空闲内存总量<br>
</li>
<li>用作内核缓存的内存量<br>
</li>
</ul>
</div>
</div>

<div id="outline-container-org85c52d0" class="outline-3">
<h3 id="org85c52d0">第5行</h3>
<div class="outline-text-3" id="text-org85c52d0">
<ul class="org-ul">
<li>交换区总量<br>
</li>
<li>使用的交换区总量<br>
</li>
<li>空间交换区总量<br>
</li>
<li>缓冲交换区总量<br>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org7dd5d96" class="outline-2">
<h2 id="org7dd5d96">进程信息</h2>
<div class="outline-text-2" id="text-org7dd5d96">
<p>
在top命令中按f按可以查看显示的列信息，按对应字母来开启/关闭列，大写字母表示开启，小写字母表示关闭。带*号的是默认列。<br></p>

<p>
A: PID = (Process Id) 进程Id；<br>
E: USER = (User Name) 进程所有者的用户名；<br>
H: PR = (Priority) 优先级<br>
I: NI = (Nice value) nice值。负值表示高优先级，正值表示低优先级<br>
O: VIRT = (Virtual Image (kb)) 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES<br>
Q: RES = (Resident size (kb)) 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA<br>
T: SHR = (Shared Mem size (kb)) 共享内存大小，单位kb<br>
W: S = (Process Status) 进程状态。D=不可中断的睡眠状态,R=运行,S=睡眠,T=跟踪/停止,Z=僵尸进程<br>
K: %CPU = (CPU usage) 上次更新到现在的CPU时间占用百分比<br>
N: %MEM = (Memory usage (RES)) 进程使用的物理内存百分比<br>
M: TIME+ = (CPU Time, hundredths) 进程使用的CPU时间总计，单位1/100秒<br>
b: PPID = (Parent Process Pid) 父进程Id<br>
c: RUSER = (Real user name)<br>
d: UID = (User Id) 进程所有者的用户id<br>
f: GROUP = (Group Name) 进程所有者的组名<br>
g: TTY = (Controlling Tty) 启动进程的终端名。不是从终端启动的进程则显示为 ?<br>
j: P = (Last used cpu (SMP)) 最后使用的CPU，仅在多CPU环境下有意义<br>
p: SWAP = (Swapped size (kb)) 进程使用的虚拟内存中，被换出的大小，单位kb<br>
l: TIME = (CPU Time) 进程使用的CPU时间总计，单位秒<br>
r: CODE = (Code size (kb)) 可执行代码占用的物理内存大小，单位kb<br>
s: DATA = (Data+Stack size (kb)) 可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb<br>
u: nFLT = (Page Fault count) 页面错误次数<br>
v: nDRT = (Dirty Pages count) 最后一次写入到现在，被修改过的页面数<br>
y: WCHAN = (Sleeping in Function) 若该进程在睡眠，则显示睡眠中的系统函数名<br>
z: Flags = (Task Flags &lt;sched.h&gt;) 任务标志，参考 sched.h<br>
X: COMMAND = (Command name/line) 命令名/命令行<br></p>
</div>
</div>


<div id="outline-container-org10f1827" class="outline-2">
<h2 id="org10f1827">参考资料</h2>
<div class="outline-text-2" id="text-org10f1827">
<ul class="org-ul">
<li>
<a href="https://www.tecmint.com/12-top-command-examples-in-linux/">tecmint.com</a><br>
</li>
<li>
<a href="https://blog.csdn.net/sanshiqiduer/article/details/1933625">csdn blog</a><br>
</li>
</ul>
</div>
</div>

  </li>


  <li>
    <span class="post-meta">Jun 07, 2018</span>
    <h3>
      <a class="post-link" href="/posts/cloud-server-security/">云服务器安全相关配置</a>
    </h3>

    <p>
我所租用的云服务器操作系统为CentOS Linux，在使用云服务器的过程中为了保证服务器的安全，进行了一些简单的配置，这样能够增加服务器被破解的难度。<br></p>

  </li>


  <li>
    <span class="post-meta">May 16, 2018</span>
    <h3>
      <a class="post-link" href="/posts/c-style-and-cpp-style-file-api/">C风格和C++风格的文件操作库函数总结</a>
    </h3>

    <p>
由于C++是兼容C的，所以使用C++进行文件操作时，会发现有两套库函数可以使用，它们分别是C风格的和C++风格的。<br></p>

<div id="outline-container-org490e89f" class="outline-2">
<h2 id="org490e89f">C风格的文件操作函数</h2>
<div class="outline-text-2" id="text-org490e89f">
<p>
<b>打开文件，关闭文件</b><br></p>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="nf">fopen</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">path</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">mode</span><span class="p">);</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">fclose</span><span class="p">(</span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">fp</span><span class="p">);</span><span class="w"></span>
</pre></div>

<p>
<b>读取文件，写入文件</b><br></p>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="kt">size_t</span><span class="w"> </span><span class="nf">fread</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">nmemb</span><span class="p">,</span><span class="w"> </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
<span class="kt">size_t</span><span class="w"> </span><span class="nf">fwrite</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">nmemb</span><span class="p">,</span><span class="w"> </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>
关于fread中两个表示大小的参数，在这个 <a href="https://stackoverflow.com/questions/8589425/how-does-fread-really-work">stackoverflow</a> 问题中得到了比较好的解答。<br></p>


<p>
<b>改变文件指示器的位置</b><br></p>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">fseek</span><span class="p">(</span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">whence</span><span class="p">);</span><span class="w"></span>
<span class="kt">long</span><span class="w"> </span><span class="nf">ftell</span><span class="p">(</span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">rewind</span><span class="p">(</span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</div>


<div id="outline-container-orgd6f5231" class="outline-2">
<h2 id="orgd6f5231">C++风格的文件操作函数</h2>
<div class="outline-text-2" id="text-orgd6f5231">
<p>
C++将文件操作函数封装为 <code>fstream</code> 操作类，一个文件实际上就会对应一个 <code>fstream</code> 对象，一下函数都是 <code>fstream</code> 的成员函数。<br>
文件打开和关闭<br></p>
<div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">open</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="n">ios_base</span><span class="o">::</span><span class="n">openmode</span><span class="w"> </span><span class="n">mode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ios_base</span><span class="o">::</span><span class="n">in</span><span class="o">|</span><span class="n">ios_base</span><span class="o">::</span><span class="n">out</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">open</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="n">ios_base</span><span class="o">::</span><span class="n">openmode</span><span class="w"> </span><span class="n">mode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ios_base</span><span class="o">::</span><span class="n">in</span><span class="o">|</span><span class="n">ios_base</span><span class="o">::</span><span class="n">out</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">close</span><span class="p">();</span><span class="w"></span>
</pre></div>

<p>
对于文件的读写可以才采用流运算符重载的方法完成。<br></p>
<div class="highlight"><pre><span></span><span class="k">friend</span><span class="w"> </span><span class="n">fstream</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">fstream</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ofs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">CRecord</span><span class="o">&amp;</span><span class="w"> </span><span class="n">objRecord</span><span class="p">);</span><span class="w"></span>
<span class="k">friend</span><span class="w"> </span><span class="n">fstream</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">fstream</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ifs</span><span class="p">,</span><span class="w"> </span><span class="n">CRecord</span><span class="o">&amp;</span><span class="w"> </span><span class="n">objRecord</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</div>


<div id="outline-container-orgcad3893" class="outline-2">
<h2 id="orgcad3893">题外话</h2>
<div class="outline-text-2" id="text-orgcad3893">
<p>
在liunx下，可以使用wc命令查看文件中的相关信息。wc命令会打印出该文件的行数、单词数、字符数。<br></p>
</div>
</div>

  </li>


  <li>
    <span class="post-meta">May 11, 2018</span>
    <h3>
      <a class="post-link" href="/posts/endianness-and-union-type/">字节序与union类型</a>
    </h3>

    <div id="outline-container-orga291855" class="outline-2">
<h2 id="orga291855">字节序是什么</h2>
<div class="outline-text-2" id="text-orga291855">
<p>
字节序是指在数据传输时，高位字节存储在内存中的较高位地址还是较低位地址。字节序分为大端字节序和小端字节序，两种字节序不能混用。<br></p>

<ul class="org-ul">
<li>大端字节序 ：高位字节保存在较低位地址的内存中<br>
</li>
<li>小端字节序 ：高位字节保存在较高位地址的内存中<br>
</li>
</ul>
<p>
以 <code>int n = 0x12345678;</code> 为例，大端字节序内存中的存储的顺序为 <code>0x12 0x34 0x56 0x78</code> ，小端字节序内存中的存储顺序为 <code>0x78 0x56 0x34 0x12</code> 。很明显可以看出大端字节序更符合人类的阅读习惯。<br></p>

<ul class="org-ul">
<li>常见的大端系统CPU：IBM z/Atchitecture<br>
</li>
<li>常见的小端系统CPU：intel x86<br>
</li>
</ul>
<p>
网络字节序使用的大端字节序，常用网络协议如IPv4、IPv6、TCP和UDP协议都是使用大端字节序进行数据传输的。<br></p>
</div>
</div>



<div id="outline-container-orge2777f2" class="outline-2">
<h2 id="orge2777f2">提供字节序转换功能的函数接口</h2>
<div class="outline-text-2" id="text-orge2777f2">
<p>
在网络通信接口中提供了转换主机字节序和网络字节序之间的函数接口，如下所示。<br></p>
<div class="highlight"><pre><span></span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">htonl</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">hostlong</span><span class="p">);</span><span class="w"></span>
<span class="kt">uint16_t</span><span class="w"> </span><span class="nf">htons</span><span class="p">(</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">hostshort</span><span class="p">);</span><span class="w"></span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="nf">ntohl</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">netlong</span><span class="p">);</span><span class="w"></span>
<span class="kt">uint16_t</span><span class="w"> </span><span class="nf">ntohs</span><span class="p">(</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">netshort</span><span class="p">);</span><span class="w"></span>
</pre></div>

<p>
有些时候，我们需要手动转换内存字节流，可以使用以下接口帮助实现指定字节序的转换。<br></p>

<p>
小端字节序的函数实现如下：<br></p>
<div class="highlight"><pre><span></span><span class="c1">// small endian</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="w"> </span><span class="nf">SE_GetStreamU16</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">pTemp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="p">(</span><span class="n">pTemp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">pTemp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">SE_GetStreamU32</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">pTemp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="p">(</span><span class="n">pTemp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"></span>
<span class="w">			 </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">pTemp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"></span>
<span class="w">			 </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">pTemp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"></span>
<span class="w">			 </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">pTemp</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">24</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">SE_SetStreamU16</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">pTemp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">pTemp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">pTemp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">SE_SetStreamU32</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">pTemp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">pTemp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">pTemp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">pTemp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">16</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">pTemp</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">24</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<p>
大端字节序的函数实现如下：<br></p>
<div class="highlight"><pre><span></span><span class="c1">// big endian</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="w"> </span><span class="nf">BE_GetStreamU16</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">pTemp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="p">(</span><span class="n">pTemp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">pTemp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">BE_GetStreamU32</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">pTemp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="p">(</span><span class="n">pTemp</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"></span>
<span class="w">			 </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">pTemp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"></span>
<span class="w">			 </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">pTemp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"></span>
<span class="w">			 </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">pTemp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">24</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">BE_SetStreamU16</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">pTemp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">pTemp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">pTemp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">BE_SetStreamU32</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">pTemp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">pTemp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">24</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">pTemp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">16</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">pTemp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">pTemp</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>



<div id="outline-container-orgfe0ef5d" class="outline-2">
<h2 id="orgfe0ef5d">查看当前系统的字节序</h2>
<div class="outline-text-2" id="text-orgfe0ef5d">
<p>
通过 <code>lscpu</code> 命令，能得到cpu的大端和小端信息。<br></p>
<div class="highlight"><pre><span></span>lscpu <span class="p">|</span> grep -i endian
</pre></div>

<p>
通过常用shell命令，在大端系统中会输出0，在小端系统中会输出1。<br></p>
<div class="highlight"><pre><span></span><span class="nb">echo</span> -n I <span class="p">|</span> od -to2 <span class="p">|</span> head -n1 <span class="p">|</span> cut -f2 -d<span class="s2">" "</span> <span class="p">|</span> cut -c6
</pre></div>

<p>
借助python进行判断。<br></p>
<div class="highlight"><pre><span></span>python -c <span class="s2">"import sys; print(sys.byteorder)"</span>
<span class="c1"># or</span>
python -c <span class="s2">"import sys;sys.exit(0 if sys.byteorder=='big' else 1)"</span>
</pre></div>

<p>
借助linux的ELF进行判断，查看第6个字节，小端系统中为1，大端系统中为2。<br></p>
<div class="highlight"><pre><span></span>xxd -c <span class="m">1</span> -l <span class="m">6</span> /bin/bash
<span class="c1"># or</span>
hexdump -n <span class="m">6</span> -C /bin/bash
</pre></div>

<p>
可以使用union类型验证字节序，以下示例代码在不同的字节序下会有不同的输出。<br></p>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;inttypes.h&gt;</span><span class="cp"></span>

<span class="k">typedef</span><span class="w"> </span><span class="k">union</span><span class="w"> </span><span class="nc">un</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">ch</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">un</span><span class="p">;</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">un</span><span class="w"> </span><span class="n">u</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">u</span><span class="p">.</span><span class="n">ch</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">u</span><span class="p">.</span><span class="n">ch</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">u</span><span class="p">.</span><span class="n">ch</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">u</span><span class="p">.</span><span class="n">ch</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">"u.x=0x%x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">u</span><span class="p">.</span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>


<div id="outline-container-org3add75e" class="outline-2">
<h2 id="org3add75e">参考资料</h2>
<div class="outline-text-2" id="text-org3add75e">
<ul class="org-ul">
<li>
<a href="https://en.wikipedia.org/wiki/Endianness">wikipedia.com - endianness</a><br>
</li>
<li>
<a href="https://serverfault.com/questions/163487/how-to-tell-if-a-linux-system-is-big-endian-or-little-endian">serverfault.com - how to check endian</a><br>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">wikipedia.com - ELF format</a><br>
</li>
</ul>
<p>
（全文完）<br></p>
</div>
</div>

  </li>

</ul>
</div>




    

  <ul class="index-pager hidden-print">
<li class="previous">
        <a href="/index-10.html" rel="next">&lt; Older posts</a>
    </li>
    <li class="next">
        <a href="/index-8.html" rel="prev">Newer posts &gt;</a>
    </li>
  </ul>
</div>
  </main><footer class="site-footer h-card"><div class="wrapper">
      <div class="footer-col-wrapper">

        <div class="footer-col">
          <p class="site-desc">Personal handnote on software development</p>
        </div>

        <div class="footer-col">
          <div class="p-name">Samson Wang</div>
          <div class="copyright">Copyright 2023, all rights reserved.</div>
          <div class="social-links">
            <ul class="social-media-list">
<li><a rel="me" href="/rss.xml">
                <svg class="svg-icon grey"><use href="/assets/svg/social-icons.svg#rss"></use></svg></a></li>
              <li><a rel="nofollow" href="https://github.com/samsonwang">
                <svg class="svg-icon grey"><use href="/assets/svg/social-icons.svg#github"></use></svg></a></li>
              <li><a rel="nofollow" href="https://twitter.com/samsonwangcn">
                <svg class="svg-icon grey"><use href="/assets/svg/social-icons.svg#twitter"></use></svg></a></li>
              <li><a rel="nofollow" href="https://facebook.com/samsonwangcn">
                 <svg class="svg-icon grey"><use href="/assets/svg/social-icons.svg#facebook"></use></svg></a></li>
            </ul>
</div>

        </div>

      </div>

    </div>

  </footer><div id="scroll-top" title="back to top">
  <div id="scroll-top-arrow"></div>
  <div id="scroll-top-stick"></div>
</div>


      <script src="/assets/js/lazyload.min.js"></script><script src="/assets/js/minima.min.js"></script><!-- google adsense --><script data-ad-client="ca-pub-6303134192857919" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- Google Analytics - Global site tag (gtag.js) --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-108507797-1"></script><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-108507797-1');
</script>
</body>
</html>
