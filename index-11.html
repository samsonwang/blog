<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns#" lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta http-equiv="x-ua-compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Hack Note (old posts, page 11) | Hack Note</title>
<meta name="description" content="Personal handnote on software development">
<meta name="theme-color" content="#04519b">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" href="/rss.xml">
<link href="https://cdn.jsdelivr.net/gh/samsonwang/blog@master/assets/css/minima.min.css" rel="stylesheet" type="text/css">
<link rel="canonical" href="https://blog.wangzhl.com/index-11.html">
<link rel="icon" href="/favicon.ico" sizes="64x64">
<link rel="prev" href="/index-10.html" type="text/html">
<link rel="next" href="/index-12.html" type="text/html">
</head>
<body>
  <header class="site-header nav-custom"><div class="wrapper">
      <a class="site-title" rel="author" href="/">Hack Note</a>
      <nav class="site-nav"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger">
          <span class="menu-icon">
            <svg viewbox="0 0 18 15" width="18px" height="15px"><use href="/assets/svg/theme.svg#menu-icon"></use></svg></span>
        </label>
        <div class="trigger">
          
            <a class="page-link" href="/">Home</a>
            <a class="page-link" href="/archive/">Archive</a>
            <a class="page-link" href="/tags/">Tags</a>
            <a class="page-link" href="/about/">About</a>

        </div>
      </nav>
</div>
  </header><main class="page-content" aria-label="Content"><div class="wrapper">

    

    


  



  


<div class="home">
  <ul class="post-list">
<li>
    <span class="post-meta">Sep 21, 2018</span>
    <h3>
      <a class="post-link" href="/posts/algorithm-weekly-four-sum/">每周算法：四数之和</a>
    </h3>

    <div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Description</h2>
<div class="outline-text-2" id="text-1">
<p>
Given an array <code>nums</code> of n integers and an integer <code>target</code> , are there elements <i>a</i>, <i>b</i>, <i>c</i>, and <i>d</i> in <code>nums</code> such that <i>a</i> + <i>b</i> + <i>c</i> + <i>d</i> = <code>target</code> ? Find all unique quadruplets in the array which gives the sum of <code>target</code> .<br></p>

<p>
<b>Note:</b><br>
The solution set must not contain duplicate quadruplets.<br></p>

<p>
<b>Example:</b><br></p>
<pre class="example">
Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.

A solution set is:
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]
</pre>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Solution</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">Apporach 1 暴力解法</h3>
<div class="outline-text-3" id="text-2-1">
<p>
将所有的组合穷举出来，与目标进行逐一比对，将满足条件的组合收集起来，就能得到结果。需要注意的是去除结果中的重复项。<br></p>
<div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">fourSum</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">set</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">ans</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
	    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">k</span><span class="o">=</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">m</span><span class="o">=</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
		    <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">t</span><span class="p">({</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">m</span><span class="p">]});</span>
			<span class="n">sort</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">t</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
			<span class="n">ans</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
		    <span class="p">}</span>
		<span class="p">}</span>
	    <span class="p">}</span>
	<span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">ans</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ans</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">Approach 2 拓展3sum算法</h3>
<div class="outline-text-3" id="text-2-2">
<p>
这道题的与之前的 <a href="/posts/algorithm-weekly-three-sum/" class="post-url">3 sum</a> 十分类似，通过简单的拓展就能得到该问题的解法。<br></p>
<div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">fourSum</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">ans</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">target_1</span> <span class="o">=</span> <span class="n">target</span> <span class="o">-</span> <span class="n">n1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();)</span> <span class="p">{</span>
	    <span class="kt">int</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
	    <span class="kt">int</span> <span class="n">target_2</span> <span class="o">=</span> <span class="n">target_1</span> <span class="o">-</span> <span class="n">n2</span><span class="p">;</span>

	    <span class="kt">int</span> <span class="n">front</span> <span class="o">=</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
	    <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	    <span class="k">while</span> <span class="p">(</span><span class="n">front</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">n3</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">front</span><span class="p">];</span>
		<span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">n3</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">end</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="o">==</span> <span class="n">target_2</span><span class="p">)</span> <span class="p">{</span>
		    <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">({</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">n3</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="n">end</span><span class="p">]}));</span>
		    <span class="k">do</span> <span class="p">{</span> <span class="o">++</span><span class="n">front</span><span class="p">;</span> <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">front</span> <span class="o">&lt;</span> <span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">front</span><span class="p">]</span> <span class="o">==</span> <span class="n">n3</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="o">&gt;</span> <span class="n">target_2</span><span class="p">)</span> <span class="p">{</span>
		    <span class="o">--</span><span class="n">end</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
		    <span class="o">++</span><span class="n">front</span><span class="p">;</span>
		<span class="p">}</span>
	    <span class="p">}</span>
	    <span class="k">do</span> <span class="p">{</span> <span class="o">++</span><span class="n">j</span><span class="p">;</span> <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">j</span><span class="o">&lt;</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">n2</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">do</span> <span class="p">{</span> <span class="o">++</span><span class="n">i</span><span class="p">;</span> <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">n1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">Approach 3 优化的拓展3sum算法</h3>
<div class="outline-text-3" id="text-2-3">
<p>
在 approach 2 的基础上，增加一些边界条件判断，能够很大程度上提升算法的速度。下面的代码截取自leetcode，通过增加边界条件的判断，可以明显缩短代码的运行耗时。其中注释的代码是令一种较慢边界条件的判断方法，该代码的作者进一步优化了边界条件的判断逻辑。可以说，这种解法就是压榨算法的性能。这种优化方法是值得思考和学习的。<br></p>
<div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">fourSum</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">-</span><span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">//avoid duplicate</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span>
	<span class="c1">// if (nums[i] + nums[i+1] + nums[i+2] + nums[i+3] &gt; target) break;</span>
	<span class="c1">// if (nums[i] + nums[len-3] + nums[len-2] + nums[len-1] &lt; target) continue;</span>
	<span class="c1">//version3: less tight pruning</span>
	<span class="k">if</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span>  <span class="mi">3</span> <span class="o">*</span> <span class="n">nums</span><span class="p">[</span><span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span>
	    <span class="c1">// if (nums[i] + nums[j] + nums[j+1] + nums[j+2] &gt; target) break;</span>
	    <span class="c1">// if (nums[i] + nums[j] + nums[len-2] + nums[len-1] &lt; target) continue;</span>
	    <span class="c1">//version3: less tight pruning</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nums</span><span class="p">[</span><span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
	    <span class="c1">//now the problems becomes 3 sum problem and only two other elements only to be considered</span>
	    <span class="kt">int</span> <span class="n">left</span>  <span class="o">=</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	    <span class="kt">int</span> <span class="n">sofar</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
	    <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sofar</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
		    <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">({</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]}));</span>
		    <span class="c1">//how to skip the duplicate left and right</span>
		    <span class="c1">//version1: my own version</span>
		    <span class="c1">//  left++;</span>
		    <span class="c1">//  right--;</span>
		    <span class="c1">//  while (left &lt; right &amp;&amp; nums[left-1] == nums[left])  ++left;</span>
		    <span class="c1">// while (right &gt; left &amp;&amp; nums[right+1] == nums[right]) --right;</span>
		    <span class="c1">//version2: refer others</span>
		    <span class="k">do</span><span class="p">{</span><span class="n">left</span><span class="o">++</span><span class="p">;}</span> <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span>
		    <span class="k">do</span><span class="p">{</span><span class="n">right</span><span class="o">--</span><span class="p">;}</span> <span class="k">while</span> <span class="p">(</span><span class="n">right</span> <span class="o">&gt;</span> <span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sofar</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">)</span> <span class="n">left</span><span class="o">++</span><span class="p">;</span>
		<span class="k">else</span> <span class="n">right</span><span class="o">--</span><span class="p">;</span>
	    <span class="p">}</span>
	<span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>

  </li>


  <li>
    <span class="post-meta">Sep 19, 2018</span>
    <h3>
      <a class="post-link" href="/posts/breadth-first-search/">广度优先搜索</a>
    </h3>

    <div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">引言</h2>
<div class="outline-text-2" id="text-1">
<p>
在求解 <a href="/posts/algorithm-weekly-letter-combinations-of-a-phone-number/" class="post-url">leetcode 17</a> 时，我遇到了BFS（广度优先搜索）这个概念。在深入了解后发现，BFS是图（graph）的一个知识点，我对这一知识点进行展开学习，并将找到的资料汇总起来。本文主要整理了图和广度优先搜索的相关知识点。<br></p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">图的存储方式</h2>
<div class="outline-text-2" id="text-2">
<p>
研究图就需要使用计算机语言对其进行描述。图的存储结构除了要存储图中各个顶点的本身的信息外，同时还要存储顶点与顶点之间的所有关系（边的信息）。因此，图的结构比较复杂，很难以数据元素在存储区中的物理位置来表示元素之间的关系，但也正是由于其任意的特性，故物理表示方法很多。常用的图的存储结构有邻接矩阵、邻接表、十字链表和邻接多重表。<br></p>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">相邻矩阵（adjacency martix）</h3>
<div class="outline-text-3" id="text-2-1">
<p>
对于一个具有 <code>n</code> 个顶点的图，可以使用 <code>n*n</code> 的矩阵（二维数组）来表示它们间的邻接关系。下图中，矩阵 <code>A(i，j)=1</code> 表示图中存在一条边 <code>(Vi，Vj)</code> ，而 <code>A(i，j)=0</code> 表示图中不存在边 <code>(Vi，Vj)</code> 。实际编程时，当图为不带权图时，可以在二维数组中存放bool值， <code>A(i，j)=true</code> 表示存在边 <code>(Vi，Vj)</code> ， <code>A(i，j)=false</code> 表示不存在边 <code>(Vi，Vj)</code> ；当图带权值时，则可以直接在二维数组中存放权值， <code>A(i，j)=null</code> 表示不存在边 <code>(Vi，Vj)</code> 。<br></p>

<p>
<img src="/assets/images/spinner.svg" data-src="/images/post-breadth-first-search-1.jpg" alt="图的相邻矩阵表示方法"><br></p>

<p>
左图所示的是无向图的邻接矩阵表示法，可以观察到，矩阵延对角线对称，即 <code>A(i，j)=A(j，i)</code> 。无向图邻接矩阵的第 <code>i</code> 行或第 <code>i</code> 列非零元素的个数其实就是第 <code>i</code> 个顶点的度。这表示无向图邻接矩阵存在一定的数据冗余。<br></p>

<p>
右图所示的是有向图邻接矩阵表示法，矩阵并不延对角线对称， <code>A(i，j)=1</code> 表示顶点 <code>Vi</code> 邻接到顶点 <code>Vj</code> ； <code>A(j，i)=1</code> 则表示顶点 <code>Vi</code> 邻接自顶点 <code>Vj</code> 。两者并不象无向图邻接矩阵那样表示相同的意思。有向图邻接矩阵的第 <code>i</code> 行非零元素的个数其实就是第 <code>i</code> 个顶点的出度，而第 <code>i</code> 列非零元素的个数是第 <code>i</code> 个顶点的入度，即第 <code>i</code> 个顶点的度是第 <code>i</code> 行和第 <code>i</code> 列非零元素个数之和。<br></p>

<p>
由于存在 <code>n</code> 个顶点的图需要 <code>n^2</code> 个数组元素进行存储，当图为稀疏图时，使用邻接矩阵存储方法将出现大量零元素，照成极大地空间浪费，这时应该使用邻接表表示法存储图中的数据。<br></p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">邻接表（adjacency list）</h3>
<div class="outline-text-3" id="text-2-2">
<p>
邻接表（adjacency list）是一种常用的表示图的数据结构。邻接表是许多链表的集合，每个链表描述了一个顶点（ <code>vectex</code> ）的相邻元素（ <code>Neighbor</code> ）。更形象地讲，邻接表是一个二维容器，第一维描述某个点，第二维描述这个点所对应的边集们。<br>
图的邻接矩阵存储方法跟树的孩子链表示法相类似，是一种顺序分配和链式分配相结合的存储结构。邻接表由表头结点和表结点两部分组成，其中图中每个顶点均对应一个存储在数组中的表头结点。如这个表头结点所对应的顶点存在相邻顶点，则把相邻顶点依次存放于表头结点所指向的单向链表中。如下图所示，表结点存放的是邻接顶点在数组中的索引。对于无向图来说，使用邻接表进行存储也会出现数据冗余，表头结点 <code>A</code> 所指链表中存在一个指向 <code>C</code> 的表结点的同时，表头结点 <code>C</code> 所指链表也会存在一个指向 <code>A</code> 的表结点。<br><img src="/assets/images/spinner.svg" data-src="/images/post-breadth-first-search-2.jpg" alt="图的相邻表表示方法"><br></p>

<p>
有向图的邻接表有出边表和入边表（又称逆邻接表）之分。出边表的表结点存放的是从表头结点出发的有向边所指的尾顶点；入边表的表结点存放的则是指向表头结点的某个头顶点。如下图所示，图(b)和(c)分别为有向图(a)的出边表和入边表。<br><img src="/assets/images/spinner.svg" data-src="/images/post-breadth-first-search-3.jpg" alt="有向图的相邻表表示方法"><br></p>

<p>
以上所讨论的邻接表所表示的都是不带权的图，如果要表示带权图，可以在表结点中增加一个存放权的字段，其效果如下图所示。<br><img src="/assets/images/spinner.svg" data-src="/images/post-breadth-first-search-4.jpg" alt="加权图的相邻表表示方法"><br>
观察上图可以发现，当删除存储表头结点的数组中的某一元素，有可能使部分表头结点索引号的改变，从而导致大面积修改表结点的情况发生。可以在表结点中直接存放指向表头结点的指针以解决这个问题（在链表中存放类实例即是存放指针，但必须要保证表头结点是类而不是结构体）。在实际创建邻接表时，甚至可以使用链表代替数组存放表头结点或使用顺序表存代替链表存放表结点。<br></p>

<p>
本节所有的图片摘自 <a href="https://www.cnblogs.com/abatei/archive/2008/06/06/1215114.html">cnblogs.com - abatei</a><br></p>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">图的遍历</h2>
<div class="outline-text-2" id="text-3">
<p>
和树的遍历类似，在此，我们希望从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫做图的遍历(traversing graph)。如果只访问图的顶点而不关注边的信息，那么图的遍历十分简单，使用一个 <code>foreach</code> 语句遍历存放顶点信息的数组即可。但如果为了实现特定算法，就需要根据边的信息按照一定顺序进行遍历。图的遍历算法是求解图的连通性问题、拓扑排序和求关键路径等算法的基础。<br></p>

<p>
图的遍历要比树的遍历复杂得多，由于图的任一顶点都可能和其余顶点相邻接，故在访问了某顶点之后，可能顺着某条边又访问到了已访问过的顶点，因此，在图的遍历过程中，必须记下每个访问过的顶点，以免同一个顶点被访问多次。为此给顶点附设访问标志 <code>visited</code> ，其初值为 <code>false</code> ，一旦某个顶点被访问，则其 <code>visited</code> 标志置为 <code>true</code> 。<br></p>

<p>
图的遍历方法有两种：一种是深度优先搜索遍历（depth first search 简称DFS），另一种是广度优先搜索遍历（breadth first search 简称BFS）。<br></p>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">广度优先搜索（breadth first search）</h2>
<div class="outline-text-2" id="text-4">
<p>
图的广度优先搜索遍历算法是一个分层遍历的过程，和二叉树的广度优先搜索遍历类同。它从图的某一顶点 <code>Vi</code> 出发，访问此顶点后，依次访问 <code>Vi</code> 的各个未曾访问过的邻接点，然后分别从这些邻接点出发，直至图中所有已有已被访问的顶点的邻接点都被访问到。对于无向连通图，若顶点 <code>Vi</code> 为初始访问的顶点，则广度优先搜索遍历顺序如下所示。<br><img src="/assets/images/spinner.svg" data-src="/images/post-breadth-first-search-5.jpg" alt="图的广度优先搜索遍历"><br></p>

<p>
广度优先搜索的伪代码如下：<br></p>
<pre class="example">
BFS (G, s)  // Where G is the graph and s is the source node
  let Q be queue.
  Q.enqueue( s )  // Inserting s in queue until all its neighbour vertices are marked.

  mark s as visited.

  while ( Q is not empty )
    // Removing that vertex from queue, whose neighbour will be visited now
    v  =  Q.dequeue( )

    // processing all the neighbours of v
    for all neighbours w of v in Graph G
      if w is not visited
        Q.enqueue( w )  // Stores w in Q to further visit its neighbour
        mark w as visited.
</pre>

<p>
<b>时间复杂度</b><br>
BFS的时间复杂度为 <code>O(V+E)</code> ，其中 <code>V</code> 是节点的数量， <code>E</code> 是边的数量。<br></p>

<p>
<b>BFS的应用场景</b><br></p>
<ul class="org-ul">
<li>最短路径问题<br>
</li>
<li>P2P网络，网络广播<br>
</li>
<li>GPS导航系统<br>
</li>
<li>搜索引擎的网络爬虫<br>
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">参考资料</h2>
<div class="outline-text-2" id="text-5">
<ul class="org-ul">
<li>
<a href="https://www.hackerearth.com/zh/practice/algorithms/graphs/breadth-first-search/tutorial/">hackerearth.com - breath first search tutorial</a><br>
</li>
<li>
<a href="http://www.cnblogs.com/abatei/archive/2010/02/25/1215114.html">cnblogs - 图的遍历</a><br>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Adjacency_matrix">wikipedia - adjacency matrix</a><br>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Adjacency_list">wikipedia - adjacency list</a><br>
</li>
<li>
<a href="https://baike.baidu.com/item/%25E9%2582%25BB%25E6%258E%25A5%25E8%25A1%25A8">百度百科 - 邻接表</a><br>
</li>
<li>
<a href="https://www.geeksforgeeks.org/applications-of-breadth-first-traversal/">geeksforgeeks - application of BFS</a><br>
</li>
</ul>
</div>
</div>

  </li>


  <li>
    <span class="post-meta">Sep 18, 2018</span>
    <h3>
      <a class="post-link" href="/posts/algorithm-weekly-letter-combinations-of-a-phone-number/">每周算法：拨号键盘上的字符组合</a>
    </h3>

    <div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Description</h2>
<div class="outline-text-2" id="text-1">
<p>
Given a string containing digits from <code>2-9</code> inclusive, return all possible letter combinations that the number could represent.<br></p>

<p>
A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.<br></p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col class="left">
<col class="left">
<col class="left">
</colgroup>
<tbody>
<tr>
<td class="left">1</td>
<td class="left">2abc</td>
<td class="left">3def</td>
</tr>
<tr>
<td class="left">4ghi</td>
<td class="left">5jkl</td>
<td class="left">6mno</td>
</tr>
<tr>
<td class="left">7pqrs</td>
<td class="left">8tuv</td>
<td class="left">9wxyz</td>
</tr>
</tbody>
</table>
<p>
<b>Example:</b><br></p>
<pre class="example">
Input: "23"
Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
</pre>

<p>
<b>Note:</b><br>
Although the above answer is in lexicographical order, your answer could be in any order you want.<br></p>

<p>
来源：<a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/">leetcode 17 letter combinations of a phone number</a><br></p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Solution</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">Approach 1</h3>
<div class="outline-text-3" id="text-2-1">
<p>
借助加法计算进位的思想，下面是我的解法。我首次提交时并没有注意输入字符串为空的情况，对于输入参数的检查还是太容易忽略了。<br></p>

<div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">letterCombinations</span><span class="p">(</span><span class="n">string</span> <span class="n">digits</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">ans</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">digits</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">letters</span> <span class="p">{</span><span class="s">""</span><span class="p">,</span>  <span class="s">""</span><span class="p">,</span> <span class="s">"abc"</span><span class="p">,</span> <span class="s">"def"</span><span class="p">,</span> <span class="s">"ghi"</span><span class="p">,</span>
	    <span class="s">"jkl"</span><span class="p">,</span> <span class="s">"mno"</span><span class="p">,</span> <span class="s">"pqrs"</span><span class="p">,</span> <span class="s">"tuv"</span><span class="p">,</span> <span class="s">"wxyz"</span><span class="p">};</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">carry</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nums</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="nl">ch</span> <span class="p">:</span> <span class="n">digits</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">ch</span> <span class="o">-</span> <span class="sc">'0'</span><span class="p">;</span>
	<span class="n">nums</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">do</span><span class="p">{</span>
	<span class="n">string</span> <span class="n">str</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">carry</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
	    <span class="n">str</span> <span class="o">+=</span> <span class="n">letters</span><span class="p">[</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="p">[</span><span class="n">carry</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
	<span class="p">}</span>
	<span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>

	<span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">carry</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
	    <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">carry</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="p">;</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">&gt;=</span> <span class="n">letters</span><span class="p">[</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]].</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">carry</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">c</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	    <span class="p">}</span>
	    <span class="k">else</span> <span class="p">{</span>
		<span class="n">carry</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
		<span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	    <span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
	    <span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>
我在想的是这个算法的时间复杂度是多少，感觉它的时间复杂度应该是O(n<sup>2</sup>)。<br></p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">Approach 2 recursive</h3>
<div class="outline-text-3" id="text-2-2">
<p>
使用递归完成字符串的拼接，在每次递归，都会增加一个字符。终止递归的条件是字符串长度达到输入参数的长度。递归方法符合生活中的使用场景，还是比较容易理解的。<br></p>

<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">mMap</span><span class="p">[</span><span class="mi">8</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="sc">'a'</span><span class="p">,</span> <span class="sc">'b'</span><span class="p">,</span> <span class="sc">'c'</span><span class="p">,</span> <span class="sc">'#'</span><span class="p">},</span>
	<span class="p">{</span><span class="sc">'d'</span><span class="p">,</span> <span class="sc">'e'</span><span class="p">,</span> <span class="sc">'f'</span><span class="p">,</span> <span class="sc">'#'</span><span class="p">},</span>
	<span class="p">{</span><span class="sc">'g'</span><span class="p">,</span> <span class="sc">'h'</span><span class="p">,</span> <span class="sc">'i'</span><span class="p">,</span> <span class="sc">'#'</span><span class="p">},</span>
	<span class="p">{</span><span class="sc">'j'</span><span class="p">,</span> <span class="sc">'k'</span><span class="p">,</span> <span class="sc">'l'</span><span class="p">,</span> <span class="sc">'#'</span><span class="p">},</span>
	<span class="p">{</span><span class="sc">'m'</span><span class="p">,</span> <span class="sc">'n'</span><span class="p">,</span> <span class="sc">'o'</span><span class="p">,</span> <span class="sc">'#'</span><span class="p">},</span>
	<span class="p">{</span><span class="sc">'p'</span><span class="p">,</span> <span class="sc">'q'</span><span class="p">,</span> <span class="sc">'r'</span><span class="p">,</span> <span class="sc">'s'</span><span class="p">},</span>
	<span class="p">{</span><span class="sc">'t'</span><span class="p">,</span> <span class="sc">'u'</span><span class="p">,</span> <span class="sc">'v'</span><span class="p">,</span> <span class="sc">'#'</span><span class="p">},</span>
	<span class="p">{</span><span class="sc">'w'</span><span class="p">,</span> <span class="sc">'x'</span><span class="p">,</span> <span class="sc">'y'</span><span class="p">,</span> <span class="sc">'z'</span><span class="p">},</span>
    <span class="p">};</span>

<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">letterCombinations</span><span class="p">(</span><span class="n">string</span> <span class="n">digits</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
	<span class="n">backTrack</span><span class="p">(</span><span class="n">digits</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="s">""</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">backTrack</span><span class="p">(</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">digits</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">,</span> <span class="n">string</span> <span class="n">combination</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">digits</span><span class="p">.</span><span class="n">length</span><span class="p">())</span> <span class="p">{</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">combination</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">return</span><span class="p">;</span>
	    <span class="p">}</span>
	    <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">combination</span><span class="p">);</span>
	    <span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">mMap</span><span class="p">[</span><span class="n">digits</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'2'</span><span class="p">])</span> <span class="p">{</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'#'</span><span class="p">)</span>
		<span class="k">continue</span><span class="p">;</span>

	    <span class="n">combination</span> <span class="o">+=</span> <span class="n">c</span><span class="p">;</span>
	    <span class="n">backTrack</span><span class="p">(</span><span class="n">digits</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">combination</span><span class="p">,</span> <span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>

	    <span class="c1">// 这里为什么要删去最后一个呢？</span>
	    <span class="c1">// 因为之前在尾部追加了一个c</span>
	    <span class="n">combination</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">combination</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>

<p>
<del>如何评估递归算法的时间复杂度和空间复杂度呢？</del><br></p>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">Approach 3 BFS</h3>
<div class="outline-text-3" id="text-2-3">
<p>
宽度优先搜索，breadth-first search（BFS）,是一种对树（tree）或图（graph）的遍历算法，下面就是这种算法的解法，代码使用java编写。<br></p>

<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">letterCombinations</span><span class="p">(</span><span class="n">String</span> <span class="n">digits</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">digits</span><span class="p">.</span><span class="na">isEmpty</span><span class="p">())</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">String</span><span class="o">[]</span> <span class="n">mapping</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">[]</span> <span class="p">{</span><span class="s">"0"</span><span class="p">,</span> <span class="s">"1"</span><span class="p">,</span> <span class="s">"abc"</span><span class="p">,</span> <span class="s">"def"</span><span class="p">,</span>
				     <span class="s">"ghi"</span><span class="p">,</span> <span class="s">"jkl"</span><span class="p">,</span> <span class="s">"mno"</span><span class="p">,</span> <span class="s">"pqrs"</span><span class="p">,</span> <span class="s">"tuv"</span><span class="p">,</span> <span class="s">"wxyz"</span><span class="p">};</span>

    <span class="n">ans</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="s">""</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">digits</span><span class="p">.</span><span class="na">length</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">Character</span><span class="p">.</span><span class="na">getNumericValue</span><span class="p">(</span><span class="n">digits</span><span class="p">.</span><span class="na">charAt</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>

	<span class="k">while</span><span class="p">(</span><span class="n">ans</span><span class="p">.</span><span class="na">peek</span><span class="p">().</span><span class="na">length</span><span class="p">()</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
	    <span class="n">String</span> <span class="n">t</span> <span class="o">=</span> <span class="n">ans</span><span class="p">.</span><span class="na">remove</span><span class="p">();</span> <span class="c1">// remove是从头部删去一个元素</span>
	    <span class="k">for</span><span class="p">(</span><span class="kt">char</span> <span class="n">s</span> <span class="p">:</span> <span class="n">mapping</span><span class="o">[</span><span class="n">x</span><span class="o">]</span><span class="p">.</span><span class="na">toCharArray</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">ans</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">s</span><span class="p">);</span> <span class="c1">// add是向尾部添加一个元素</span>
	    <span class="p">}</span>
	<span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>
下面是另外一种使用BFS算法实现的解法<br></p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">letterCombinations</span><span class="p">(</span><span class="n">String</span> <span class="n">digits</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">digits</span><span class="p">.</span><span class="na">isEmpty</span><span class="p">())</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">String</span><span class="o">[]</span> <span class="n">mapping</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">[]</span> <span class="p">{</span><span class="s">"0"</span><span class="p">,</span> <span class="s">"1"</span><span class="p">,</span> <span class="s">"abc"</span><span class="p">,</span> <span class="s">"def"</span><span class="p">,</span>
				     <span class="s">"ghi"</span><span class="p">,</span> <span class="s">"jkl"</span><span class="p">,</span> <span class="s">"mno"</span><span class="p">,</span> <span class="s">"pqrs"</span><span class="p">,</span> <span class="s">"tuv"</span><span class="p">,</span> <span class="s">"wxyz"</span><span class="p">};</span>
    <span class="n">ans</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="s">""</span><span class="p">);</span>
    <span class="k">while</span><span class="p">(</span><span class="n">ans</span><span class="p">.</span><span class="na">peek</span><span class="p">().</span><span class="na">length</span><span class="p">()</span> <span class="o">!=</span> <span class="n">digits</span><span class="p">.</span><span class="na">length</span><span class="p">()){</span>
	<span class="n">String</span> <span class="n">remove</span> <span class="o">=</span> <span class="n">ans</span><span class="p">.</span><span class="na">remove</span><span class="p">();</span>
	<span class="n">String</span> <span class="n">map</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">[</span><span class="n">digits</span><span class="p">.</span><span class="na">charAt</span><span class="p">(</span><span class="n">remove</span><span class="p">.</span><span class="na">length</span><span class="p">())</span><span class="o">-</span><span class="sc">'0'</span><span class="o">]</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">:</span> <span class="n">map</span><span class="p">.</span><span class="na">toCharArray</span><span class="p">()){</span>
	    <span class="n">ans</span><span class="p">.</span><span class="na">addLast</span><span class="p">(</span><span class="n">remove</span><span class="o">+</span><span class="n">c</span><span class="p">);</span>
	<span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Reference</h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li>
<a href="https://en.wikipedia.org/wiki/Breadth-first_search">wikipedia - breadth-first search</a><br>
</li>
</ul>
</div>
</div>

  </li>


  <li>
    <span class="post-meta">Sep 16, 2018</span>
    <h3>
      <a class="post-link" href="/posts/algorithm-weekly-three-sum-closest/">每周算法：最接近的三数之和</a>
    </h3>

    <div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Description</h2>
<div class="outline-text-2" id="text-1">
<p>
Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.<br></p>

<p>
<b>Example:</b><br></p>
<pre class="example">
Given array nums = [-1, 2, 1, -4], and target = 1.
The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
</pre>

<p>
来源：<a href="https://leetcode.com/problems/3sum-closest/description/">leetcode 16 3um closest</a><br></p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Solution</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">Approach 1</h3>
<div class="outline-text-3" id="text-2-1">
<p>
这道题与之前的“3Sum”十分类似，做起来思路是非常相似的，最容易想到的就是暴力解法，穷举出所有的组合，进而找出最接近的。<br></p>

<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">threeSumClosest</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">ans</span><span class="p">);</span>

    <span class="c1">// 穷举出所有的组合，与target比较，找到最接近的</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
	    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">sum_t</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
		<span class="kt">int</span> <span class="n">diff_t</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">sum_t</span><span class="p">);</span>

		<span class="n">ans</span> <span class="o">=</span> <span class="n">diff_t</span> <span class="o">&lt;</span> <span class="n">diff</span> <span class="o">?</span> <span class="p">(</span><span class="n">diff</span> <span class="o">=</span> <span class="n">diff_t</span><span class="p">,</span> <span class="n">sum_t</span><span class="p">)</span> <span class="o">:</span> <span class="n">ans</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ans</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
		    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
		<span class="p">}</span>
	    <span class="p">}</span>
	<span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">Approach 2</h3>
<div class="outline-text-3" id="text-2-2">
<p>
套用之前“3Sum”的O(n<sup>2</sup>)解法，下面的解法也是很容易想到的。<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">threeSumClosest</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">sort</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

    <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">ans</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">front</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">front</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
	    <span class="kt">int</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">front</span><span class="p">];</span>
	    <span class="kt">int</span> <span class="n">n3</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">end</span><span class="p">];</span>
	    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">n2</span> <span class="o">+</span> <span class="n">n3</span><span class="p">;</span>
	    <span class="kt">int</span> <span class="n">diff_t</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">sum</span><span class="p">);</span>

	    <span class="k">if</span> <span class="p">(</span><span class="n">diff</span> <span class="o">&gt;</span> <span class="n">diff_t</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ans</span> <span class="o">=</span> <span class="n">sum</span><span class="p">;</span>
		<span class="n">diff</span> <span class="o">=</span> <span class="n">diff_t</span><span class="p">;</span>
	    <span class="p">}</span>

	    <span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
	    <span class="p">}</span>
	    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">--</span><span class="n">end</span><span class="p">;</span>
	    <span class="p">}</span>
	    <span class="k">else</span> <span class="p">{</span>
		<span class="o">++</span><span class="n">front</span><span class="p">;</span>
	    <span class="p">}</span>
	<span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Reference</h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li>
<a href="https://leetcode.com/problems/3sum/description/">leetcode 3 Sum</a><br>
</li>
<li>
<a href="/posts/algorithm-weekly-three-sum/" class="post-url">my old post - 3 Sum</a><br>
</li>
</ul>
</div>
</div>

  </li>


  <li>
    <span class="post-meta">Sep 16, 2018</span>
    <h3>
      <a class="post-link" href="/posts/using-regexp-in-linux-shell/">在shell中使用正则表达式</a>
    </h3>

    <div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">引言</h2>
<div class="outline-text-2" id="text-1">
<p>
本篇文章主要是针对shell中的 <code>grep</code> 和 <code>egrep</code> 的讲解，对于正则表达式的规则本身并没有太多的内容。在阅读本篇文章之前，读者应该对正则表达式有个大致的了解。<br></p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">
<code>grep</code> 命令</h2>
<div class="outline-text-2" id="text-2">
<p>
<code>grep</code> 命令是linux终端中最常用的命令之一，它的全称是“global regular expression print”，从字面上理解， <code>grep</code> 可以用来进行正则表达式匹配。<br></p>

<p>
<b>常用选项</b><br>
使用一些选项命令能够更加方便地进行匹配<br><code>-i</code> 忽略大小写<br><code>-v</code> 进行逆向匹配<br><code>-n</code> 打印行号<br><code>--color=auto</code> 彩色输出结果<br></p>

<p>
<b>支持的表达式</b><br>
正则表达式有很多规则， <code>grep</code> 支持的有如下：<br>
在每一行的开始<br></p>
<div class="highlight"><pre><span></span>grep <span class="s2">"^GUN"</span> GPL-3
</pre></div>

<p>
在每一行的结尾<br></p>
<div class="highlight"><pre><span></span>grep <span class="s2">"and</span>$<span class="s2">"</span> GPL-3
</pre></div>

<p>
匹配任意字符<br></p>
<div class="highlight"><pre><span></span>grep <span class="s2">"..cept"</span> GPL-3
</pre></div>

<p>
在指定的字符中进行匹配<br></p>
<div class="highlight"><pre><span></span>grep <span class="s2">"t[wo]o"</span> GPL-3
</pre></div>

<p>
在指定的字符中进行逆向匹配<br></p>
<div class="highlight"><pre><span></span>grep <span class="s2">"[^c]ode"</span> GPL-3
</pre></div>

<p>
使用范围来指定字符<br></p>
<div class="highlight"><pre><span></span>grep <span class="s2">"^[A-Z]"</span> GPL-3
</pre></div>

<p>
限定出现的次数为0次或0次以上<br></p>
<div class="highlight"><pre><span></span>grep <span class="s2">"([A-Za-z ]*)"</span> GPL-3
</pre></div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">
<code>egrep</code> 命令</h2>
<div class="outline-text-2" id="text-3">
<p>
<code>egrep</code> 的含义为“extended grep”，相对于 <code>grep</code> 有更多的正则表达式特性。同样，可以在使用 <code>grep</code> 时增加 <code>-E</code> 参数获得相同的效果。<br></p>

<p>
<b>表达式分组</b><br>
使用括号能够将表达式进行分组，下面的任何一个都能够实现这个效果<br></p>
<div class="highlight"><pre><span></span>grep <span class="s2">"\(grouping\)"</span> file.txt
grep -E <span class="s2">"(grouping)"</span> file.txt
egrep <span class="s2">"(grouping)"</span> file.txt
</pre></div>

<p>
表达式进行中多选一<br></p>
<div class="highlight"><pre><span></span>egrep <span class="s2">"(GPL|General Public License)"</span> GPL-3
</pre></div>

<p>
匹配的重复次数为0次或0次以上，与 <code>*</code> 限定符类似，但是 <code>?</code> 可以作用于一组字符<br></p>
<div class="highlight"><pre><span></span>egrep <span class="s2">"(copy)?right"</span> GPL-3
</pre></div>

<p>
指定匹配的重复次数<br></p>
<div class="highlight"><pre><span></span>egrep <span class="s2">"[AEIOUaeiou]{3}"</span> GPL-3
</pre></div>
</div>
</div>


<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">参考资料</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li>
<a href="https://www.digitalocean.com/community/tutorials/using-grep-regular-expressions-to-search-for-text-patterns-in-linux">digital ocean - grep tutorial</a><br>
</li>
<li>
<a href="http://man7.org/linux/man-pages/man1/grep.1.html">linux man page</a><br>
</li>
</ul>
</div>
</div>

  </li>


  <li>
    <span class="post-meta">Sep 14, 2018</span>
    <h3>
      <a class="post-link" href="/posts/compares-between-thread-and-process/">线程与进程的比较</a>
    </h3>

    <div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">进程与线程之间有什么区别</h2>
<div class="outline-text-2" id="text-1">
<p>
进程（process）是指在系统中正在运行的一个应用程序，是系统资源分配的基本单位，在内存中有其完备的数据空间和代码空间，拥有完整的虚拟空间地址。一个进程所拥有的数据和变量只属于它自己。<br></p>

<p>
线程（thread）是进程内相对独立的可执行单元，所以也被称为轻量进程（lightweight processes）。线程是操作系统进行任务调度的基本单元，它与父进程的其它线程共享该进程所拥有的全部代码空间和全局变量，但拥有独立的堆栈（即局部变量对于线程来说是私有的）。<br></p>

<p>
进程和线程都具有就绪、阻塞和运行三种基本状态。<br></p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">联系</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>一个进程至少拥有一个线程(主线程)，也可以拥有多个线程<br>
</li>
<li>一个线程必须有一个父进程，多个进程可以并发执行<br>
</li>
<li>一个线程可以创建和撤销另一个线程<br>
</li>
<li>同一个进程中的多个线程之间可以并发执行<br>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">区别</h3>
<div class="outline-text-3" id="text-1-2">
<p>
系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销<br>
资源管理：进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。<br></p>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">通信方式</h3>
<div class="outline-text-3" id="text-1-3">
<p>
进程间通信主要包括管道、系统IPC(包括消息队列，信号量，共享存储)、SOCKET，具体说明参考linux进程间通信方式。进程间通信其实是指分属于不同进程的线程之间的通讯，所以进程间的通信方法同样适用于线程间的通信。但对于同一进程的不同线程来说，使用全局变量进行通信效率会更高。<br></p>
</div>
</div>
</div>


<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">什么情况下适合使用线程</h2>
<div class="outline-text-2" id="text-2">
<p>
线程相对于进程的优势：<br></p>
<ul class="org-ul">
<li>线程间通信（数据交互）比进程间通信更加简便快捷。<br>
</li>
<li>线程之间的上下文切换速度要比进程间的快，也就是说，对于操作系统而言，停止一个线程并启动另一个线程的速度比进程之间相似操作更快。<br>
</li>
<li>创建一个线程的速度比创建一个进程的速度快。<br>
</li>
</ul>
<p>
下面的一些情景更适合使用线程来完成：<br></p>
<ul class="org-ul">
<li>进行耗时较长的处理：当一个windows界面程序正在计算时，它就不能处理其他消息（message）了，界面就不能及时更新。<br>
</li>
<li>进行后台处理：有些任务并不是时间紧迫的，但是需要定期执行。<br>
</li>
<li>进行 <code>I/O</code> 处理： <code>I/O</code> 操作或网络操作一般都会有一定的延迟，线程能保证程序中的其他部分不会受到延迟的影响。<br>
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">什么情况下适合使用进程</h2>
<div class="outline-text-2" id="text-3">
<p>
进程相对于线程的优势：<br></p>
<ul class="org-ul">
<li>多线程系单进程的软件只能运行在一台机器上，而多进程的软件可以运行在多台机器上。这在一定程度上限制软件的可拓展性，单台机器的性能总是有限的。<br>
</li>
<li>多进程模型的鲁棒性更好，有更好的容错性。运行在同一进程下的多个线程会相互影响，如果其中的一个线程出了问题，可能会波及整个进程。<br>
</li>
<li>有些功能模块并不是线程安全的，这时就只能使用多进程模型了。<br>
</li>
</ul>
<p>
以chrome浏览器为例，它使用了多进程模型。每一个标签页都是一个进程，这样能够将渲染引擎中的bug隔离在该进程内，从而使整个程序免受影响。多进程模型将JavaScript隔离在每个进程中，这样就能防止其因占用过多的CPU或内存，使整个软件失去响应。另一方面，多进程模型的系统开销也是比较大的，这点能够从chrome的高额内存使用中看出来。不过chrome的优化策略可以让较低内存的情况下有更好内存使用效率。当一个标签页处于非激活状态，其对应的内存可以在需要时被交换进硬盘中，这样用户当前操作的页面就能够保持响应状态。如果使用的是多线程模型，区分活跃内存和非活跃内存就变得十分困难，导致内存使用效率的下降。<br></p>
</div>
</div>


<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">参考资料</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li>
<a href="https://www.backblaze.com/blog/whats-the-diff-programs-processes-and-threads/">backblaze.com - difference between process and thread</a><br>
</li>
<li>
<a href="https://docs.microsoft.com/zh-cn/windows/desktop/ProcThread/about-processes-and-threads">msdn - about processes and threads</a><br>
</li>
<li>
<a href="https://blog.csdn.net/xiexievv/article/details/7294189">csdn - blog</a><br>
</li>
<li>
<a href="https://stackoverflow.com/questions/617787/why-should-i-use-a-thread-vs-using-a-process">stackoverflow - why should I use thread vs process</a><br>
</li>
<li>
<a href="https://blog.chromium.org/2008/09/multi-process-architecture.html">chromium blog - multi process architecture</a><br>
</li>
</ul>
<p>
（全文完）<br></p>
</div>
</div>

  </li>

</ul>
</div>




    

  <ul class="index-pager hidden-print">
<li class="previous">
      <a href="/index-10.html" rel="prev">&lt; Newer posts</a>
    </li>
    <li class="next">
      <a href="/index-12.html" rel="next">Older posts &gt;</a>
    </li>
  </ul>
</div>
  </main><footer class="site-footer h-card"><div class="wrapper">
      <div class="footer-col-wrapper">

        <div class="footer-col">
          <p class="site-desc">Personal handnote on software development</p>
        </div>

        <div class="footer-col">
          <div class="p-name">Samson Wang</div>
          <div class="u-email"><a href="mailto:wangzhilv@gmail.com">wangzhilv@gmail.com</a></div>
          <div class="copyright">Copyright 2020, all rights reserved.</div>
          <div class="social-links">
            <ul class="social-media-list">
<li><a rel="me" href="/rss.xml">
                <svg class="svg-icon grey"><use href="/assets/svg/social-icons.svg#rss"></use></svg></a></li>
              <li><a rel="nofollow" href="https://github.com/samsonwang">
                <svg class="svg-icon grey"><use href="/assets/svg/social-icons.svg#github"></use></svg></a></li>
              <li><a rel="nofollow" href="https://twitter.com/samsonwangcn">
                <svg class="svg-icon grey"><use href="/assets/svg/social-icons.svg#twitter"></use></svg></a></li>
              <li><a rel="nofollow" href="https://facebook.com/samsonwangcn">
                 <svg class="svg-icon grey"><use href="/assets/svg/social-icons.svg#facebook"></use></svg></a></li>
            </ul>
</div>

        </div>

      </div>

    </div>

  </footer><div id="scroll-top" title="back to top">
  <div id="scroll-top-arrow"></div>
  <div id="scroll-top-stick"></div>
</div>


      <script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@15.1.1/dist/lazyload.min.js"></script><script src="https://cdn.jsdelivr.net/gh/samsonwang/blog@master/assets/js/minima.min.js"></script><!-- baidu tongji --><script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?1dcffb5494ab56e69005c957d7320ad1";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script><!-- Google Analytics - Global site tag (gtag.js) --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-108507797-1"></script><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-108507797-1');
</script>
</body>
</html>
