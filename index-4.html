<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#" lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="Personal handnote on software development">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Hack Note (old posts, page 4) | Hack Note</title>
<link href="/assets/css/bootstrap.min.css" rel="stylesheet" type="text/css">
<link href="/assets/css/font-awesome.min.css" rel="stylesheet" type="text/css">
<link href="/assets/css/code.css" rel="stylesheet" type="text/css">
<link href="/assets/css/colorbox.css" rel="stylesheet" type="text/css">
<link href="/assets/css/highlight.css" rel="stylesheet" type="text/css">
<link href="/assets/css/cerulean.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="en" href="/rss.xml">
<link rel="canonical" href="https://samsonwang.me/index-4.html">
<link rel="icon" href="/favicon.ico" sizes="64x64">
<link rel="prev" href="/index-3.html" type="text/html">
<link rel="next" href="/index-5.html" type="text/html">
<!--[if lt IE 9]><script src="/assets/js/html5.js"></script><![endif]-->
</head>
<body class="preload">
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->
<nav id="top-nav" class="navbar navbar-expand-md fixed-top mb-4 navbar-dark bg-dark"><div class="container">   <!-- This keeps the margins nice -->
    <a class="navbar-brand" href="/">

      <span id="blog-title">Hack Note</span>
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div class="collapse navbar-collapse" id="bs-navbar">
      <ul class="navbar-nav ml-auto">
<li class="nav-item">
<a href="/archive/" class="nav-link">Archives</a>
                </li>
<li class="nav-item">
<a href="/tags/" class="nav-link">Tags</a>
                </li>
<li class="nav-item">
<a href="/rss.xml" class="nav-link">RSS Feed</a>

        
      </li>
</ul>
<ul class="navbar-nav navbar-right"></ul>
</div>
<!-- /.navbar-collapse -->
  </div>
<!-- /.container -->
</nav><!-- End of Menubar --><div class="container" id="content" role="main">
  <div class="body-content">
    <!--Body content-->
    <div class="row">

      <div class="col-lg-9 col-md-9 col-sm-12 col-xs-12">
        
        


  



  


<div class="postindex">

      

  <article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/css-flexbox-layout-cheatsheet/" class="u-url">css flexbox 总结</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-08-14T11:29:35+08:00" itemprop="datePublished" title="2018-08-14 11:29">Aug 14 2018  (11:29)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/css-flexbox-layout-cheatsheet/#disqus_thread" data-disqus-identifier="cache/archives/2018/css-flexbox-layout-cheatsheet.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/css/" rel="tag">css</a></li>
        <li><a class="tag p-category" href="/tags/flexbox/" rel="tag">flexbox</a></li>
        <li><a class="tag p-category" href="/tags/layout/" rel="tag">layout</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <div id="outline-container-orgc5736f4" class="outline-2">
<h2 id="orgc5736f4">引言</h2>
<div class="outline-text-2" id="text-orgc5736f4">
<p>
本文主要对css flexbox的关键点了总结，方便以后在以后的查阅。<br></p>
</div>
</div>

<div id="outline-container-orgaf17648" class="outline-2">
<h2 id="orgaf17648">容器的属性</h2>
<div class="outline-text-2" id="text-orgaf17648">
<p>
对于容器需要指定其显示方式为flexbox<br></p>
<div class="highlight"><pre><span></span><span class="nt">display</span><span class="o">:</span> <span class="nt">flex</span><span class="o">;</span>
</pre></div>

<p>
指定flex排列的方向、在排列时是否会换行，使用 <code>flex-flow</code> 可以快速设置二者属性<br></p>
<div class="highlight"><pre><span></span><span class="nt">flex-direction</span><span class="o">:</span> <span class="nt">row</span> <span class="o">|</span> <span class="nt">row-reverse</span> <span class="o">|</span> <span class="nt">column</span> <span class="o">|</span> <span class="nt">column-reverse</span><span class="o">;</span>
<span class="nt">flex-wrap</span><span class="o">:</span> <span class="nt">nowrap</span> <span class="o">|</span> <span class="nt">wrap</span> <span class="o">|</span> <span class="nt">wrap-reverse</span><span class="o">;</span>
<span class="nt">flex-flow</span><span class="o">:</span> <span class="o">&lt;</span><span class="s1">'flex-direction'</span><span class="o">&gt;</span> <span class="o">||</span> <span class="o">&lt;</span><span class="s1">'flex-wrap'</span><span class="o">&gt;;</span>
</pre></div>

<p>
用于调整主轴方向的排布（对于 <code>row</code> 来说就是横向，对于 <code>column</code> 来说就是纵向）<br></p>
<div class="highlight"><pre><span></span><span class="nt">justify-content</span><span class="o">:</span> <span class="nt">flex-start</span> <span class="o">|</span> <span class="nt">flex-end</span> <span class="o">|</span> <span class="nt">center</span>
	       <span class="o">|</span> <span class="nt">space-between</span> <span class="o">|</span> <span class="nt">space-around</span> <span class="o">|</span> <span class="nt">space-evenly</span><span class="o">;</span>
</pre></div>

<p>
用于调整相交轴方向的行间排布（对于 <code>row</code> 来说就是纵向，对于 <code>column</code> 来说就是横向）<br></p>
<div class="highlight"><pre><span></span><span class="nt">align-content</span><span class="o">:</span> <span class="nt">flex-start</span> <span class="o">|</span> <span class="nt">flex-end</span> <span class="o">|</span> <span class="nt">center</span>
	     <span class="o">|</span> <span class="nt">stretch</span> <span class="o">|</span> <span class="nt">space-between</span> <span class="o">|</span> <span class="nt">space-around</span><span class="o">;</span>
</pre></div>

<p>
用于调整相交交轴方向的单行对齐方式。需要注意的是其中 <code>center</code> 和 <code>baseline</code> 的区别： 二者都表示居中，而 <code>baseline</code> 会保证所有文字的底边处在同一条线上。<br></p>
<div class="highlight"><pre><span></span><span class="nt">align-items</span><span class="o">:</span> <span class="nt">flex-start</span> <span class="o">|</span> <span class="nt">flex-end</span> <span class="o">|</span> <span class="nt">center</span> <span class="o">|</span> <span class="nt">baseline</span> <span class="o">|</span> <span class="nt">stretch</span><span class="o">;</span>
</pre></div>
</div>
</div>

<div id="outline-container-org98f8a15" class="outline-2">
<h2 id="org98f8a15">条目的属性</h2>
<div class="outline-text-2" id="text-org98f8a15">
<p>
用于调整顺序<br></p>
<div class="highlight"><pre><span></span><span class="nt">order</span><span class="o">:</span> <span class="o">&lt;</span><span class="nt">integer</span><span class="o">&gt;;</span> <span class="c">/* default 0 */</span>
</pre></div>

<p>
用于调整每个条目的伸展程度<br></p>
<div class="highlight"><pre><span></span><span class="nt">flex-grow</span><span class="o">:</span> <span class="o">&lt;</span><span class="nt">number</span><span class="o">&gt;;</span> <span class="c">/* default 0 */</span>
</pre></div>

<p>
用于调整每个条目的缩小程度<br></p>
<div class="highlight"><pre><span></span><span class="nt">flex-shrink</span><span class="o">:</span> <span class="o">&lt;</span><span class="nt">number</span><span class="o">&gt;;</span> <span class="c">/* default 1 */</span>
</pre></div>

<p>
用于调整每个条目的默认尺寸<br></p>
<div class="highlight"><pre><span></span><span class="nt">flex-basis</span><span class="o">:</span> <span class="o">&lt;</span><span class="nt">length</span><span class="o">&gt;</span> <span class="o">|</span> <span class="nt">auto</span><span class="o">;</span> <span class="c">/* default auto */</span>
</pre></div>

<p>
设置flex属性，排列顺序为 <code>flex-grow</code> , <code>flex-shrink</code> , <code>flex-basis</code><br></p>
<div class="highlight"><pre><span></span><span class="nt">flex</span><span class="o">:</span> <span class="nt">none</span> <span class="o">|</span> <span class="o">[</span> <span class="o">&lt;</span><span class="s1">'flex-grow'</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="s1">'flex-shrink'</span><span class="o">&gt;?</span> <span class="o">||</span> <span class="o">&lt;</span><span class="s1">'flex-basis'</span><span class="o">&gt;</span> <span class="o">];</span>
</pre></div>

<p>
用于重载容器的 <code>align-items</code> 的设置<br></p>
<div class="highlight"><pre><span></span><span class="nt">align-self</span><span class="o">:</span> <span class="nt">auto</span> <span class="o">|</span> <span class="nt">flex-start</span> <span class="o">|</span> <span class="nt">flex-end</span> <span class="o">|</span> <span class="nt">center</span> <span class="o">|</span> <span class="nt">baseline</span> <span class="o">|</span> <span class="nt">stretch</span><span class="o">;</span>
</pre></div>
</div>
</div>


<div id="outline-container-org4f543f2" class="outline-2">
<h2 id="org4f543f2">参考资料</h2>
<div class="outline-text-2" id="text-org4f543f2">
<ul class="org-ul">
<li>
<a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/">css-tricks.com</a><br>
</li>
<li>
<a href="https://www.w3.org/TR/css-flexbox-1/">w3.org css-flexbox</a><br>
</li>
</ul>
</div>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/using-keyboard-marcos-in-emacs/" class="u-url">emacs的键盘宏（keyboard macro）</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-08-11T10:26:32+08:00" itemprop="datePublished" title="2018-08-11 10:26">Aug 11 2018  (10:26)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/using-keyboard-marcos-in-emacs/#disqus_thread" data-disqus-identifier="cache/archives/2018/using-keyboard-marcos-in-emacs.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/emacs/" rel="tag">emacs</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <p>
对于一些有规律且重复性的编辑任务, 手动完成十分无聊, 并且需要耗费较长的时间。我在youtube上看到一个使用keyboard marco的 <a href="https://youtu.be/wFCO__0prCM">视频</a> 后, 受到很大的启发, 在以后的使用中也会尝试使用宏。我总结了一下视频中的技巧要点，并查阅资料对相关知识点进行了补充和完善。<br></p>

<p>
有梯子的同学可以去看看，视频地址：<a href="https://youtu.be/wFCO__0prCM">https://youtu.be/wFCO__0prCM</a><br></p>

<p>
<b>操作指令</b><br>
开始记录宏: 命令名称 <code>kmacro-start-macro</code> , 快捷键 <code>C-x-(</code> 或 <code>&lt;f3&gt;</code><br>
结束记录宏: 命令名称 <code>kmacro-end-macro</code> , 快捷键 <code>C-x-)</code> 或 <code>&lt;f4&gt;</code><br>
执行宏: 命令名称 <code>kmacro-end-and-call-macro</code> , 快捷键 <code>C-x-e</code> , 可以使用 <code>C-u</code> 指定这个宏的执行次数<br>
清除多余的空格: 命令名称 <code>fixup-whitespace</code> , 这个命令我是第一次见到, 以后可以尝试多用用。<br></p>

<p>
<b>参考资料</b><br></p>
<ul class="org-ul">
<li>
<a href="https://www.emacswiki.org/emacs/KeyboardMacros">emacs wiki</a><br>
</li>
</ul>
</div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/navigation-and-selection-effectively-in-emacs/" class="u-url">提高emacs中浏览和选择操作效率的技巧</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-07-30T11:14:41+08:00" itemprop="datePublished" title="2018-07-30 11:14">Jul 30 2018  (11:14)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/navigation-and-selection-effectively-in-emacs/#disqus_thread" data-disqus-identifier="cache/archives/2018/navigation-and-selection-effectively-in-emacs.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/emacs/" rel="tag">emacs</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <div id="outline-container-orgca25579" class="outline-2">
<h2 id="orgca25579">
<span class="section-number-2">1</span> 引言</h2>
<div class="outline-text-2" id="text-1">
<p>
Gaurab Paul的 <a href="https://lorefnon.tech/2018/07/14/getting-productive-with-selection-and-navigation-in-emacs/">一篇博文</a> 给了我很大的启发，他详细地介绍了emacs中的相关概念，并提供了许多充满想象力的小技巧。作为emacs的入门级选手确实学到了很多，也拓宽了自己的思路。<br></p>

<p>
我最初的开发环境是Visual Studio，这一类比较大型的IDE集成了许多功能，但同时也会束缚住使用者的想法。通过这篇文章我感受到的由普通操作指令能组合成的新编辑方式。<br></p>

<p>
如果英文水平允许的话，非常推荐阅读一下原版的博文，原文中有更加丰富形象的图片示例，无论是跟我一样刚刚入门emacs的新手，还是经验丰富的老兵，都能够从中获得启发。下面，我结合自己的理解和收获谈谈emacs中操作的体会。<br></p>
</div>
</div>


<div id="outline-container-orgd427ea6" class="outline-2">
<h2 id="orgd427ea6">
<span class="section-number-2">2</span> <code>point</code> 、 <code>mark</code> 和 <code>region</code> 的概念</h2>
<div class="outline-text-2" id="text-2">
<p>
我之前进行代码段复制的操作是十分基础的，用 <code>C-@</code> 模拟鼠标按下，方向键模拟鼠标拖动，在鼠标拖动的过程中就形成了一个选区，然后用 <code>M-w</code> 对这个选区进行复制操作，用 <code>C-y</code> 粘贴被复制的内容。<br></p>

<p>
以上操作带出了几个非常重要的概念 。在emacs中，鼠标光标所在位置被称作 <code>point</code> ；组合键 <code>C-@</code> 执行的是 <code>set-mark-command</code> 命令，就是将 <code>point</code> 所在位置标记为 <code>mark</code> ；通过移动光标，也就是移动 <code>point</code> 后，在 <code>point</code> 与 <code>mark</code> 之间就形成了 <code>region</code> 。<br></p>
</div>
</div>


<div id="outline-container-org31e8748" class="outline-2">
<h2 id="org31e8748">
<span class="section-number-2">3</span> <code>region</code> 操作技巧</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-orga4c489d" class="outline-3">
<h3 id="orga4c489d">
<span class="section-number-3">3.1</span> 调整 <code>region</code> 的大小</h3>
<div class="outline-text-3" id="text-3-1">
<p>
下面就来介绍一个非常重要的命令 <code>exchange-point-and-mark</code> ，这个命令默认被绑定在组合键 <code>C-x C-x</code> 上，从字面意思上很容易理解这条指令的作用，就是交换 <code>mark</code> 和 <code>point</code> 的位置。这样做的意义在于能够方便地切换 <code>region</code> 的可动边界，这样能够使 <code>region</code> 方便地分别从两端调整大小。<br>
下面的示例是截取自Paul的博文，需要注意的是，他习惯于使用 <code>C-SPC</code> 调用 <code>set-mark-command</code> 。<br></p>

<div class="highlight"><pre><span></span>Lorem ipsum dolor sit amet
      ^ Cursor


      Point
      |
      Mark
      |
Lorem ipsum dolor sit amet
      ^ C-spc


      Mark          Point
      | ----region--|
      |             |
Lorem ipsum dolor sit amet
	 move       ^
	 forward -&gt;


      Mark          Point
      | ----region--|
      |             |
Lorem ipsum dolor sit amet
		    ^
		    C-x C-x


      Point         Mark
      | ----region--|
      |             |
Lorem ipsum dolor sit amet

Point and mark interchanged
</pre></div>
</div>
</div>

<div id="outline-container-org5137eab" class="outline-3">
<h3 id="org5137eab">
<span class="section-number-3">3.2</span> 使用 <code>region</code> 进行重复性输入</h3>
<div class="outline-text-3" id="text-3-2">
<p>
对于 <code>region</code> 相关的操作，通常是对已经存在的代码段进行编辑的，如果我们在输入之前就知道有许多字段是需要重复输入的，那么就可以在输入之前设置好 <code>mark</code> ，对输入后形成的 <code>region</code> 完成复制。这个技巧在特定情况能够很大地提升输入效率，但是我个人认为，想要在实战中完成这个操作，还需要保证非常清晰的思路。可以通过下面的示例感受这种操作带来的方便(示例截取自Paul的博文)。<br></p>

<p>
<img src="/assets/images/spinner.svg" data-src="/images/post-navigation-and-selection-effectively-in-emacs-1.gif" alt="nil"><br></p>

<p>
下面给出了详细的操作解析<br></p>

<div class="highlight"><pre><span></span>class
      ^ C-spc =&gt; Activate mark

class Foo
	  ^ M-w =&gt; Foo has now been killed (copied)

class Foo extends React.Component&lt;
				  ^ C-spc =&gt; Activate mark

class Foo extends React.Component&lt;
				  ^ C-y =&gt; Yank (paste) Foo

class Foo extends React.Component&lt;FooProps
					  ^ M-w =&gt; FooProps has now been killed (copied)

class Foo extends React.Component&lt;FooProps&gt;

// Later
interface
	   ^ C-y =&gt; Yank FooProps

interface FooProps {}
</pre></div>
</div>
</div>

<div id="outline-container-org120f6bf" class="outline-3">
<h3 id="org120f6bf">
<span class="section-number-3">3.3</span> 框选一个矩形的 <code>region</code>
</h3>
<div class="outline-text-3" id="text-3-3">
<p>
使用 <code>rectangle-mark-mode</code> 命令，默认快捷键 <code>C-x-SPC</code> ，能够框选出一个矩形的 <code>region</code> 。对于矩形 <code>region</code> ，Paul给出的示例是复制 <code>dired</code> 中的多个文件名称，貌似其他合适的使用场景不太多。<br></p>

<p>
<img src="/assets/images/spinner.svg" data-src="/images/post-navigation-and-selection-effectively-in-emacs-2.gif" alt="nil"><br></p>
</div>
</div>
</div>


<div id="outline-container-org06ab9cf" class="outline-2">
<h2 id="org06ab9cf">
<span class="section-number-2">4</span> 其他插件支持</h2>
<div class="outline-text-2" id="text-4">
<p>
有些插件拓展能够实现光标的快速定位，如 <a href="https://github.com/ShingoFukuyama/helm-swoop">helm-swoop</a> 和 <a href="https://github.com/abo-abo/avy">avy</a> 。<br></p>
</div>

<div id="outline-container-org33a1a94" class="outline-3">
<h3 id="org33a1a94">
<span class="section-number-3">4.1</span> helm swoop</h3>
<div class="outline-text-3" id="text-4-1">
<p>
从我个人的使用体验来看 <a href="https://github.com/ShingoFukuyama/helm-swoop">helm-swoop</a> 和helm occur的功能十分相似，它们都提供了方便的关键词跳转功能。<br></p>

<p>
下面的图片来自helm swoop的 <a href="https://github.com/ShingoFukuyama/helm-swoop">主页</a><br></p>

<p>
<img src="/assets/images/spinner.svg" data-src="/images/post-navigation-and-selection-effectively-in-emacs-3.gif" alt="nil"><br></p>
</div>
</div>

<div id="outline-container-org0023c58" class="outline-3">
<h3 id="org0023c58">
<span class="section-number-3">4.2</span> avy</h3>
<div class="outline-text-3" id="text-4-2">
<p>
<a href="https://github.com/abo-abo/avy">avy</a> 的思路非常独特，这样的跳转和定位让我想起了Chrome浏览器中的Vimium插件，他允许我们使用更少的按键就能跳转到当前buffer中的任意位置，略微遗憾的是它只支持拉丁字母，不过在编写代码的大多数情况下是够用的。<br></p>

<p>
下面的图片来自Paul的博文<br></p>

<p>
<img src="/assets/images/spinner.svg" data-src="/images/post-navigation-and-selection-effectively-in-emacs-4.gif" alt="nil"><br></p>
</div>
</div>
</div>


<div id="outline-container-org05a8d52" class="outline-2">
<h2 id="org05a8d52">
<span class="section-number-2">5</span> 参考资料</h2>
<div class="outline-text-2" id="text-5">
<ul class="org-ul">
<li>
<a href="https://lorefnon.tech/2018/07/14/getting-productive-with-selection-and-navigation-in-emacs/">lorefnon.tech</a><br>
</li>
<li>
<a href="https://github.com/ShingoFukuyama/helm-swoop">helm-swoop</a><br>
</li>
<li>
<a href="https://github.com/abo-abo/avy">avy</a><br>
</li>
</ul>
</div>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/shell-output-redirections/" class="u-url">shell的输出重定向</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-07-26T10:02:41+08:00" itemprop="datePublished" title="2018-07-26 10:02">Jul 26 2018  (10:02)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/shell-output-redirections/#disqus_thread" data-disqus-identifier="cache/archives/2018/shell-output-redirections.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/linux/" rel="tag">linux</a></li>
        <li><a class="tag p-category" href="/tags/shell/" rel="tag">shell</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <div id="outline-container-org5bf91ad" class="outline-2">
<h2 id="org5bf91ad">引言</h2>
<div class="outline-text-2" id="text-org5bf91ad">
<p>
在linux中借助shell等命令行工具能够很方便地与操作系统交互，可以在shell中将命令或程序的输入结果重定向到特定地方，很方便地实现一些功能。这个技巧十分实用，使用输出重定向能够极大地简化我们的日常操作。<br></p>
</div>
</div>

<div id="outline-container-orgcdd8304" class="outline-2">
<h2 id="orgcdd8304">使用尖括号完成重定向</h2>
<div class="outline-text-2" id="text-orgcdd8304">
<p>
示例如下，运行下面的命令能够把 <code>ls</code> 命令的运行结果写入到 <code>ls-output.txt</code> 中。使用 <code>&gt;</code> 会把程序运行时本该输出到 <code>stdout</code> 的内容重定向到指定名称的文件中。<br></p>
<div class="highlight"><pre><span></span>ls . &gt; ls-output.txt
</pre></div>
<p>
可以在 <code>&gt;</code> 左面写上数字和 <code>&amp;</code> ，用以标识在重定向时的特殊用法。下面会给出一些特殊用法的实例。<br></p>
</div>

<div id="outline-container-org72444f1" class="outline-3">
<h3 id="org72444f1">重定向 <code>stdout</code> 到指定文件中</h3>
<div class="outline-text-3" id="text-org72444f1">
<div class="highlight"><pre><span></span>ls . <span class="m">1</span>&gt; ls-output.txt
</pre></div>
</div>
</div>

<div id="outline-container-org274d5db" class="outline-3">
<h3 id="org274d5db">重定向 <code>stderr</code> 到指定文件中</h3>
<div class="outline-text-3" id="text-org274d5db">
<div class="highlight"><pre><span></span>ls . <span class="m">2</span>&gt; ls-error.txt
</pre></div>
</div>
</div>

<div id="outline-container-orgf01c4d1" class="outline-3">
<h3 id="orgf01c4d1">将 <code>stdout</code> 和 <code>stdout</code> 合并再重定向到指定文件中</h3>
<div class="outline-text-3" id="text-orgf01c4d1">
<div class="highlight"><pre><span></span>ls . <span class="m">2</span>&gt;<span class="p">&amp;</span><span class="m">1</span> ls-output-and-error.txt
</pre></div>
<p>
以下命令具有相同的效果<br></p>
<div class="highlight"><pre><span></span>ls . <span class="p">&amp;</span>&gt; ls-output-and-error.txt
</pre></div>
</div>
</div>

<div id="outline-container-org60e8da9" class="outline-3">
<h3 id="org60e8da9">将程序的输出丢掉</h3>
<div class="outline-text-3" id="text-org60e8da9">
<p>
可以将输出重定向到一个特殊的文件 <code>/dev/null</code> ，所有写入到这个文件的内容都会被丢弃掉。<br></p>
<div class="highlight"><pre><span></span>program &gt; /dev/null
</pre></div>
</div>
</div>

<div id="outline-container-org0c9627c" class="outline-3">
<h3 id="org0c9627c">将输出追加到指定文件尾部</h3>
<div class="outline-text-3" id="text-org0c9627c">
<p>
使用一个尖括号（ <code>&gt;</code> ）能够将输出重定向到文件中，在写入文件时会覆盖掉其中的内容。如果想保留文件中的原始内容，则可以用两个尖括号（ <code>&gt;&gt;</code> ），这样就能将输出追加到文件的尾部。示例代码如下：<br></p>
<div class="highlight"><pre><span></span><span class="nb">echo</span> <span class="nb">test</span> &gt;&gt; file-output.txt
</pre></div>
</div>
</div>
</div>

<div id="outline-container-orgb44b278" class="outline-2">
<h2 id="orgb44b278">使用管道完成重定向</h2>
<div class="outline-text-2" id="text-orgb44b278">
<p>
使用管道符号 <code>|</code> 能够将一个程序的输出重定向到另一个程序的输入中去。下面的命令会将 <code>ls</code> 的输出（ <code>stdout</code> ）重定向到 <code>grep</code> 的输入（ <code>stdin</code> ）中去。管道命令在linux中是最常见的用法。<br></p>
<div class="highlight"><pre><span></span>ls <span class="p">|</span> grep &lt;pattern&gt;
</pre></div>
</div>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/notes-on-libshmcache/" class="u-url">libshmcache源码阅读笔记</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-07-23T10:51:59+08:00" itemprop="datePublished" title="2018-07-23 10:51">Jul 23 2018  (10:51)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/notes-on-libshmcache/#disqus_thread" data-disqus-identifier="cache/archives/2018/notes-on-libshmcache.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/c/" rel="tag">c</a></li>
        <li><a class="tag p-category" href="/tags/memcached/" rel="tag">memcached</a></li>
        <li><a class="tag p-category" href="/tags/redis/" rel="tag">redis</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <div id="outline-container-orgfc72ff0" class="outline-2">
<h2 id="orgfc72ff0">引言</h2>
<div class="outline-text-2" id="text-orgfc72ff0">
<p>
由于在工作中需要开发一套内存缓存服务，使用了共享内存作为多进程间的数据共享。为了提高共享内存缓存服务的性能，我找了一个类似的较为成熟的开源项目 <a href="https://github.com/happyfish100/libshmcache">libshmcache</a> ，通过研究源码学习其中的优点并改进自己的模块。<br></p>

<p>
libshmcache与redis相似的是都使用内存进行数据缓存；与redis不同的是，redis使用的进程自己申请的动态内存，而libshmcache使用的是共享内存。使用共享内存就意味着libshmcache主要的应用场景是同一台主机上的数据缓存。<br></p>

<p>
我花了一周时间阅读了比较感兴趣的部分代码，收获不少，现就以下几个方面总结一下自己的心得：<br></p>
<ul class="org-ul">
<li>纯C语言开发的代码风格<br>
</li>
<li>hash table的原理和实现<br>
</li>
<li>gcc原子化操作接口<br>
</li>
<li>有锁写和无锁读的实现细节<br>
</li>
<li>共享内存的两套函数接口(POSIX和SystemV)<br>
</li>
</ul>
</div>
</div>


<div id="outline-container-org0b5a5d5" class="outline-2">
<h2 id="org0b5a5d5">纯C语言开发时的代码风格</h2>
<div class="outline-text-2" id="text-org0b5a5d5">
<p>
我在工作中使用比较多的开发语言是C++，对于C语言编写的这样规模的项目，还是第一次仔细深入地研究。C语言使用 <code>struct</code> 作为大多数自定义数据结构的关键字，相对于C++能够使用成员函数能够对类进行功能拓展，C语言比较常用的是将这个对象作为输入参数传到函数中。<br></p>

<p>
纵观所有项目代码，我感受比较深的就是使用结构体中嵌套匿名结构体，这样做能够增强数据结构的层次感，示例代码如下：<br></p>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">shmcache_context</span> <span class="p">{</span>
    <span class="kt">pid_t</span> <span class="n">pid</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">lock_fd</span><span class="p">;</span>    <span class="c1">//for file lock</span>
    <span class="kt">int</span> <span class="n">detect_deadlock_clocks</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">shmcache_config</span> <span class="n">config</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">shm_memory_info</span> <span class="o">*</span><span class="n">memory</span><span class="p">;</span>
    <span class="k">struct</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">shmcache_segment_info</span> <span class="n">hashtable</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
	    <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	    <span class="k">struct</span> <span class="n">shmcache_segment_info</span> <span class="o">*</span><span class="n">items</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">values</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">segments</span><span class="p">;</span>

    <span class="k">struct</span> <span class="n">shmcache_value_allocator_context</span> <span class="n">value_allocator</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">shmcache_list</span> <span class="n">list</span><span class="p">;</span>   <span class="c1">//for value recycle</span>
    <span class="kt">bool</span> <span class="n">create_segment</span><span class="p">;</span>  <span class="c1">//if check segment size                                  </span>
<span class="p">};</span>
</pre></div>
<p>
注意 <code>shmcache_context</code> 中的匿名结构体 <code>segments</code> 和 <code>values</code> ，这样的写法体现了相互包含关系，也使后续的操作该数据结构的语句更加容易理解。<br></p>

<p>
另外对于联合体和位域这两种技术也是我在之前开发中使用比较少的，通过阅读源码能够让我对其有了更深刻的理解。示例代码如下：<br></p>
<div class="highlight"><pre><span></span><span class="k">union</span> <span class="n">shm_hentry_offset</span> <span class="p">{</span>
    <span class="kt">int64_t</span> <span class="n">offset</span><span class="p">;</span>
    <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="nl">index</span> <span class="p">:</span><span class="mi">16</span><span class="p">;</span>
	<span class="kt">int64_t</span> <span class="nl">offset</span> <span class="p">:</span><span class="mi">48</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">segment</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
<p>
这段代码使用了联合体赋予了 <code>shm_hentry_offset</code> 两种访问方式，又使用了位域将 <code>int64_t</code> 分割为两段。<br></p>
</div>
</div>


<div id="outline-container-org1c48fc3" class="outline-2">
<h2 id="org1c48fc3">hash table的原理和实现</h2>
<div class="outline-text-2" id="text-org1c48fc3">
<p>
libshmcache内部使用的是hash table做内部缓存的数据结构，这使查找的时间复杂度是O(1)。<br>
之前看过一些介绍hash table的资料，对hash table的工作原理是有过一个基础的了解的，这次通过阅读源码，能够了解到hash table在代码实现上更加细节的内容。<br>
对于hash计算中出现的hash值冲突，即在hash计算时出现了两个不同的key在经过hash计算后得到的bucket相同，libshmcache采用的解决方案是使用linked list来存放这些相同bucket对应的value。<br></p>
</div>
</div>


<div id="outline-container-orgc6337a2" class="outline-2">
<h2 id="orgc6337a2">gcc原子化操作接口</h2>
<div class="outline-text-2" id="text-orgc6337a2">
<p>
使用原子化操作接口能够解决一些并发读写问题，原子化操作相对于互斥锁执行更快。原子化操作也是一种无锁编程的方式。<br></p>
</div>
</div>


<div id="outline-container-orge73f8a7" class="outline-2">
<h2 id="orge73f8a7">有锁写和无锁读的实现</h2>
<div class="outline-text-2" id="text-orge73f8a7">
<p>
在libshmcache中，写操作通过 <code>pthread_mutex_t</code> 进行同步，而读操作是无锁的。<br>
对于写操作来说，需要对hash table进行操作，这肯定是需要同步的。<br>
将 <code>pthread_mutex_t</code> 保存在共享内存中，不同的进程通过映射共享内存就能获得同一个互斥量，通过这个互斥量就能完成进程间同步。<br></p>
</div>
</div>


<div id="outline-container-orgbc36853" class="outline-2">
<h2 id="orgbc36853">共享内存的两套函数接口(POSIX和SystemV)</h2>
<div class="outline-text-2" id="text-orgbc36853">
<p>
在linux上使用共享内存时有两套接口 <code>mmap</code> 和 <code>shmget</code> 。 <code>mmap</code> 是 <code>POSIX</code> 标准的接口，而 <code>shmget</code> 是 <code>System V</code> 标准的接口，两者都能够实现进程间共享内存，但他们在使用上还是有些区别的。对于 <code>mmap</code> 来说，需要在硬盘上创建一个文件，再将该文件映射到内存中。对于 <code>shmget</code> 来说，需要指定一个key，不同的进程通过相同的key就能映射到同一片内存。<br></p>
</div>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/bit-field/" class="u-url">C/C++中的位域</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-07-11T18:03:37+08:00" itemprop="datePublished" title="2018-07-11 18:03">Jul 11 2018  (18:03)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/bit-field/#disqus_thread" data-disqus-identifier="cache/archives/2018/bit-field.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/cpp/" rel="tag">cpp</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <div id="outline-container-org763a981" class="outline-2">
<h2 id="org763a981">
<span class="section-number-2">1</span> 什么是位域</h2>
<div class="outline-text-2" id="text-1">
<p>
<a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E6%AE%B5">维基百科</a> 给出了以下解释<br></p>
<blockquote>
<p>
位域（或称“位段”，bit field）为一种数据结构，可以把数据以位的形式紧凑的储存，并允许程序员对此结构的位进行操作。<br></p>
</blockquote>

<p>
<a href="https://en.cppreference.com/w/cpp/language/bit_field">cppreference</a> 给出了以下定义<br></p>
<blockquote>
<p>
Declares a class data member with explicit size, in bits. Adjacent bit field members may be packed to share and straddle the individual bytes.<br></p>
</blockquote>

<p>
这种数据结构的好处：<br></p>
<ul class="org-ul">
<li>可以使数据单元节省储存空间，当程序需要成千上万个数据单元时，这种方法就显得尤为重要。<br>
</li>
<li>位段可以很方便的访问一个整数值的部分内容从而可以简化程序源代码。<br>
</li>
</ul>
<p>
而位域这种数据结构的缺点在于，其内存分配与内存对齐的实现方式依赖于具体的机器和系统，在不同的平台可能有不同的结果，这导致了位段在本质上是不可移植的。<br></p>
</div>
</div>

<div id="outline-container-orgc555261" class="outline-2">
<h2 id="orgc555261">
<span class="section-number-2">2</span> 位域的语法</h2>
<div class="outline-text-2" id="text-2">
<div class="highlight"><pre><span></span><span class="n">identifier</span><span class="p">(</span><span class="n">optional</span><span class="p">)</span> <span class="n">attr</span><span class="p">(</span><span class="n">optional</span><span class="p">)</span> <span class="o">:</span> <span class="n">size</span>
</pre></div>

<p>
注意：<br></p>
<ul class="org-ul">
<li>size的大小不能超过identifier所包含最大比特位个数。<br>
</li>
<li>identifier为空时表示对应的size个数的比特位不使用<br>
</li>
<li>size为0时表示根据前类型强制补齐<br>
</li>
</ul>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">S1</span> <span class="p">{</span>
    <span class="c1">// will usually occupy 2 bytes:</span>
    <span class="c1">// 3 bits: value of b1</span>
    <span class="c1">// 2 bits: unused</span>
    <span class="c1">// 6 bits: value of b2</span>
    <span class="c1">// 2 bits: value of b3</span>
    <span class="c1">// 3 bits: unused</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nl">b1</span> <span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nl">b2</span> <span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="nl">b3</span> <span class="p">:</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">S2</span> <span class="p">{</span>
    <span class="c1">// will usually occupy 2 bytes:</span>
    <span class="c1">// 3 bits: value of b1</span>
    <span class="c1">// 5 bits: unused</span>
    <span class="c1">// 6 bits: value of b2</span>
    <span class="c1">// 2 bits: value of b3</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nl">b1</span> <span class="p">:</span> <span class="mi">3</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">:</span><span class="mi">0</span><span class="p">;</span> <span class="c1">// start a new byte</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nl">b2</span> <span class="p">:</span> <span class="mi">6</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nl">b3</span> <span class="p">:</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>

<div id="outline-container-orge72f126" class="outline-3">
<h3 id="orge72f126">
<span class="section-number-3">2.1</span> 在size取0时如何理解</h3>
<div class="outline-text-3" id="text-2-1">
<p>
对于size取0时的各种情况进行了尝试，详细用例如下。思路是使用联合体能比较方便地将内存分布表示出来。<br>
如下所示，定义了如下几种情况。<br></p>
</div>

<div id="outline-container-org4a851a0" class="outline-4">
<h4 id="org4a851a0">
<span class="section-number-4">2.1.1</span> case1</h4>
<div class="outline-text-4" id="text-2-1-1">
<div class="highlight"><pre><span></span><span class="k">union</span> <span class="n">un1</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n1</span><span class="p">;</span>
    <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="nl">nn1</span> <span class="p">:</span> <span class="mi">4</span><span class="p">;</span>
	<span class="kt">int</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="nl">nn2</span> <span class="p">:</span> <span class="mi">16</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">st</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
<p>
对联合体中的结构体位段进行赋值，并将联合体中的内容打印出来。<br></p>
<div class="highlight"><pre><span></span><span class="k">union</span> <span class="n">un1</span> <span class="n">u1</span><span class="p">;</span>
<span class="n">u1</span><span class="p">.</span><span class="n">st</span><span class="p">.</span><span class="n">nn1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">u1</span><span class="p">.</span><span class="n">st</span><span class="p">.</span><span class="n">nn2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"union u1.n1=0x%08x sizeof(un1)=%zu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">u1</span><span class="p">.</span><span class="n">n1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">un1</span><span class="p">));</span>
</pre></div>
<p>
输出结果为<br></p>
<div class="highlight"><pre><span></span><span class="k">union</span> <span class="n">un1</span><span class="p">.</span><span class="n">n1</span><span class="o">=</span><span class="mh">0x00000001</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">un1</span><span class="p">)</span><span class="o">=</span><span class="mi">8</span>
</pre></div>
</div>
</div>

<div id="outline-container-org19fb296" class="outline-4">
<h4 id="org19fb296">
<span class="section-number-4">2.1.2</span> case2</h4>
<div class="outline-text-4" id="text-2-1-2">
<div class="highlight"><pre><span></span><span class="k">union</span> <span class="n">un1</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n1</span><span class="p">;</span>
    <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="nl">nn1</span> <span class="p">:</span> <span class="mi">4</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="nl">nn2</span> <span class="p">:</span> <span class="mi">16</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">st</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
<p>
输出结果为<br></p>
<div class="highlight"><pre><span></span><span class="k">union</span> <span class="n">un1</span><span class="p">.</span><span class="n">n1</span><span class="o">=</span><span class="mh">0x00000101</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">un1</span><span class="p">)</span><span class="o">=</span><span class="mi">4</span>
</pre></div>
</div>
</div>

<div id="outline-container-org71f5518" class="outline-4">
<h4 id="org71f5518">
<span class="section-number-4">2.1.3</span> case3</h4>
<div class="outline-text-4" id="text-2-1-3">
<div class="highlight"><pre><span></span><span class="k">union</span> <span class="n">un1</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n1</span><span class="p">;</span>
    <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="nl">nn1</span> <span class="p">:</span> <span class="mi">4</span><span class="p">;</span>
	<span class="kt">short</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="nl">nn2</span> <span class="p">:</span> <span class="mi">16</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">st</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
<p>
输出结果为<br></p>
<div class="highlight"><pre><span></span><span class="k">union</span> <span class="n">un1</span><span class="p">.</span><span class="n">n1</span><span class="o">=</span><span class="mh">0x00010001</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">un1</span><span class="p">)</span><span class="o">=</span><span class="mi">4</span>
</pre></div>
</div>
</div>


<div id="outline-container-org19d8dd0" class="outline-4">
<h4 id="org19d8dd0">
<span class="section-number-4">2.1.4</span> case4</h4>
<div class="outline-text-4" id="text-2-1-4">
<div class="highlight"><pre><span></span><span class="k">union</span> <span class="n">un1</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n1</span><span class="p">;</span>
    <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="nl">nn1</span> <span class="p">:</span> <span class="mi">8</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="nl">nn2</span> <span class="p">:</span> <span class="mi">16</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">st</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
<p>
输出结果为<br></p>
<div class="highlight"><pre><span></span><span class="k">union</span> <span class="n">un1</span><span class="p">.</span><span class="n">n1</span><span class="o">=</span><span class="mh">0x00000101</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">un1</span><span class="p">)</span><span class="o">=</span><span class="mi">4</span>
</pre></div>
</div>
</div>
</div>

<div id="outline-container-orgc2eeb97" class="outline-3">
<h3 id="orgc2eeb97">
<span class="section-number-3">2.2</span> <code>struct</code> 标识符</h3>
<div class="outline-text-3" id="text-2-2">
<p>
多数例子都是以 <code>struct</code> 作为位域的组织标识，在C++中能否使用 <code>class</code> 作为位域的标识符。<br>
经过测试，是可以使用 <code>class</code> 的，但是需要注意 <code>class</code> 的默认访问控制属性为 <code>private</code><br></p>
</div>
</div>
</div>

<div id="outline-container-orgc6a32e6" class="outline-2">
<h2 id="orgc6a32e6">
<span class="section-number-2">3</span> 位域的常见应用场景</h2>
<div class="outline-text-2" id="text-3">
<p>
<b>为什么要使用位域？位域适合那些情况？</b><br>
位域的主要使用目的是节省对象的内存使用。在存放一些比较小的数据时，使用位域能够使字节中的每个比特位合理地利用起来，避免内存浪费。<br>
比较典型的应用是描述硬件寄存器。如果有32个一组的寄存器，每个寄存器代表一个比特位，就可以使用位域表示这组寄存器。<br></p>
</div>
</div>

<div id="outline-container-org44527f2" class="outline-2">
<h2 id="org44527f2">
<span class="section-number-2">4</span> C++中的位操作接口</h2>
<div class="outline-text-2" id="text-4">
<p>
C++中也提供了一套位操作的接口 <code>std::bitset</code> ，这套接口提供了指定比特位数据的操作接口。<br></p>
</div>
</div>

<div id="outline-container-org414beda" class="outline-2">
<h2 id="org414beda">
<span class="section-number-2">5</span> 参考资料</h2>
<div class="outline-text-2" id="text-5">
<ul class="org-ul">
<li>
<a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E6%AE%B5">wikipedia bit-field</a><br>
</li>
<li>
<a href="https://en.cppreference.com/w/cpp/language/bit_field">cppreference bit-field</a><br>
</li>
<li>
<a href="https://msdn.microsoft.com/zh-cn/library/ewwyfdbe.aspx">microsoft msdn</a><br>
</li>
<li>
<a href="https://stackoverflow.com/questions/24933242/when-to-use-bit-fields-in-c">stackoverflow</a><br>
</li>
<li>
<a href="https://en.cppreference.com/w/cpp/utility/bitset">cppreference std::bitset</a><br>
</li>
</ul>
</div>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/gcc-built-in-functions-for-atomic-memory-access/" class="u-url">GCC的内存原子化操作函数接口</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-07-02T17:54:08+08:00" itemprop="datePublished" title="2018-07-02 17:54">Jul 02 2018  (17:54)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/gcc-built-in-functions-for-atomic-memory-access/#disqus_thread" data-disqus-identifier="cache/archives/2018/gcc-built-in-functions-for-atomic-memory-access.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/gcc/" rel="tag">gcc</a></li>
        <li><a class="tag p-category" href="/tags/linux/" rel="tag">linux</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <div id="outline-container-org8a82b07" class="outline-2">
<h2 id="org8a82b07">
<span class="section-number-2">1</span> 原子化操作</h2>
<div class="outline-text-2" id="text-1">
<p>
在并发编程中，一个操作或一组操作是原子操作、可线性化操作、不可分操作或不可中断操作（atomic, linearizable, indivisible, uniterruptible），表示该操作执行时不可被中断的。操作的原子性能够保证操作在执行时免受中断、信号、并发进程线程的影响。另外，原子操作大多只有两种结果，要么成功并改变系统中对应的状态，要么没有相关效果。<br></p>

<p>
原子化经常由互斥来保证，可以在硬件层面建立一个缓存一致性协议，也可以在软件层面使用信号量或加锁。因此，一个原子操作不是必须实际上马上生效，而操作系统让这个操作看起来是直接发生的，这能够让操作系统保持一致。正是如此，只要不影响性能，用户可以忽略较底层的实现细节。<br></p>
</div>
</div>

<div id="outline-container-org09a2f9a" class="outline-2">
<h2 id="org09a2f9a">
<span class="section-number-2">2</span> 函数接口</h2>
<div class="outline-text-2" id="text-2">
<p>
GCC提供了原子化的操作接口，能够支持长度为1、2、4、8字节的整形变量或指针。<br></p>

<blockquote>
<p>
In most cases, these builtins are considered a full barrier. That is, no memory operand will be moved across the operation, either forward or backward. Further, instructions will be issued as necessary to prevent the processor from speculating loads across the operation and from queuing stores after the operation.<br></p>
</blockquote>
<p>
在大多数情况下，这些内建函数是完全内存栅栏（full barrier）的，以上摘自 GCC Manual。<br></p>

<p>
<b>取值并进行对应操作的接口</b> 如下所示：<br></p>
<div class="highlight"><pre><span></span><span class="n">type</span> <span class="n">__sync_fetch_and_add</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">type</span> <span class="n">__sync_fetch_and_sub</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">type</span> <span class="n">__sync_fetch_and_or</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">type</span> <span class="n">__sync_fetch_and_and</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">type</span> <span class="n">__sync_fetch_and_xor</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">type</span> <span class="n">__sync_fetch_and_nand</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
<p>
这些函数接口的执行逻辑如下：会执行名称相对应的运算，并将内存中之前存放的值取出并返回。<br></p>
<div class="highlight"><pre><span></span><span class="p">{</span> <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span> <span class="o">*</span><span class="n">ptr</span> <span class="n">op</span><span class="o">=</span> <span class="n">value</span><span class="p">;</span> <span class="k">return</span> <span class="n">tmp</span><span class="p">;</span> <span class="p">}</span>
<span class="p">{</span> <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">value</span><span class="p">);</span> <span class="k">return</span> <span class="n">tmp</span><span class="p">;</span> <span class="p">}</span>   <span class="c1">// nand</span>
</pre></div>
<p>
<b>需要注意的是</b> ：从GCC 4.4开始 <code>__sync_fetch_and_nand</code> 是按照 <code>*ptr = ~(*ptr &amp; value)</code> 实现的，而不是 <code>*ptr = ~*ptr &amp; value</code><br></p>

<p>
<b>直接操作并返回结果的接口</b> 如下所示：<br></p>
<div class="highlight"><pre><span></span><span class="n">type</span> <span class="n">__sync_add_and_fetch</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">type</span> <span class="n">__sync_sub_and_fetch</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">type</span> <span class="n">__sync_or_and_fetch</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">type</span> <span class="n">__sync_and_and_fetch</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">type</span> <span class="n">__sync_xor_and_fetch</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">type</span> <span class="n">__sync_nand_and_fetch</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
<p>
这些函数接口的执行逻辑如下：<br></p>
<div class="highlight"><pre><span></span><span class="p">{</span> <span class="o">*</span><span class="n">ptr</span> <span class="n">op</span><span class="o">=</span> <span class="n">value</span><span class="p">;</span> <span class="k">return</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span> <span class="p">}</span>
<span class="p">{</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="o">*</span><span class="n">ptr</span> <span class="o">&amp;</span> <span class="n">value</span><span class="p">);</span> <span class="k">return</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span> <span class="p">}</span>   <span class="c1">// nand</span>
</pre></div>
<p>
<b>需要注意的是</b> ：从GCC 4.4开始 <code>__sync_nand_and_fetch</code> 是按照 <code>*ptr = ~(*ptr &amp; value)</code> 实现的，而不是 <code>*ptr = ~*ptr &amp; value</code><br></p>

<p>
比较并交换的函数接口<br></p>
<div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="n">__sync_bool_compare_and_swap</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">oldval</span> <span class="n">type</span> <span class="n">newval</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">type</span> <span class="n">__sync_val_compare_and_swap</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">oldval</span> <span class="n">type</span> <span class="n">newval</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
</div>

<div id="outline-container-orga52a717" class="outline-2">
<h2 id="orga52a717">
<span class="section-number-2">3</span> 内存栅栏（Memory Barrier）</h2>
<div class="outline-text-2" id="text-3">
<p>
在上面的说明中提到了memory barrier的概念，这个概念是CPU指令的一个术语。<br></p>

<p>
内存栅栏又叫内存屏障，是一种能够让CPU或编译器约束内存操作指令执行顺序的屏蔽指令。这表示在内存栅栏前的指令能够保证执行时先于内存栅栏后的指令。由于大多数现代CPU采用性能优化会导致指令执行变序时，所以内存栅栏是十分必要的。这样的指令变序对于单线程程序一般不会有很大影响，但是在并发编程情况下如果不加以控制就会导致不可预知的结果。<br></p>

<p>
内存栅栏的典型应用场景就是用于实现多设备之间的共享内存的底层机器码。这些代码包括原始同步机制、多核系统上的无锁数据结构、与计算机硬件交互的设备驱动。<br></p>

<p>
内存栅栏对于无锁编程来说十分重要的。<br></p>

<p>
<b>内存栅栏与volatile关键字</b><br>
内存栅栏分为读栅栏（read barrier）、写栅栏（write barrier）、获取栅栏（acquire barrier）、释放栅栏（release barrier）等。内存栅栏并不能保证数值的是“最新的”或“新鲜的”，它只能控制内存访问的相对顺序。<br></p>

<p>
“写栅栏”用于控制写操作的顺序。由于相对于CPU的执行速度来说，向内存中写入顺序是比较慢的，通常会有一个写入请求队列，所以实际的写入操作发生在指令发起之后，队列中指令的顺序可能会被重新排序。写栅栏能够防止指令变序。<br></p>

<p>
“读栅栏”用于控制读操作的顺序。由于预先执行（CPU会提前将内存中的数据读回来），并且CPU有缓存区（CPU会从缓存中而不是内存中读取数据），读操作可能会出现变序。<br></p>

<p>
volatile关键字值能通知编译器生成的输出码从内存中重新读取数据，但是不会告诉CPU在如何读取数据、在哪里读取数据。<br></p>

<p>
“获取栅栏”能够保证特定指令块之前的执行顺序。例如获取读，在向读队列中加入读操作，“获取栅栏”意味着在这条操作之后可以出现指令变序，而这条操作之前不会出现指令变序。<br></p>

<p>
“释放栅栏”能够保证特定指令块之后的执行顺序。例如释放写，在向写队列中加入写操作，“释放栅栏”意味着在这条写操作之前的指令不会变序到该指令之后，而这条该操作的之后的指令可能会变序到该指令之前。<br></p>

<p>
获取栅栏和释放栅栏是又叫半栅栏（half barrier），这是因为它们只能防止单方向的指令变序。<br></p>
</div>
</div>


<div id="outline-container-orgd6606ad" class="outline-2">
<h2 id="orgd6606ad">
<span class="section-number-2">4</span> 操作原子化能够解决多进程访问共享内存的问题吗？</h2>
<div class="outline-text-2" id="text-4">
<p>
原子化操作是对于CPU而言的指令操作，它不关心线程还是进程，它只关心这一系列的指令是不可分割的。所以，进程间可以使用原子操作完成内存的操作同步。<br></p>
</div>
</div>


<div id="outline-container-org4772935" class="outline-2">
<h2 id="org4772935">
<span class="section-number-2">5</span> 参考资料</h2>
<div class="outline-text-2" id="text-5">
<ul class="org-ul">
<li>
<a href="https://en.wikipedia.org/wiki/Linearizability">Wikipedia - Linearizability</a><br>
</li>
<li>
<a href="https://gcc.gnu.org/onlinedocs/gcc-4.4.3/gcc/Atomic-Builtins.html">GNU GCC online docs</a><br>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Memory_barrier">Wikipedia - Memory Barrier</a><br>
</li>
<li>
<a href="https://stackoverflow.com/questions/1787450/how-do-i-understand-read-memory-barriers-and-volatile">stackoverflow - memory barrier and volatile</a><br>
</li>
<li>
<a href="https://stackoverflow.com/questions/8160348/lock-freedom-atomic-operations-across-2-processes-instead-of-threads">stackoverflow - atomic operation in multi process</a><br>
</li>
<li>
<a href="https://en.cppreference.com/w/cpp/atomic">cppreference - atomic</a><br>
</li>
</ul>
</div>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/gdb-display-contents-of-memory-address/" class="u-url">在gdb中查看指定内存地址的内容</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-06-29T16:45:09+08:00" itemprop="datePublished" title="2018-06-29 16:45">Jun 29 2018  (16:45)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/gdb-display-contents-of-memory-address/#disqus_thread" data-disqus-identifier="cache/archives/2018/gdb-display-contents-of-memory-address.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/debugging/" rel="tag">debugging</a></li>
        <li><a class="tag p-category" href="/tags/gdb/" rel="tag">gdb</a></li>
        <li><a class="tag p-category" href="/tags/linux/" rel="tag">linux</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <div>
<p>
调试 C/C++ 程序时，需要打印指定内存地址的内容。我最近调试程序中的序列化模块时，需要将类对象按照指定的格式转化为二进制流，为了验证转化结果，在调试时就需要将指定内存地址中的内容打印出来。<br></p>

<p class="more"><a href="/posts/gdb-display-contents-of-memory-address/">Read more…</a></p>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/asynchronous-synchronous-and-blocking-unblocking/" class="u-url">同步和异步、阻塞和非阻塞</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-06-26T09:27:06+08:00" itemprop="datePublished" title="2018-06-26 09:27">Jun 26 2018  (09:27)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/asynchronous-synchronous-and-blocking-unblocking/#disqus_thread" data-disqus-identifier="cache/archives/2018/asynchronous-synchronous-and-blocking-unblocking.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/computer-science/" rel="tag">computer science</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <div id="outline-container-org4cfd186" class="outline-2">
<h2 id="org4cfd186">
<span class="section-number-2">1</span> 同步和异步</h2>
<div class="outline-text-2" id="text-1">
<p>
同步和异步指的是在进行I/O操作完成之前，是否允许其他处理步骤继续执行。<br>
计算机中的I/O操作相对于数据处理操作时十分耗时的。<br></p>

<p>
一个简单的I/O操作方式就是启动连接并等待操作完成，但是这样的操作（同步阻塞I/O）在通信过程中会阻塞进程的处理进度。<br>
相应的，可以在启动通信的同时进行其他的处理，并不需要等待I/O操作的完成，这样的操作就被称作是异步I/O。那些依赖于I/O操作执行完成的任务会阻塞等待I/O操作的完成，其他不依赖与I/O操作的任务能够继续执行。<br></p>

<p>
同步模型常用的函数接口： <code>read</code> , <code>write</code> , <code>send</code> , <code>recv</code><br>
异步模型常用的函数接口： <code>aio_write</code> , <code>aio_read</code><br></p>
</div>

<div id="outline-container-orgc972d25" class="outline-3">
<h3 id="orgc972d25">
<span class="section-number-3">1.1</span> POSIX AIO</h3>
<div class="outline-text-3" id="text-1-1">
<p>
在头文件 <code>aio.h</code> 中定义，链接时使用 <code>-lrt</code><br></p>

<p>
<b>函数接口</b><br>
异步写操作<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">aio_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">aiocb</span><span class="o">*</span> <span class="n">aiocbp</span><span class="p">);</span>
</pre></div>

<p>
异步读操作<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">aio_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">aiocb</span><span class="o">*</span> <span class="n">aiocbp</span><span class="p">);</span>
</pre></div>

<p>
获取异步操作结果<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">aio_return</span><span class="p">(</span><span class="k">struct</span> <span class="n">aiocb</span><span class="o">*</span> <span class="n">aiocbp</span><span class="p">);</span>
</pre></div>

<p>
获取异步操作中的错误<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">aio_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">aiocb</span><span class="o">*</span> <span class="n">aiocbp</span><span class="p">);</span>
</pre></div>

<p>
示例代码： <a href="https://gist.github.com/rsms/771059">github gist</a><br></p>
</div>
</div>

<div id="outline-container-org31b05bc" class="outline-3">
<h3 id="org31b05bc">
<span class="section-number-3">1.2</span> Linux AIO</h3>
<div class="outline-text-3" id="text-1-2">
<p>
在头文件 <code>libaio.h</code> 中定义，链接时使用 <code>-laio</code><br></p>

<p>
<b>函数接口</b><br>
需要注意的是aio的函数接口需要借助 <code>syscall</code> 进行调用。<br>
创建aio context对象<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">io_setup</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">nr</span><span class="p">,</span> <span class="n">aio_context_t</span><span class="o">*</span> <span class="n">ctxp</span><span class="p">);</span>
</pre></div>
<p>
销毁aio context对象<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">io_destroy</span><span class="p">(</span><span class="n">aio_context_t</span> <span class="n">ctx</span><span class="p">);</span>
</pre></div>
<p>
提交异步操作<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">io_submit</span><span class="p">(</span><span class="n">aio_context_t</span> <span class="n">ctx</span><span class="p">,</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iocb</span><span class="o">**</span> <span class="n">iocbpp</span><span class="p">);</span>
</pre></div>
<p>
获取异步操作结果<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">io_getevents</span><span class="p">(</span><span class="n">aio_context_t</span> <span class="n">ctx</span><span class="p">,</span> <span class="kt">long</span> <span class="n">min_nr</span><span class="p">,</span> <span class="kt">long</span> <span class="n">max_nr</span><span class="p">,</span>
		 <span class="n">io_event</span><span class="o">*</span> <span class="n">events</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span><span class="o">*</span> <span class="n">timeout</span><span class="p">);</span>
</pre></div>

<p>
示例代码:<br></p>
<ul class="org-ul">
<li>
<a href="https://gist.github.com/larytet/87f90b08643ac3de934df2cadff4989c">github gist</a><br>
</li>
<li>
<a href="http://www.xmailserver.org/eventfd-aio-test.c">xmailserver.org</a><br>
</li>
</ul>
</div>
</div>

<div id="outline-container-org0cf992f" class="outline-3">
<h3 id="org0cf992f">
<span class="section-number-3">1.3</span> POSIX AIO与Linux AIO的区别</h3>
<div class="outline-text-3" id="text-1-3">
<p>
摘自 <a href="https://stackoverflow.com/questions/8768083/difference-between-posix-aio-and-libaio-on-linux">stackoverflow.com</a><br></p>
<blockquote>
<p>
On linux, the two AIO implementations are fundamentally different.<br>
The POSIX AIO is a user-level implementation that performs normal blocking I/O in multiple threads, hence giving the illusion that the I/Os are asynchronous. The main reason to do this is that:<br></p>
<ul class="org-ul">
<li>it works with any filesystem<br>
</li>
<li>it works (essentially) on any operating system (keep in mind that gnu's libc is portable)<br>
</li>
<li>it works on files with buffering enabled (i.e. no O<sub>DIRECT</sub> flag set)<br>
</li>
</ul>
<p>
The main drawback is that your queue depth (i.e. the number of outstanding operations you can have in practice) is limited by the number of threads you choose to have, which also means that a slow operation on one disk may block an operation going to a different disk. It also affects which I/Os (or how many) is seen by the kernel and the disk scheduler as well.<br>
The kernel AIO (i.e. io<sub>submit</sub>() et.al.) is kernel support for asynchronous I/O operations, where the io requests are actually queued up in the kernel, sorted by whatever disk scheduler you have, presumably some of them are forwarded (in somewhat optimal order one would hope) to the actual disk as asynchronous operations (using TCQ or NCQ). The main restriction with this approach is that not all filesystems work that well or at all with async I/O (and may fall back to blocking semantics), files have to be opened with O<sub>DIRECT</sub> which comes with a whole lot of other restrictions on the I/O requests. If you fail to open your files with O<sub>DIRECT</sub>, it may still "work", as in you get the right data back, but it probably isn't done asynchronously, but is falling back to blocking semantics.<br>
Also keep in mind that io<sub>submit</sub>() can actually block on the disk under certain circumstances.<br></p>
</blockquote>
<p>
在Linux上两种AIO是完全不同的；<br>
POSIX AIO实现在用户层，实际上进行的操作是普通的多线程阻塞操作，表现为I/O操作是异步的，这种AIO的优点是兼容性和可移植性好，缺点是操作队列长度受限于最大线程数量。<br>
Linux AIO是内核提供的AIO函数接口，I/O操作请求的队列在内核中维护，这种AIO的缺点是并不支持所有的文件系统，Linux AIO在某些情况下的磁盘操作是会阻塞的。<br></p>
</div>
</div>
</div>

<div id="outline-container-org126401e" class="outline-2">
<h2 id="org126401e">
<span class="section-number-2">2</span> 阻塞和非阻塞</h2>
<div class="outline-text-2" id="text-2">
<p>
阻塞与非阻塞的概念针对的是函数是否会立即返回。<br>
非阻塞模型常与IO复用技术组合使用。<br>
可以通过函数将IO设备设置为非阻塞模式。<br></p>
</div>
</div>


<div id="outline-container-org4abb423" class="outline-2">
<h2 id="org4abb423">
<span class="section-number-2">3</span> 如何理解阻塞非阻塞与同步异步的区别</h2>
<div class="outline-text-2" id="text-3">
<p>
在处理 IO 的时候，阻塞和非阻塞都是同步 IO。<br>
只有使用了特殊的 API 才是异步 IO。<br></p>
</div>
</div>


<div id="outline-container-orgf3c5c94" class="outline-2">
<h2 id="orgf3c5c94">
<span class="section-number-2">4</span> 参考资料</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li>
<a href="https://blog.csdn.net/hguisu/article/details/38638183">csdn.net</a><br>
</li>
<li>
<a href="https://github.com/littledan/linux-aio%20repo">github.com linux-aio</a><br>
</li>
<li>
<a href="https://www.ibm.com/developerworks/linux/library/l-async/index.html">ibm developerworks</a><br>
</li>
</ul>
</div>
</div>
    </div>

  </article>
</div>



        
       <script>var disqus_shortname="samsonwang-me";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script>
</div>

      <div class="col-lg-3 col-md-3 col-sm-12 col-xs-12 sidebar">
       
<div class="sidebar-module sidebar-module-inset">
  <h4>About Me</h4>
  
        <div class="sidebar-aboutme">
        <p>Zeal for coding, C++ developer. Focused on Linux server develop. I use EMACS on a daily basis.</p>
        </div>
</div>

       
<div class="sidebar-module sidebar-module-inset">
  <h4>Categories</h4>
  
        <ol class="list-unstyled sidebar-category">
<li>
<a href="/tags/category-cpp/">cpp</a>
        </li>
<li>
<a href="/tags/category-emacs/">emacs</a>
        </li>
<li>
<a href="/tags/category-linux/">linux</a>
        </li>
<li>
<a href="/tags/category-windows/">windows</a>
        </li>
</ol>
</div>

      </div>
<!--.sidebar-->
    </div>
<!--.row-->

    

        <nav class="postindexpager"><ul class="pager">
<li class="right">
                <a href="/index-3.html" rel="prev">Newer posts</a>
            </li>
            <li class="left">
                <a href="/index-5.html" rel="next">Older posts</a>
            </li>
        </ul></nav><!--End of body content--><footer id="footer"><div class="text-center">
<p>Contents © 2017-2019 <a href="mailto:wangzhilv@gmail.com">Samson Wang</a>
 - Powered by <a href="https://getnikola.com/" rel="nofollow">Nikola</a>
 - Hosted on <a href="https://pages.github.com/" rel="nofollow">Github Pages</a>
 - 
<a rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/"><img alt="知识共享许可协议" style="padding-bottom:2px" src="https://i.creativecommons.org/l/by-nc/4.0/80x15.png"></a>
</p>
</div>

      
    </footer>
</div>
</div>

<div id="scroll-top" title="back to top">
  <div id="scroll-top-arrow"></div>
  <div id="scroll-top-stick"></div>
</div>


            <script src="/assets/js/jquery.min.js"></script><script src="/assets/js/jquery.colorbox-min.js"></script><script src="/assets/js/jquery.lazyload.min.js"></script><script src="/assets/js/popper.min.js"></script><script src="/assets/js/bootstrap.min.js"></script><script src="/assets/js/moment-with-locales.min.js"></script><script src="/assets/js/fancydates.js"></script><script src="/assets/js/cerulean.js"></script><!-- fancy dates --><script>
  moment.locale("en");
  fancydates(0, "YYYY-MM-DD HH:mm");
</script><!-- end fancy dates --><!-- Baidu Analytics --><script>
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?7ec47c52179b8ca4f9aee81282bd7b20";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>
</body>
</html>
