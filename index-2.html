<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#" lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="Personal handnote on software development">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Hack Note (old posts, page 2) | Hack Note</title>
<link href="/assets/css/bootstrap.min.css" rel="stylesheet" type="text/css">
<link href="/assets/css/font-awesome.min.css" rel="stylesheet" type="text/css">
<link href="/assets/css/code.css" rel="stylesheet" type="text/css">
<link href="/assets/css/colorbox.css" rel="stylesheet" type="text/css">
<link href="/assets/css/highlight.css" rel="stylesheet" type="text/css">
<link href="/assets/css/cerulean.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="en" href="/rss.xml">
<link rel="canonical" href="https://samsonwang.me/index-2.html">
<link rel="icon" href="/favicon.ico" sizes="64x64">
<link rel="prev" href="/index-1.html" type="text/html">
<link rel="next" href="/index-3.html" type="text/html">
<!--[if lt IE 9]><script src="/assets/js/html5.js"></script><![endif]-->
</head>
<body class="preload">
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->
<nav id="top-nav" class="navbar navbar-expand-md fixed-top mb-4 navbar-dark bg-dark"><div class="container">   <!-- This keeps the margins nice -->
    <a class="navbar-brand" href="https://samsonwang.me/">

      <span id="blog-title">Hack Note</span>
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div class="collapse navbar-collapse" id="bs-navbar">
      <ul class="navbar-nav mr-auto">
<li class="nav-item">
<a href="/archive/" class="nav-link">Archives</a>
                </li>
<li class="nav-item">
<a href="/tags/" class="nav-link">Tags</a>
                </li>
<li class="nav-item">
<a href="/listings/" class="nav-link">Listings</a>
                </li>
<li class="nav-item">
<a href="/galleries/" class="nav-link">Galleries</a>
                </li>
<li class="nav-item">
<a href="/rss.xml" class="nav-link">RSS Feed</a>

        
      </li>
</ul>
<ul class="navbar-nav navbar-right"></ul>
</div>
<!-- /.navbar-collapse -->
  </div>
<!-- /.container -->
</nav><!-- End of Menubar --><div class="container" id="content" role="main">
  <div class="body-content">
    <!--Body content-->
    <div class="row">

      <div class="col-lg-9 col-md-9 col-sm-12 col-xs-12">
        
        


  



  


<div class="postindex">
  <article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/using-keyboard-marcos-in-emacs/" class="u-url">emacs的键盘宏（keyboard macro）</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-08-11T10:26:32+08:00" itemprop="datePublished" title="2018-08-11 10:26">Aug 11 2018  (10:26)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/using-keyboard-marcos-in-emacs/#disqus_thread" data-disqus-identifier="cache/posts/using-keyboard-marcos-in-emacs.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/emacs/" rel="tag">emacs</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <p>
对于一些有规律且重复性的编辑任务, 手动完成十分无聊, 并且需要耗费较长的时间。我在youtube上看到一个使用keyboard marco的 <a href="https://youtu.be/wFCO__0prCM">视频</a> 后, 受到很大的启发, 在以后的使用中也会尝试使用宏。我总结了一下视频中的技巧要点，并查阅资料对相关知识点进行了补充和完善。<br></p>

<p>
有梯子的同学可以去看看，视频地址：<a href="https://youtu.be/wFCO__0prCM">https://youtu.be/wFCO__0prCM</a><br></p>

<p>
<b>操作指令</b><br>
开始记录宏: 命令名称 <code>kmacro-start-macro</code> , 快捷键 <code>C-x-(</code> 或 <code>&lt;f3&gt;</code><br>
结束记录宏: 命令名称 <code>kmacro-end-macro</code> , 快捷键 <code>C-x-)</code> 或 <code>&lt;f4&gt;</code><br>
执行宏: 命令名称 <code>kmacro-end-and-call-macro</code> , 快捷键 <code>C-x-e</code> , 可以使用 <code>C-u</code> 指定这个宏的执行次数<br>
清除多余的空格: 命令名称 <code>fixup-whitespace</code> , 这个命令我是第一次见到, 以后可以尝试多用用。<br></p>

<p>
<b>参考资料</b><br></p>
<ul class="org-ul">
<li>
<a href="https://www.emacswiki.org/emacs/KeyboardMacros">emacs wiki</a><br>
</li>
</ul>
</div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/algorithm-weekly-longest-palindromic-substring/" class="u-url">每周算法：最长对称子串</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-08-07T10:37:34+08:00" itemprop="datePublished" title="2018-08-07 10:37">Aug 07 2018  (10:37)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/algorithm-weekly-longest-palindromic-substring/#disqus_thread" data-disqus-identifier="cache/posts/algorithm-weekly-longest-palindromic-substring.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/algorithm/" rel="tag">algorithm</a></li>
        <li><a class="tag p-category" href="/tags/leetcode/" rel="tag">leetcode</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <div id="outline-container-org30ff2a5" class="outline-2">
<h2 id="org30ff2a5">Description</h2>
<div class="outline-text-2" id="text-org30ff2a5">
<p>
Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.<br></p>

<p>
<b>Example 1:</b><br>
Input: "babad"<br>
Output: "bab"<br>
Note: "aba" is also a valid answer.<br></p>

<p>
<b>Example 2:</b><br>
Input: "cbbd"<br>
Output: "bb"<br></p>

<p>
来源：<a href="https://leetcode.com/problems/longest-palindromic-substring/description/">LeetCode 05 Longest Palindromic Substring</a><br></p>
</div>
</div>

<div id="outline-container-orgbc3340b" class="outline-2">
<h2 id="orgbc3340b">Solution</h2>
<div class="outline-text-2" id="text-orgbc3340b">
<p>
我想到了两种方法：暴力解法、从中心展开<br></p>
</div>

<div id="outline-container-orga81f9f1" class="outline-3">
<h3 id="orga81f9f1">Approach 1 暴力解法</h3>
<div class="outline-text-3" id="text-orga81f9f1">
<p>
暴击解法的时间复杂度为 <code>O(n3)</code> , 找出所有子串的时间复杂度为 <code>O(n2)</code> , 判断一个子串的时间复杂度为 <code>O(n)</code> ; 空间复杂度为 <code>O(1)</code> 。<br></p>

<p>
需要注意的是，如果子串过短，就没有必要进行对称性判断了。<br></p>

<p>
下面是我的代码<br></p>
<div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">isPalindrome</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>

    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">head</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">head</span> <span class="o">&lt;</span> <span class="n">tail</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">head</span><span class="p">]</span> <span class="o">!=</span> <span class="n">str</span><span class="p">[</span><span class="n">tail</span><span class="p">])</span> <span class="p">{</span>
	    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">++</span><span class="n">head</span><span class="p">;</span>
	<span class="o">--</span><span class="n">tail</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">string</span> <span class="nf">longestPalindrome</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>

    <span class="n">string</span> <span class="n">ans</span> <span class="o">=</span> <span class="s">""</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span><span class="o">=</span><span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">()</span><span class="o">-</span><span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">ans</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">continue</span><span class="p">;</span>
	    <span class="p">}</span>

	    <span class="n">string</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">ans</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">temp</span><span class="p">.</span><span class="n">length</span><span class="p">()</span>
		<span class="o">&amp;&amp;</span> <span class="n">isPalindrome</span><span class="p">(</span><span class="n">temp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ans</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
	    <span class="p">}</span>
	<span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>

<div id="outline-container-org6d697f4" class="outline-3">
<h3 id="org6d697f4">Approach 2 从中心展开</h3>
<div class="outline-text-3" id="text-org6d697f4">
<p>
从中心展开方法的时间复杂度为 <code>O(n2)</code> , 空间复杂度为 <code>O(1)</code> 。<br></p>

<p>
需要注意的是坐标的计算，这个在字符串处理题目中是十分关键的，也是很容易出错的。<br>
由于单个字符和两个相同字符都可以作为中心，这点需要额外注意一下。<br></p>

<p>
下面就是我的解法，使用的C++做的。<br></p>
<div class="highlight"><pre><span></span><span class="n">string</span> <span class="nf">longestPalindrome</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>

    <span class="n">string</span> <span class="n">ans</span> <span class="o">=</span> <span class="s">""</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>

	<span class="c1">// 如何确定初始的边界很重要</span>
	<span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="c1">// 向两边拓展边界</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
	    <span class="o">--</span><span class="n">j</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="o">&lt;</span><span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
	    <span class="o">++</span><span class="n">k</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;=</span><span class="mi">0</span>
	       <span class="o">&amp;&amp;</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="o">&lt;</span><span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">()</span>
	       <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">s</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
	    <span class="o">--</span><span class="n">j</span><span class="p">;</span>
	    <span class="o">++</span><span class="n">k</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="n">ans</span><span class="p">.</span><span class="n">length</span><span class="p">())</span> <span class="p">{</span>
	    <span class="n">ans</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>
leetcode上还有一个解法，使用java完成的，它的坐标计算也很有技巧性。<br></p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="n">String</span> <span class="nf">longestPalindrome</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="s">""</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
	<span class="kt">int</span> <span class="n">len1</span> <span class="o">=</span> <span class="n">expandAroundCenter</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
	<span class="kt">int</span> <span class="n">len2</span> <span class="o">=</span> <span class="n">expandAroundCenter</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">len1</span><span class="o">,</span> <span class="n">len2</span><span class="o">);</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="o">)</span> <span class="o">{</span>
	    <span class="n">start</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="o">(</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
	    <span class="n">end</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">len</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
	<span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">int</span> <span class="nf">expandAroundCenter</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">L</span> <span class="o">=</span> <span class="n">left</span><span class="o">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">L</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">R</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">L</span><span class="o">)</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">R</span><span class="o">))</span> <span class="o">{</span>
	<span class="n">L</span><span class="o">--;</span>
	<span class="n">R</span><span class="o">++;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">R</span> <span class="o">-</span> <span class="n">L</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>
</div>
</div>

<div id="outline-container-org0c71b67" class="outline-3">
<h3 id="org0c71b67">Approach 3 动态规划（dynamic programming）</h3>
<div class="outline-text-3" id="text-org0c71b67">
<p>
leetcode上还给给出了使用DP解决这个问题的方法。<br>
我在leetcode上的discuss上找了个java写的解法。<br></p>

<p>
动态规划的时间复杂度为 <code>O(n2)</code> , 空间复杂度为 <code>O(n2)</code> 。<br>
我对dp算法的了解还不多，个人感觉值得思考的是 <code>i</code> 和 <code>j</code> 的变化起点和变化方向。<br></p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="n">String</span> <span class="nf">longestPalindrome</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
  <span class="n">String</span> <span class="n">res</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

  <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
      <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">||</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]);</span>

      <span class="k">if</span> <span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">res</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">res</span><span class="o">.</span><span class="na">length</span><span class="o">()))</span> <span class="o">{</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>
</div>
</div>

<div id="outline-container-orgf80c538" class="outline-3">
<h3 id="orgf80c538">Approach 4 Manacher算法</h3>
<div class="outline-text-3" id="text-orgf80c538">
<p>
这个算法思路实在是新奇，感兴趣的同学可以 <a href="https://articles.leetcode.com/longest-palindromic-substring-part-ii/">去看看</a> 。<br></p>
</div>
</div>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/algorithm-weekly-longest-substring-without-repeating-characters/" class="u-url">每周算法：最长不含重复字符的子串</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-08-02T11:43:14+08:00" itemprop="datePublished" title="2018-08-02 11:43">Aug 02 2018  (11:43)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/algorithm-weekly-longest-substring-without-repeating-characters/#disqus_thread" data-disqus-identifier="cache/posts/algorithm-weekly-longest-substring-without-repeating-characters.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/algorithm/" rel="tag">algorithm</a></li>
        <li><a class="tag p-category" href="/tags/leetcode/" rel="tag">leetcode</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <div id="outline-container-org930928c" class="outline-2">
<h2 id="org930928c">Description</h2>
<div class="outline-text-2" id="text-org930928c">
<p>
Given a string, find the length of the longest substring without repeating characters.<br></p>

<p>
<b>Examples:</b><br>
Given "abcabcbb", the answer is "abc", which the length is 3.<br>
Given "bbbbb", the answer is "b", with the length of 1.<br>
Given "pwwkew", the answer is "wke", with the length of 3. Note that the answer must be a substring, "pwke" is a subsequence and not a substring.<br></p>

<p>
来源：<a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/description/">LeetCode 03 Longest Substring Without Repeating Characters</a><br></p>
</div>
</div>

<div id="outline-container-org03b4283" class="outline-2">
<h2 id="org03b4283">Solution</h2>
<div class="outline-text-2" id="text-org03b4283">
<p>
好久没刷算法题了，手有点生，没有什么思路，下面的答案是看过提示之后才写出来的。<br></p>
</div>

<div id="outline-container-org4b38633" class="outline-3">
<h3 id="org4b38633">Approach 1 暴力解法</h3>
<div class="outline-text-3" id="text-org4b38633">
<p>
将所有的子串都穷举出来，并对它们进行判断，就能够得到最长子串的长度。这个算法很显然需要耗费很长时间。<br>
需要注意的是： C++20中才支持 <code>std::set::contains</code> 这个接口（根据cppreference.com）。<br></p>

<div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">isStringWithUniqueString</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 用于判断字符串是否是具有唯一字符的</span>
    <span class="n">set</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">setChar</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">str</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">setChar</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">!=</span> <span class="n">setChar</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
	<span class="p">{</span>
	    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">setChar</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">lengthOfLongestSubstring</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">lengthMax</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
	<span class="p">{</span>
	    <span class="c1">// get sub-string</span>
	    <span class="n">string</span> <span class="n">strTemp</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">i</span><span class="p">);</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">isStringWithUniqueString</span><span class="p">(</span><span class="n">strTemp</span><span class="p">))</span>
	    <span class="p">{</span>
		<span class="n">lengthMax</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">lengthMax</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">strTemp</span><span class="p">.</span><span class="n">length</span><span class="p">());</span>
	    <span class="p">}</span>
	<span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">lengthMax</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>


<div id="outline-container-org3988fff" class="outline-3">
<h3 id="org3988fff">Approach 2 滑动窗口</h3>
<div class="outline-text-3" id="text-org3988fff">
<p>
滑动窗口的概念在字符串处理问题中十分常用，保持子串的左端点不动，不断拓展右侧端点，就能穷举出所有满足条件的子串。<br>
需要注意的是这句话： <code>lengthMax = max(lengthMax, int(j-i+1));</code><br></p>
<ol class="org-ol">
<li>
<code>std::max</code> 并不能同时匹配 <code>int</code> 和 <code>size_t</code> ，所以需要进行强制类型转换。<br>
</li>
<li>在完成第 <code>j</code> 个字母的验证后，说明包含该字母的子串也满足条件，所以要进行 <code>+1</code> 操作，这个主要是针对只有一个字母的字符串。<br>
</li>
</ol>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">lengthOfLongestSubstring</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">lengthMax</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
	<span class="c1">// 这个循环目的是，验证从i到j的字符串是否满足条件</span>
	<span class="n">set</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">setChar</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
	<span class="p">{</span>
	    <span class="kt">char</span> <span class="n">ch</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">setChar</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="o">!=</span> <span class="n">setChar</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
	    <span class="p">{</span>
		<span class="k">break</span><span class="p">;</span>
	    <span class="p">}</span>
	    <span class="k">else</span>
	    <span class="p">{</span>
		<span class="n">lengthMax</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">lengthMax</span><span class="p">,</span> <span class="kt">int</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
	    <span class="p">}</span>

	    <span class="n">setChar</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
	<span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">lengthMax</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>


<div id="outline-container-org594bbca" class="outline-3">
<h3 id="org594bbca">Approach 3 优化的滑动窗口</h3>
<div class="outline-text-3" id="text-org594bbca">
<p>
使用 <code>map</code> 对字母出现的位置进行记录，这样在出现相同字母时，就能够从上一次出现的位置向后开始寻找。<br>
需要注意句话 <code>it-&gt;second+1&gt;=i</code> , 需要对位置加1后再比较，这样才能保证 <code>i</code> 的坐标计算正确。<br></p>

<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">lengthOfLongestSubstring</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">lengthMax</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">mapPos</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
    <span class="p">{</span>
	<span class="kt">char</span> <span class="n">ch</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
	<span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">size_t</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">mapPos</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">mapPos</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
	<span class="p">{</span>
	    <span class="c1">// 这里说明找到了字符上一次出现的位置</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">+</span> <span class="mi">1</span><span class="o">&gt;=</span> <span class="n">i</span><span class="p">)</span>
	    <span class="p">{</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	    <span class="p">}</span>
	<span class="p">}</span>

	<span class="n">lengthMax</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">lengthMax</span><span class="p">,</span> <span class="kt">int</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>

	<span class="n">mapPos</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">lengthMax</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/navigation-and-selection-effectively-in-emacs/" class="u-url">提高emacs中浏览和选择操作效率的技巧</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-07-30T11:14:41+08:00" itemprop="datePublished" title="2018-07-30 11:14">Jul 30 2018  (11:14)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/navigation-and-selection-effectively-in-emacs/#disqus_thread" data-disqus-identifier="cache/posts/navigation-and-selection-effectively-in-emacs.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/emacs/" rel="tag">emacs</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <div id="outline-container-org5c6e310" class="outline-2">
<h2 id="org5c6e310">
<span class="section-number-2">1</span> 引言</h2>
<div class="outline-text-2" id="text-1">
<p>
Gaurab Paul的 <a href="https://lorefnon.tech/2018/07/14/getting-productive-with-selection-and-navigation-in-emacs/">一篇博文</a> 给了我很大的启发，他详细地介绍了emacs中的相关概念，并提供了许多充满想象力的小技巧。作为emacs的入门级选手确实学到了很多，也拓宽了自己的思路。<br></p>

<p>
我最初的开发环境是Visual Studio，这一类比较大型的IDE集成了许多功能，但同时也会束缚住使用者的想法。通过这篇文章我感受到的由普通操作指令能组合成的新编辑方式。<br></p>

<p>
如果英文水平允许的话，非常推荐阅读一下原版的博文，原文中有更加丰富形象的图片示例，无论是跟我一样刚刚入门emacs的新手，还是经验丰富的老兵，都能够从中获得启发。下面，我结合自己的理解和收获谈谈emacs中操作的体会。<br></p>
</div>
</div>


<div id="outline-container-org8d68760" class="outline-2">
<h2 id="org8d68760">
<span class="section-number-2">2</span> <code>point</code> 、 <code>mark</code> 和 <code>region</code> 的概念</h2>
<div class="outline-text-2" id="text-2">
<p>
我之前进行代码段复制的操作是十分基础的，用 <code>C-@</code> 模拟鼠标按下，方向键模拟鼠标拖动，在鼠标拖动的过程中就形成了一个选区，然后用 <code>M-w</code> 对这个选区进行复制操作，用 <code>C-y</code> 粘贴被复制的内容。<br></p>

<p>
以上操作带出了几个非常重要的概念 。在emacs中，鼠标光标所在位置被称作 <code>point</code> ；组合键 <code>C-@</code> 执行的是 <code>set-mark-command</code> 命令，就是将 <code>point</code> 所在位置标记为 <code>mark</code> ；通过移动光标，也就是移动 <code>point</code> 后，在 <code>point</code> 与 <code>mark</code> 之间就形成了 <code>region</code> 。<br></p>
</div>
</div>


<div id="outline-container-orga5779c0" class="outline-2">
<h2 id="orga5779c0">
<span class="section-number-2">3</span> <code>region</code> 操作技巧</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-orga50017a" class="outline-3">
<h3 id="orga50017a">
<span class="section-number-3">3.1</span> 调整 <code>region</code> 的大小</h3>
<div class="outline-text-3" id="text-3-1">
<p>
下面就来介绍一个非常重要的命令 <code>exchange-point-and-mark</code> ，这个命令默认被绑定在组合键 <code>C-x C-x</code> 上，从字面意思上很容易理解这条指令的作用，就是交换 <code>mark</code> 和 <code>point</code> 的位置。这样做的意义在于能够方便地切换 <code>region</code> 的可动边界，这样能够使 <code>region</code> 方便地分别从两端调整大小。<br>
下面的示例是截取自Paul的博文，需要注意的是，他习惯于使用 <code>C-SPC</code> 调用 <code>set-mark-command</code> 。<br></p>

<div class="highlight"><pre><span></span>Lorem ipsum dolor sit amet
      ^ Cursor


      Point
      |
      Mark
      |
Lorem ipsum dolor sit amet
      ^ C-spc


      Mark          Point
      | ----region--|
      |             |
Lorem ipsum dolor sit amet
	 move       ^
	 forward -&gt;


      Mark          Point
      | ----region--|
      |             |
Lorem ipsum dolor sit amet
		    ^
		    C-x C-x


      Point         Mark
      | ----region--|
      |             |
Lorem ipsum dolor sit amet

Point and mark interchanged
</pre></div>
</div>
</div>

<div id="outline-container-orgb1a4dd8" class="outline-3">
<h3 id="orgb1a4dd8">
<span class="section-number-3">3.2</span> 使用 <code>region</code> 进行重复性输入</h3>
<div class="outline-text-3" id="text-3-2">
<p>
对于 <code>region</code> 相关的操作，通常是对已经存在的代码段进行编辑的，如果我们在输入之前就知道有许多字段是需要重复输入的，那么就可以在输入之前设置好 <code>mark</code> ，对输入后形成的 <code>region</code> 完成复制。这个技巧在特定情况能够很大地提升输入效率，但是我个人认为，想要在实战中完成这个操作，还需要保证非常清晰的思路。可以通过下面的示例感受这种操作带来的方便(示例截取自Paul的博文)。<br></p>

<p>
<img src="/assets/images/spinner.svg" data-src="/images/post-navigation-and-selection-effectively-in-emacs-1.gif" alt="nil"><br></p>

<p>
下面给出了详细的操作解析<br></p>

<div class="highlight"><pre><span></span>class
      ^ C-spc =&gt; Activate mark

class Foo
	  ^ M-w =&gt; Foo has now been killed (copied)

class Foo extends React.Component&lt;
				  ^ C-spc =&gt; Activate mark

class Foo extends React.Component&lt;
				  ^ C-y =&gt; Yank (paste) Foo

class Foo extends React.Component&lt;FooProps
					  ^ M-w =&gt; FooProps has now been killed (copied)

class Foo extends React.Component&lt;FooProps&gt;

// Later
interface
	   ^ C-y =&gt; Yank FooProps

interface FooProps {}
</pre></div>
</div>
</div>

<div id="outline-container-org2597381" class="outline-3">
<h3 id="org2597381">
<span class="section-number-3">3.3</span> 框选一个矩形的 <code>region</code>
</h3>
<div class="outline-text-3" id="text-3-3">
<p>
使用 <code>rectangle-mark-mode</code> 命令，默认快捷键 <code>C-x-SPC</code> ，能够框选出一个矩形的 <code>region</code> 。对于矩形 <code>region</code> ，Paul给出的示例是复制 <code>dired</code> 中的多个文件名称，貌似其他合适的使用场景不太多。<br></p>

<p>
<img src="/assets/images/spinner.svg" data-src="/images/post-navigation-and-selection-effectively-in-emacs-2.gif" alt="nil"><br></p>
</div>
</div>
</div>


<div id="outline-container-orge557fa8" class="outline-2">
<h2 id="orge557fa8">
<span class="section-number-2">4</span> 其他插件支持</h2>
<div class="outline-text-2" id="text-4">
<p>
有些插件拓展能够实现光标的快速定位，如 <a href="https://github.com/ShingoFukuyama/helm-swoop">helm-swoop</a> 和 <a href="https://github.com/abo-abo/avy">avy</a> 。<br></p>
</div>

<div id="outline-container-org169dfa8" class="outline-3">
<h3 id="org169dfa8">
<span class="section-number-3">4.1</span> helm swoop</h3>
<div class="outline-text-3" id="text-4-1">
<p>
从我个人的使用体验来看 <a href="https://github.com/ShingoFukuyama/helm-swoop">helm-swoop</a> 和helm occur的功能十分相似，它们都提供了方便的关键词跳转功能。<br></p>

<p>
下面的图片来自helm swoop的 <a href="https://github.com/ShingoFukuyama/helm-swoop">主页</a><br></p>

<p>
<img src="/assets/images/spinner.svg" data-src="/images/post-navigation-and-selection-effectively-in-emacs-3.gif" alt="nil"><br></p>
</div>
</div>

<div id="outline-container-orgb5445a0" class="outline-3">
<h3 id="orgb5445a0">
<span class="section-number-3">4.2</span> avy</h3>
<div class="outline-text-3" id="text-4-2">
<p>
<a href="https://github.com/abo-abo/avy">avy</a> 的思路非常独特，这样的跳转和定位让我想起了Chrome浏览器中的Vimium插件，他允许我们使用更少的按键就能跳转到当前buffer中的任意位置，略微遗憾的是它只支持拉丁字母，不过在编写代码的大多数情况下是够用的。<br></p>

<p>
下面的图片来自Paul的博文<br></p>

<p>
<img src="/assets/images/spinner.svg" data-src="/images/post-navigation-and-selection-effectively-in-emacs-4.gif" alt="nil"><br></p>
</div>
</div>
</div>


<div id="outline-container-org13d855b" class="outline-2">
<h2 id="org13d855b">
<span class="section-number-2">5</span> 参考资料</h2>
<div class="outline-text-2" id="text-5">
<ul class="org-ul">
<li>
<a href="https://lorefnon.tech/2018/07/14/getting-productive-with-selection-and-navigation-in-emacs/">lorefnon.tech</a><br>
</li>
<li>
<a href="https://github.com/ShingoFukuyama/helm-swoop">helm-swoop</a><br>
</li>
<li>
<a href="https://github.com/abo-abo/avy">avy</a><br>
</li>
</ul>
</div>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/shell-output-redirections/" class="u-url">shell的输出重定向</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-07-26T10:02:41+08:00" itemprop="datePublished" title="2018-07-26 10:02">Jul 26 2018  (10:02)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/shell-output-redirections/#disqus_thread" data-disqus-identifier="cache/posts/shell-output-redirections.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/linux/" rel="tag">linux</a></li>
        <li><a class="tag p-category" href="/tags/shell/" rel="tag">shell</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <div id="outline-container-org7a0c39a" class="outline-2">
<h2 id="org7a0c39a">引言</h2>
<div class="outline-text-2" id="text-org7a0c39a">
<p>
在linux中借助shell等命令行工具能够很方便地与操作系统交互，可以在shell中将命令或程序的输入结果重定向到特定地方，很方便地实现一些功能。这个技巧十分实用，使用输出重定向能够极大地简化我们的日常操作。<br></p>
</div>
</div>

<div id="outline-container-org1d47bd8" class="outline-2">
<h2 id="org1d47bd8">使用尖括号完成重定向</h2>
<div class="outline-text-2" id="text-org1d47bd8">
<p>
示例如下，运行下面的命令能够把 <code>ls</code> 命令的运行结果写入到 <code>ls-output.txt</code> 中。使用 <code>&gt;</code> 会把程序运行时本该输出到 <code>stdout</code> 的内容重定向到指定名称的文件中。<br></p>
<div class="highlight"><pre><span></span>ls . &gt; ls-output.txt
</pre></div>
<p>
可以在 <code>&gt;</code> 左面写上数字和 <code>&amp;</code> ，用以标识在重定向时的特殊用法。下面会给出一些特殊用法的实例。<br></p>
</div>

<div id="outline-container-orgb12477c" class="outline-3">
<h3 id="orgb12477c">重定向 <code>stdout</code> 到指定文件中</h3>
<div class="outline-text-3" id="text-orgb12477c">
<div class="highlight"><pre><span></span>ls . <span class="m">1</span>&gt; ls-output.txt
</pre></div>
</div>
</div>

<div id="outline-container-orgb4f054a" class="outline-3">
<h3 id="orgb4f054a">重定向 <code>stderr</code> 到指定文件中</h3>
<div class="outline-text-3" id="text-orgb4f054a">
<div class="highlight"><pre><span></span>ls . <span class="m">2</span>&gt; ls-error.txt
</pre></div>
</div>
</div>

<div id="outline-container-org872c647" class="outline-3">
<h3 id="org872c647">将 <code>stdout</code> 和 <code>stdout</code> 合并再重定向到指定文件中</h3>
<div class="outline-text-3" id="text-org872c647">
<div class="highlight"><pre><span></span>ls . <span class="m">2</span>&gt;<span class="p">&amp;</span><span class="m">1</span> ls-output-and-error.txt
</pre></div>
<p>
以下命令具有相同的效果<br></p>
<div class="highlight"><pre><span></span>ls . <span class="p">&amp;</span>&gt; ls-output-and-error.txt
</pre></div>
</div>
</div>

<div id="outline-container-org524908b" class="outline-3">
<h3 id="org524908b">将程序的输出丢掉</h3>
<div class="outline-text-3" id="text-org524908b">
<p>
可以将输出重定向到一个特殊的文件 <code>/dev/null</code> ，所有写入到这个文件的内容都会被丢弃掉。<br></p>
<div class="highlight"><pre><span></span>program &gt; /dev/null
</pre></div>
</div>
</div>

<div id="outline-container-orgf12d38b" class="outline-3">
<h3 id="orgf12d38b">将输出追加到指定文件尾部</h3>
<div class="outline-text-3" id="text-orgf12d38b">
<p>
使用一个尖括号（ <code>&gt;</code> ）能够将输出重定向到文件中，在写入文件时会覆盖掉其中的内容。如果想保留文件中的原始内容，则可以用两个尖括号（ <code>&gt;&gt;</code> ），这样就能将输出追加到文件的尾部。示例代码如下：<br></p>
<div class="highlight"><pre><span></span><span class="nb">echo</span> <span class="nb">test</span> &gt;&gt; file-output.txt
</pre></div>
</div>
</div>
</div>

<div id="outline-container-org506d2d7" class="outline-2">
<h2 id="org506d2d7">使用管道完成重定向</h2>
<div class="outline-text-2" id="text-org506d2d7">
<p>
使用管道符号 <code>|</code> 能够将一个程序的输出重定向到另一个程序的输入中去。下面的命令会将 <code>ls</code> 的输出（ <code>stdout</code> ）重定向到 <code>grep</code> 的输入（ <code>stdin</code> ）中去。管道命令在linux中是最常见的用法。<br></p>
<div class="highlight"><pre><span></span>ls <span class="p">|</span> grep &lt;pattern&gt;
</pre></div>
</div>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/notes-on-libshmcache/" class="u-url">libshmcache源码阅读笔记</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-07-23T10:51:59+08:00" itemprop="datePublished" title="2018-07-23 10:51">Jul 23 2018  (10:51)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/notes-on-libshmcache/#disqus_thread" data-disqus-identifier="cache/posts/notes-on-libshmcache.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/c/" rel="tag">c</a></li>
        <li><a class="tag p-category" href="/tags/memcached/" rel="tag">memcached</a></li>
        <li><a class="tag p-category" href="/tags/redis/" rel="tag">redis</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <div id="outline-container-org04fe53b" class="outline-2">
<h2 id="org04fe53b">引言</h2>
<div class="outline-text-2" id="text-org04fe53b">
<p>
由于在工作中需要开发一套内存缓存服务，使用了共享内存作为多进程间的数据共享。为了提高共享内存缓存服务的性能，我找了一个类似的较为成熟的开源项目 <a href="https://github.com/happyfish100/libshmcache">libshmcache</a> ，通过研究源码学习其中的优点并改进自己的模块。<br></p>

<p>
libshmcache与redis相似的是都使用内存进行数据缓存；与redis不同的是，redis使用的进程自己申请的动态内存，而libshmcache使用的是共享内存。使用共享内存就意味着libshmcache主要的应用场景是同一台主机上的数据缓存。<br></p>

<p>
我花了一周时间阅读了比较感兴趣的部分代码，收获不少，现就以下几个方面总结一下自己的心得：<br></p>
<ul class="org-ul">
<li>纯C语言开发的代码风格<br>
</li>
<li>hash table的原理和实现<br>
</li>
<li>gcc原子化操作接口<br>
</li>
<li>有锁写和无锁读的实现细节<br>
</li>
<li>共享内存的两套函数接口(POSIX和SystemV)<br>
</li>
</ul>
</div>
</div>


<div id="outline-container-orgd7d3ea1" class="outline-2">
<h2 id="orgd7d3ea1">纯C语言开发时的代码风格</h2>
<div class="outline-text-2" id="text-orgd7d3ea1">
<p>
我在工作中使用比较多的开发语言是C++，对于C语言编写的这样规模的项目，还是第一次仔细深入地研究。C语言使用 <code>struct</code> 作为大多数自定义数据结构的关键字，相对于C++能够使用成员函数能够对类进行功能拓展，C语言比较常用的是将这个对象作为输入参数传到函数中。<br></p>

<p>
纵观所有项目代码，我感受比较深的就是使用结构体中嵌套匿名结构体，这样做能够增强数据结构的层次感，示例代码如下：<br></p>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">shmcache_context</span> <span class="p">{</span>
    <span class="kt">pid_t</span> <span class="n">pid</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">lock_fd</span><span class="p">;</span>    <span class="c1">//for file lock</span>
    <span class="kt">int</span> <span class="n">detect_deadlock_clocks</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">shmcache_config</span> <span class="n">config</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">shm_memory_info</span> <span class="o">*</span><span class="n">memory</span><span class="p">;</span>
    <span class="k">struct</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">shmcache_segment_info</span> <span class="n">hashtable</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
	    <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	    <span class="k">struct</span> <span class="n">shmcache_segment_info</span> <span class="o">*</span><span class="n">items</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">values</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">segments</span><span class="p">;</span>

    <span class="k">struct</span> <span class="n">shmcache_value_allocator_context</span> <span class="n">value_allocator</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">shmcache_list</span> <span class="n">list</span><span class="p">;</span>   <span class="c1">//for value recycle</span>
    <span class="kt">bool</span> <span class="n">create_segment</span><span class="p">;</span>  <span class="c1">//if check segment size                                  </span>
<span class="p">};</span>
</pre></div>
<p>
注意 <code>shmcache_context</code> 中的匿名结构体 <code>segments</code> 和 <code>values</code> ，这样的写法体现了相互包含关系，也使后续的操作该数据结构的语句更加容易理解。<br></p>

<p>
另外对于联合体和位域这两种技术也是我在之前开发中使用比较少的，通过阅读源码能够让我对其有了更深刻的理解。示例代码如下：<br></p>
<div class="highlight"><pre><span></span><span class="k">union</span> <span class="n">shm_hentry_offset</span> <span class="p">{</span>
    <span class="kt">int64_t</span> <span class="n">offset</span><span class="p">;</span>
    <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="nl">index</span> <span class="p">:</span><span class="mi">16</span><span class="p">;</span>
	<span class="kt">int64_t</span> <span class="nl">offset</span> <span class="p">:</span><span class="mi">48</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">segment</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
<p>
这段代码使用了联合体赋予了 <code>shm_hentry_offset</code> 两种访问方式，又使用了位域将 <code>int64_t</code> 分割为两段。<br></p>
</div>
</div>


<div id="outline-container-orgbe6058e" class="outline-2">
<h2 id="orgbe6058e">hash table的原理和实现</h2>
<div class="outline-text-2" id="text-orgbe6058e">
<p>
libshmcache内部使用的是hash table做内部缓存的数据结构，这使查找的时间复杂度是O(1)。<br>
之前看过一些介绍hash table的资料，对hash table的工作原理是有过一个基础的了解的，这次通过阅读源码，能够了解到hash table在代码实现上更加细节的内容。<br>
对于hash计算中出现的hash值冲突，即在hash计算时出现了两个不同的key在经过hash计算后得到的bucket相同，libshmcache采用的解决方案是使用linked list来存放这些相同bucket对应的value。<br></p>
</div>
</div>


<div id="outline-container-org6b11ef8" class="outline-2">
<h2 id="org6b11ef8">gcc原子化操作接口</h2>
<div class="outline-text-2" id="text-org6b11ef8">
<p>
使用原子化操作接口能够解决一些并发读写问题，原子化操作相对于互斥锁执行更快。原子化操作也是一种无锁编程的方式。<br></p>
</div>
</div>


<div id="outline-container-orgded9e27" class="outline-2">
<h2 id="orgded9e27">有锁写和无锁读的实现</h2>
<div class="outline-text-2" id="text-orgded9e27">
<p>
在libshmcache中，写操作通过 <code>pthread_mutex_t</code> 进行同步，而读操作是无锁的。<br>
对于写操作来说，需要对hash table进行操作，这肯定是需要同步的。<br>
将 <code>pthread_mutex_t</code> 保存在共享内存中，不同的进程通过映射共享内存就能获得同一个互斥量，通过这个互斥量就能完成进程间同步。<br></p>
</div>
</div>


<div id="outline-container-orgd8e6e19" class="outline-2">
<h2 id="orgd8e6e19">共享内存的两套函数接口(POSIX和SystemV)</h2>
<div class="outline-text-2" id="text-orgd8e6e19">
<p>
在linux上使用共享内存时有两套接口 <code>mmap</code> 和 <code>shmget</code> 。 <code>mmap</code> 是 <code>POSIX</code> 标准的接口，而 <code>shmget</code> 是 <code>System V</code> 标准的接口，两者都能够实现进程间共享内存，但他们在使用上还是有些区别的。对于 <code>mmap</code> 来说，需要在硬盘上创建一个文件，再将该文件映射到内存中。对于 <code>shmget</code> 来说，需要指定一个key，不同的进程通过相同的key就能映射到同一片内存。<br></p>
</div>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/bit-field/" class="u-url">C/C++中的位域</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-07-11T18:03:37+08:00" itemprop="datePublished" title="2018-07-11 18:03">Jul 11 2018  (18:03)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/bit-field/#disqus_thread" data-disqus-identifier="cache/posts/bit-field.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/cpp/" rel="tag">cpp</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <div id="outline-container-org5fe90ad" class="outline-2">
<h2 id="org5fe90ad">
<span class="section-number-2">1</span> 什么是位域</h2>
<div class="outline-text-2" id="text-1">
<p>
<a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E6%AE%B5">维基百科</a> 给出了以下解释<br></p>
<blockquote>
<p>
位域（或称“位段”，bit field）为一种数据结构，可以把数据以位的形式紧凑的储存，并允许程序员对此结构的位进行操作。<br></p>
</blockquote>

<p>
<a href="https://en.cppreference.com/w/cpp/language/bit_field">cppreference</a> 给出了以下定义<br></p>
<blockquote>
<p>
Declares a class data member with explicit size, in bits. Adjacent bit field members may be packed to share and straddle the individual bytes.<br></p>
</blockquote>

<p>
这种数据结构的好处：<br></p>
<ul class="org-ul">
<li>可以使数据单元节省储存空间，当程序需要成千上万个数据单元时，这种方法就显得尤为重要。<br>
</li>
<li>位段可以很方便的访问一个整数值的部分内容从而可以简化程序源代码。<br>
</li>
</ul>
<p>
而位域这种数据结构的缺点在于，其内存分配与内存对齐的实现方式依赖于具体的机器和系统，在不同的平台可能有不同的结果，这导致了位段在本质上是不可移植的。<br></p>
</div>
</div>

<div id="outline-container-orgc4f0854" class="outline-2">
<h2 id="orgc4f0854">
<span class="section-number-2">2</span> 位域的语法</h2>
<div class="outline-text-2" id="text-2">
<div class="highlight"><pre><span></span><span class="n">identifier</span><span class="p">(</span><span class="n">optional</span><span class="p">)</span> <span class="n">attr</span><span class="p">(</span><span class="n">optional</span><span class="p">)</span> <span class="o">:</span> <span class="n">size</span>
</pre></div>

<p>
注意：<br></p>
<ul class="org-ul">
<li>size的大小不能超过identifier所包含最大比特位个数。<br>
</li>
<li>identifier为空时表示对应的size个数的比特位不使用<br>
</li>
<li>size为0时表示根据前类型强制补齐<br>
</li>
</ul>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">S1</span> <span class="p">{</span>
    <span class="c1">// will usually occupy 2 bytes:</span>
    <span class="c1">// 3 bits: value of b1</span>
    <span class="c1">// 2 bits: unused</span>
    <span class="c1">// 6 bits: value of b2</span>
    <span class="c1">// 2 bits: value of b3</span>
    <span class="c1">// 3 bits: unused</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nl">b1</span> <span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nl">b2</span> <span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="nl">b3</span> <span class="p">:</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">S2</span> <span class="p">{</span>
    <span class="c1">// will usually occupy 2 bytes:</span>
    <span class="c1">// 3 bits: value of b1</span>
    <span class="c1">// 5 bits: unused</span>
    <span class="c1">// 6 bits: value of b2</span>
    <span class="c1">// 2 bits: value of b3</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nl">b1</span> <span class="p">:</span> <span class="mi">3</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">:</span><span class="mi">0</span><span class="p">;</span> <span class="c1">// start a new byte</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nl">b2</span> <span class="p">:</span> <span class="mi">6</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nl">b3</span> <span class="p">:</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>

<div id="outline-container-org0d2e6d0" class="outline-3">
<h3 id="org0d2e6d0">
<span class="section-number-3">2.1</span> 在size取0时如何理解</h3>
<div class="outline-text-3" id="text-2-1">
<p>
对于size取0时的各种情况进行了尝试，详细用例如下。思路是使用联合体能比较方便地将内存分布表示出来。<br>
如下所示，定义了如下几种情况。<br></p>
</div>

<div id="outline-container-orga5096f1" class="outline-4">
<h4 id="orga5096f1">
<span class="section-number-4">2.1.1</span> case1</h4>
<div class="outline-text-4" id="text-2-1-1">
<div class="highlight"><pre><span></span><span class="k">union</span> <span class="n">un1</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n1</span><span class="p">;</span>
    <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="nl">nn1</span> <span class="p">:</span> <span class="mi">4</span><span class="p">;</span>
	<span class="kt">int</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="nl">nn2</span> <span class="p">:</span> <span class="mi">16</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">st</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
<p>
对联合体中的结构体位段进行赋值，并将联合体中的内容打印出来。<br></p>
<div class="highlight"><pre><span></span><span class="k">union</span> <span class="n">un1</span> <span class="n">u1</span><span class="p">;</span>
<span class="n">u1</span><span class="p">.</span><span class="n">st</span><span class="p">.</span><span class="n">nn1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">u1</span><span class="p">.</span><span class="n">st</span><span class="p">.</span><span class="n">nn2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"union u1.n1=0x%08x sizeof(un1)=%zu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">u1</span><span class="p">.</span><span class="n">n1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">un1</span><span class="p">));</span>
</pre></div>
<p>
输出结果为<br></p>
<div class="highlight"><pre><span></span><span class="k">union</span> <span class="n">un1</span><span class="p">.</span><span class="n">n1</span><span class="o">=</span><span class="mh">0x00000001</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">un1</span><span class="p">)</span><span class="o">=</span><span class="mi">8</span>
</pre></div>
</div>
</div>

<div id="outline-container-orge2fec9f" class="outline-4">
<h4 id="orge2fec9f">
<span class="section-number-4">2.1.2</span> case2</h4>
<div class="outline-text-4" id="text-2-1-2">
<div class="highlight"><pre><span></span><span class="k">union</span> <span class="n">un1</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n1</span><span class="p">;</span>
    <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="nl">nn1</span> <span class="p">:</span> <span class="mi">4</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="nl">nn2</span> <span class="p">:</span> <span class="mi">16</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">st</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
<p>
输出结果为<br></p>
<div class="highlight"><pre><span></span><span class="k">union</span> <span class="n">un1</span><span class="p">.</span><span class="n">n1</span><span class="o">=</span><span class="mh">0x00000101</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">un1</span><span class="p">)</span><span class="o">=</span><span class="mi">4</span>
</pre></div>
</div>
</div>

<div id="outline-container-org69dc891" class="outline-4">
<h4 id="org69dc891">
<span class="section-number-4">2.1.3</span> case3</h4>
<div class="outline-text-4" id="text-2-1-3">
<div class="highlight"><pre><span></span><span class="k">union</span> <span class="n">un1</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n1</span><span class="p">;</span>
    <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="nl">nn1</span> <span class="p">:</span> <span class="mi">4</span><span class="p">;</span>
	<span class="kt">short</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="nl">nn2</span> <span class="p">:</span> <span class="mi">16</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">st</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
<p>
输出结果为<br></p>
<div class="highlight"><pre><span></span><span class="k">union</span> <span class="n">un1</span><span class="p">.</span><span class="n">n1</span><span class="o">=</span><span class="mh">0x00010001</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">un1</span><span class="p">)</span><span class="o">=</span><span class="mi">4</span>
</pre></div>
</div>
</div>


<div id="outline-container-org6204ad6" class="outline-4">
<h4 id="org6204ad6">
<span class="section-number-4">2.1.4</span> case4</h4>
<div class="outline-text-4" id="text-2-1-4">
<div class="highlight"><pre><span></span><span class="k">union</span> <span class="n">un1</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n1</span><span class="p">;</span>
    <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="nl">nn1</span> <span class="p">:</span> <span class="mi">8</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="nl">nn2</span> <span class="p">:</span> <span class="mi">16</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">st</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
<p>
输出结果为<br></p>
<div class="highlight"><pre><span></span><span class="k">union</span> <span class="n">un1</span><span class="p">.</span><span class="n">n1</span><span class="o">=</span><span class="mh">0x00000101</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">un1</span><span class="p">)</span><span class="o">=</span><span class="mi">4</span>
</pre></div>
</div>
</div>
</div>

<div id="outline-container-org924dd8d" class="outline-3">
<h3 id="org924dd8d">
<span class="section-number-3">2.2</span> <code>struct</code> 标识符</h3>
<div class="outline-text-3" id="text-2-2">
<p>
多数例子都是以 <code>struct</code> 作为位域的组织标识，在C++中能否使用 <code>class</code> 作为位域的标识符。<br>
经过测试，是可以使用 <code>class</code> 的，但是需要注意 <code>class</code> 的默认访问控制属性为 <code>private</code><br></p>
</div>
</div>
</div>

<div id="outline-container-org6dec9e5" class="outline-2">
<h2 id="org6dec9e5">
<span class="section-number-2">3</span> 位域的常见应用场景</h2>
<div class="outline-text-2" id="text-3">
<p>
<b>为什么要使用位域？位域适合那些情况？</b><br>
位域的主要使用目的是节省对象的内存使用。在存放一些比较小的数据时，使用位域能够使字节中的每个比特位合理地利用起来，避免内存浪费。<br>
比较典型的应用是描述硬件寄存器。如果有32个一组的寄存器，每个寄存器代表一个比特位，就可以使用位域表示这组寄存器。<br></p>
</div>
</div>

<div id="outline-container-orgda64dbf" class="outline-2">
<h2 id="orgda64dbf">
<span class="section-number-2">4</span> C++中的位操作接口</h2>
<div class="outline-text-2" id="text-4">
<p>
C++中也提供了一套位操作的接口 <code>std::bitset</code> ，这套接口提供了指定比特位数据的操作接口。<br></p>
</div>
</div>

<div id="outline-container-org00e61f0" class="outline-2">
<h2 id="org00e61f0">
<span class="section-number-2">5</span> 参考资料</h2>
<div class="outline-text-2" id="text-5">
<ul class="org-ul">
<li>
<a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E6%AE%B5">wikipedia bit-field</a><br>
</li>
<li>
<a href="https://en.cppreference.com/w/cpp/language/bit_field">cppreference bit-field</a><br>
</li>
<li>
<a href="https://msdn.microsoft.com/zh-cn/library/ewwyfdbe.aspx">microsoft msdn</a><br>
</li>
<li>
<a href="https://stackoverflow.com/questions/24933242/when-to-use-bit-fields-in-c">stackoverflow</a><br>
</li>
<li>
<a href="https://en.cppreference.com/w/cpp/utility/bitset">cppreference std::bitset</a><br>
</li>
</ul>
</div>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/gcc-built-in-functions-for-atomic-memory-access/" class="u-url">GCC的内存原子化操作函数接口</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-07-02T17:54:08+08:00" itemprop="datePublished" title="2018-07-02 17:54">Jul 02 2018  (17:54)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/gcc-built-in-functions-for-atomic-memory-access/#disqus_thread" data-disqus-identifier="cache/posts/gcc-built-in-functions-for-atomic-memory-access.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/gcc/" rel="tag">gcc</a></li>
        <li><a class="tag p-category" href="/tags/linux/" rel="tag">linux</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <div id="outline-container-org4f1fa54" class="outline-2">
<h2 id="org4f1fa54">
<span class="section-number-2">1</span> 原子化操作</h2>
<div class="outline-text-2" id="text-1">
<p>
在并发编程中，一个操作或一组操作是原子操作、可线性化操作、不可分操作或不可中断操作（atomic, linearizable, indivisible, uniterruptible），表示该操作执行时不可被中断的。操作的原子性能够保证操作在执行时免受中断、信号、并发进程线程的影响。另外，原子操作大多只有两种结果，要么成功并改变系统中对应的状态，要么没有相关效果。<br></p>

<p>
原子化经常由互斥来保证，可以在硬件层面建立一个缓存一致性协议，也可以在软件层面使用信号量或加锁。因此，一个原子操作不是必须实际上马上生效，而操作系统让这个操作看起来是直接发生的，这能够让操作系统保持一致。正是如此，只要不影响性能，用户可以忽略较底层的实现细节。<br></p>
</div>
</div>

<div id="outline-container-orgab70719" class="outline-2">
<h2 id="orgab70719">
<span class="section-number-2">2</span> 函数接口</h2>
<div class="outline-text-2" id="text-2">
<p>
GCC提供了原子化的操作接口，能够支持长度为1、2、4、8字节的整形变量或指针。<br></p>

<blockquote>
<p>
In most cases, these builtins are considered a full barrier. That is, no memory operand will be moved across the operation, either forward or backward. Further, instructions will be issued as necessary to prevent the processor from speculating loads across the operation and from queuing stores after the operation.<br></p>
</blockquote>
<p>
在大多数情况下，这些内建函数是完全内存栅栏（full barrier）的，以上摘自 GCC Manual。<br></p>

<p>
<b>取值并进行对应操作的接口</b> 如下所示：<br></p>
<div class="highlight"><pre><span></span><span class="n">type</span> <span class="n">__sync_fetch_and_add</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">type</span> <span class="n">__sync_fetch_and_sub</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">type</span> <span class="n">__sync_fetch_and_or</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">type</span> <span class="n">__sync_fetch_and_and</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">type</span> <span class="n">__sync_fetch_and_xor</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">type</span> <span class="n">__sync_fetch_and_nand</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
<p>
这些函数接口的执行逻辑如下：会执行名称相对应的运算，并将内存中之前存放的值取出并返回。<br></p>
<div class="highlight"><pre><span></span><span class="p">{</span> <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span> <span class="o">*</span><span class="n">ptr</span> <span class="n">op</span><span class="o">=</span> <span class="n">value</span><span class="p">;</span> <span class="k">return</span> <span class="n">tmp</span><span class="p">;</span> <span class="p">}</span>
<span class="p">{</span> <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">value</span><span class="p">);</span> <span class="k">return</span> <span class="n">tmp</span><span class="p">;</span> <span class="p">}</span>   <span class="c1">// nand</span>
</pre></div>
<p>
<b>需要注意的是</b> ：从GCC 4.4开始 <code>__sync_fetch_and_nand</code> 是按照 <code>*ptr = ~(*ptr &amp; value)</code> 实现的，而不是 <code>*ptr = ~*ptr &amp; value</code><br></p>

<p>
<b>直接操作并返回结果的接口</b> 如下所示：<br></p>
<div class="highlight"><pre><span></span><span class="n">type</span> <span class="n">__sync_add_and_fetch</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">type</span> <span class="n">__sync_sub_and_fetch</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">type</span> <span class="n">__sync_or_and_fetch</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">type</span> <span class="n">__sync_and_and_fetch</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">type</span> <span class="n">__sync_xor_and_fetch</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">type</span> <span class="n">__sync_nand_and_fetch</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
<p>
这些函数接口的执行逻辑如下：<br></p>
<div class="highlight"><pre><span></span><span class="p">{</span> <span class="o">*</span><span class="n">ptr</span> <span class="n">op</span><span class="o">=</span> <span class="n">value</span><span class="p">;</span> <span class="k">return</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span> <span class="p">}</span>
<span class="p">{</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="o">*</span><span class="n">ptr</span> <span class="o">&amp;</span> <span class="n">value</span><span class="p">);</span> <span class="k">return</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span> <span class="p">}</span>   <span class="c1">// nand</span>
</pre></div>
<p>
<b>需要注意的是</b> ：从GCC 4.4开始 <code>__sync_nand_and_fetch</code> 是按照 <code>*ptr = ~(*ptr &amp; value)</code> 实现的，而不是 <code>*ptr = ~*ptr &amp; value</code><br></p>

<p>
比较并交换的函数接口<br></p>
<div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="n">__sync_bool_compare_and_swap</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">oldval</span> <span class="n">type</span> <span class="n">newval</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">type</span> <span class="n">__sync_val_compare_and_swap</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">oldval</span> <span class="n">type</span> <span class="n">newval</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
</div>

<div id="outline-container-org3954ec8" class="outline-2">
<h2 id="org3954ec8">
<span class="section-number-2">3</span> 内存栅栏（Memory Barrier）</h2>
<div class="outline-text-2" id="text-3">
<p>
在上面的说明中提到了memory barrier的概念，这个概念是CPU指令的一个术语。<br></p>

<p>
内存栅栏又叫内存屏障，是一种能够让CPU或编译器约束内存操作指令执行顺序的屏蔽指令。这表示在内存栅栏前的指令能够保证执行时先于内存栅栏后的指令。由于大多数现代CPU采用性能优化会导致指令执行变序时，所以内存栅栏是十分必要的。这样的指令变序对于单线程程序一般不会有很大影响，但是在并发编程情况下如果不加以控制就会导致不可预知的结果。<br></p>

<p>
内存栅栏的典型应用场景就是用于实现多设备之间的共享内存的底层机器码。这些代码包括原始同步机制、多核系统上的无锁数据结构、与计算机硬件交互的设备驱动。<br></p>

<p>
内存栅栏对于无锁编程来说十分重要的。<br></p>

<p>
<b>内存栅栏与volatile关键字</b><br>
内存栅栏分为读栅栏（read barrier）、写栅栏（write barrier）、获取栅栏（acquire barrier）、释放栅栏（release barrier）等。内存栅栏并不能保证数值的是“最新的”或“新鲜的”，它只能控制内存访问的相对顺序。<br></p>

<p>
“写栅栏”用于控制写操作的顺序。由于相对于CPU的执行速度来说，向内存中写入顺序是比较慢的，通常会有一个写入请求队列，所以实际的写入操作发生在指令发起之后，队列中指令的顺序可能会被重新排序。写栅栏能够防止指令变序。<br></p>

<p>
“读栅栏”用于控制读操作的顺序。由于预先执行（CPU会提前将内存中的数据读回来），并且CPU有缓存区（CPU会从缓存中而不是内存中读取数据），读操作可能会出现变序。<br></p>

<p>
volatile关键字值能通知编译器生成的输出码从内存中重新读取数据，但是不会告诉CPU在如何读取数据、在哪里读取数据。<br></p>

<p>
“获取栅栏”能够保证特定指令块之前的执行顺序。例如获取读，在向读队列中加入读操作，“获取栅栏”意味着在这条操作之后可以出现指令变序，而这条操作之前不会出现指令变序。<br></p>

<p>
“释放栅栏”能够保证特定指令块之后的执行顺序。例如释放写，在向写队列中加入写操作，“释放栅栏”意味着在这条写操作之前的指令不会变序到该指令之后，而这条该操作的之后的指令可能会变序到该指令之前。<br></p>

<p>
获取栅栏和释放栅栏是又叫半栅栏（half barrier），这是因为它们只能防止单方向的指令变序。<br></p>
</div>
</div>


<div id="outline-container-org8cebe73" class="outline-2">
<h2 id="org8cebe73">
<span class="section-number-2">4</span> 操作原子化能够解决多进程访问共享内存的问题吗？</h2>
<div class="outline-text-2" id="text-4">
<p>
原子化操作是对于CPU而言的指令操作，它不关心线程还是进程，它只关心这一系列的指令是不可分割的。所以，进程间可以使用原子操作完成内存的操作同步。<br></p>
</div>
</div>


<div id="outline-container-orgf81791a" class="outline-2">
<h2 id="orgf81791a">
<span class="section-number-2">5</span> 参考资料</h2>
<div class="outline-text-2" id="text-5">
<ul class="org-ul">
<li>
<a href="https://en.wikipedia.org/wiki/Linearizability">Wikipedia - Linearizability</a><br>
</li>
<li>
<a href="https://gcc.gnu.org/onlinedocs/gcc-4.4.3/gcc/Atomic-Builtins.html">GNU GCC online docs</a><br>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Memory_barrier">Wikipedia - Memory Barrier</a><br>
</li>
<li>
<a href="https://stackoverflow.com/questions/1787450/how-do-i-understand-read-memory-barriers-and-volatile">stackoverflow - memory barrier and volatile</a><br>
</li>
<li>
<a href="https://stackoverflow.com/questions/8160348/lock-freedom-atomic-operations-across-2-processes-instead-of-threads">stackoverflow - atomic operation in multi process</a><br>
</li>
<li>
<a href="https://en.cppreference.com/w/cpp/atomic">cppreference - atomic</a><br>
</li>
</ul>
</div>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/gdb-display-contents-of-memory-address/" class="u-url">在gdb中查看指定内存地址的内容</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-06-29T16:45:09+08:00" itemprop="datePublished" title="2018-06-29 16:45">Jun 29 2018  (16:45)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/gdb-display-contents-of-memory-address/#disqus_thread" data-disqus-identifier="cache/posts/gdb-display-contents-of-memory-address.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/gdb/" rel="tag">gdb</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <div id="outline-container-orgb8d01fe" class="outline-2">
<h2 id="orgb8d01fe">
<span class="section-number-2">1</span> 引言</h2>
<div class="outline-text-2" id="text-1">
<p>
调试 C/C++ 程序时，需要打印指定内存地址的内容。我最近调试程序中的序列化模块时，需要将类对象按照指定的格式转化为二进制流，为了验证转化结果，在调试时就需要将指定内存地址中的内容打印出来。<br></p>
</div>
</div>

<div id="outline-container-org3b08950" class="outline-2">
<h2 id="org3b08950">
<span class="section-number-2">2</span> 指令语法</h2>
<div class="outline-text-2" id="text-2">
<p>
在gdb模式下，使用 <code>x</code> （ <code>examine</code> 的缩写）指令能够将指令内存地址中的信息打印出来。指令的语法如下。<br></p>
<div class="highlight"><pre><span></span>x/nfu addr
x addr
</pre></div>
<p>
其中 <code>n</code> 、 <code>f</code> 、 <code>u</code> 都是可选参数， <code>n</code> 表示重复次数， <code>f</code> 表示显示格式（format）， <code>u</code> 表示显示单元大小(unix size)。<br></p>

<p>
<code>f</code> <b>可以取如下值</b> ：<br>
x 按十六进制格式显示变量<br>
d 按十进制格式显示变量<br>
o 按八进制格式显示变量<br>
t 按二进制格式显示变量<br></p>

<p>
<code>u</code> <b>可以取如下值</b> ：<br>
b 表示单字节（byte）<br>
h 表示双字节（halfword）<br>
w 表示四字节(word)<br>
g 表示八字节(giant word)<br></p>
</div>
</div>

<div id="outline-container-orga6e2f65" class="outline-2">
<h2 id="orga6e2f65">
<span class="section-number-2">3</span> 示例</h2>
<div class="outline-text-2" id="text-3">
<p>
以下指令会以16进制格式显示addr开始的100字节信息<br></p>
<div class="highlight"><pre><span></span>x/100xb addr
</pre></div>
</div>
</div>

<div id="outline-container-orgc61e705" class="outline-2">
<h2 id="orgc61e705">
<span class="section-number-2">4</span> 参考资料</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li>
<a href="ftp://ftp.gnu.org/old-gnu/Manuals/gdb/html_chapter/gdb_9.html#SEC56">GDB manual(gnu.org)</a><br>
</li>
<li>
<a href="https://sourceware.org/gdb/onlinedocs/gdb/Memory.html">GDB manual(sourceware.org)</a><br>
</li>
</ul>
</div>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/asynchronous-synchronous-and-blocking-unblocking/" class="u-url">同步和异步、阻塞和非阻塞</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-06-26T09:27:06+08:00" itemprop="datePublished" title="2018-06-26 09:27">Jun 26 2018  (09:27)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/asynchronous-synchronous-and-blocking-unblocking/#disqus_thread" data-disqus-identifier="cache/posts/asynchronous-synchronous-and-blocking-unblocking.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/computer-science/" rel="tag">computer science</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <div id="outline-container-org5316894" class="outline-2">
<h2 id="org5316894">
<span class="section-number-2">1</span> 同步和异步</h2>
<div class="outline-text-2" id="text-1">
<p>
同步和异步指的是在进行I/O操作完成之前，是否允许其他处理步骤继续执行。<br>
计算机中的I/O操作相对于数据处理操作时十分耗时的。<br></p>

<p>
一个简单的I/O操作方式就是启动连接并等待操作完成，但是这样的操作（同步阻塞I/O）在通信过程中会阻塞进程的处理进度。<br>
相应的，可以在启动通信的同时进行其他的处理，并不需要等待I/O操作的完成，这样的操作就被称作是异步I/O。那些依赖于I/O操作执行完成的任务会阻塞等待I/O操作的完成，其他不依赖与I/O操作的任务能够继续执行。<br></p>

<p>
同步模型常用的函数接口： <code>read</code> , <code>write</code> , <code>send</code> , <code>recv</code><br>
异步模型常用的函数接口： <code>aio_write</code> , <code>aio_read</code><br></p>
</div>

<div id="outline-container-org291f6ab" class="outline-3">
<h3 id="org291f6ab">
<span class="section-number-3">1.1</span> POSIX AIO</h3>
<div class="outline-text-3" id="text-1-1">
<p>
在头文件 <code>aio.h</code> 中定义，链接时使用 <code>-lrt</code><br></p>

<p>
<b>函数接口</b><br>
异步写操作<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">aio_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">aiocb</span><span class="o">*</span> <span class="n">aiocbp</span><span class="p">);</span>
</pre></div>

<p>
异步读操作<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">aio_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">aiocb</span><span class="o">*</span> <span class="n">aiocbp</span><span class="p">);</span>
</pre></div>

<p>
获取异步操作结果<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">aio_return</span><span class="p">(</span><span class="k">struct</span> <span class="n">aiocb</span><span class="o">*</span> <span class="n">aiocbp</span><span class="p">);</span>
</pre></div>

<p>
获取异步操作中的错误<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">aio_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">aiocb</span><span class="o">*</span> <span class="n">aiocbp</span><span class="p">);</span>
</pre></div>

<p>
示例代码： <a href="https://gist.github.com/rsms/771059">github gist</a><br></p>
</div>
</div>

<div id="outline-container-org536fb95" class="outline-3">
<h3 id="org536fb95">
<span class="section-number-3">1.2</span> Linux AIO</h3>
<div class="outline-text-3" id="text-1-2">
<p>
在头文件 <code>libaio.h</code> 中定义，链接时使用 <code>-laio</code><br></p>

<p>
<b>函数接口</b><br>
需要注意的是aio的函数接口需要借助 <code>syscall</code> 进行调用。<br>
创建aio context对象<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">io_setup</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">nr</span><span class="p">,</span> <span class="n">aio_context_t</span><span class="o">*</span> <span class="n">ctxp</span><span class="p">);</span>
</pre></div>
<p>
销毁aio context对象<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">io_destroy</span><span class="p">(</span><span class="n">aio_context_t</span> <span class="n">ctx</span><span class="p">);</span>
</pre></div>
<p>
提交异步操作<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">io_submit</span><span class="p">(</span><span class="n">aio_context_t</span> <span class="n">ctx</span><span class="p">,</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iocb</span><span class="o">**</span> <span class="n">iocbpp</span><span class="p">);</span>
</pre></div>
<p>
获取异步操作结果<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">io_getevents</span><span class="p">(</span><span class="n">aio_context_t</span> <span class="n">ctx</span><span class="p">,</span> <span class="kt">long</span> <span class="n">min_nr</span><span class="p">,</span> <span class="kt">long</span> <span class="n">max_nr</span><span class="p">,</span>
		 <span class="n">io_event</span><span class="o">*</span> <span class="n">events</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span><span class="o">*</span> <span class="n">timeout</span><span class="p">);</span>
</pre></div>

<p>
示例代码:<br></p>
<ul class="org-ul">
<li>
<a href="https://gist.github.com/larytet/87f90b08643ac3de934df2cadff4989c">github gist</a><br>
</li>
<li>
<a href="http://www.xmailserver.org/eventfd-aio-test.c">xmailserver.org</a><br>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgb59a45a" class="outline-3">
<h3 id="orgb59a45a">
<span class="section-number-3">1.3</span> POSIX AIO与Linux AIO的区别</h3>
<div class="outline-text-3" id="text-1-3">
<p>
摘自 <a href="https://stackoverflow.com/questions/8768083/difference-between-posix-aio-and-libaio-on-linux">stackoverflow.com</a><br></p>
<blockquote>
<p>
On linux, the two AIO implementations are fundamentally different.<br>
The POSIX AIO is a user-level implementation that performs normal blocking I/O in multiple threads, hence giving the illusion that the I/Os are asynchronous. The main reason to do this is that:<br></p>
<ul class="org-ul">
<li>it works with any filesystem<br>
</li>
<li>it works (essentially) on any operating system (keep in mind that gnu's libc is portable)<br>
</li>
<li>it works on files with buffering enabled (i.e. no O<sub>DIRECT</sub> flag set)<br>
</li>
</ul>
<p>
The main drawback is that your queue depth (i.e. the number of outstanding operations you can have in practice) is limited by the number of threads you choose to have, which also means that a slow operation on one disk may block an operation going to a different disk. It also affects which I/Os (or how many) is seen by the kernel and the disk scheduler as well.<br>
The kernel AIO (i.e. io<sub>submit</sub>() et.al.) is kernel support for asynchronous I/O operations, where the io requests are actually queued up in the kernel, sorted by whatever disk scheduler you have, presumably some of them are forwarded (in somewhat optimal order one would hope) to the actual disk as asynchronous operations (using TCQ or NCQ). The main restriction with this approach is that not all filesystems work that well or at all with async I/O (and may fall back to blocking semantics), files have to be opened with O<sub>DIRECT</sub> which comes with a whole lot of other restrictions on the I/O requests. If you fail to open your files with O<sub>DIRECT</sub>, it may still "work", as in you get the right data back, but it probably isn't done asynchronously, but is falling back to blocking semantics.<br>
Also keep in mind that io<sub>submit</sub>() can actually block on the disk under certain circumstances.<br></p>
</blockquote>
<p>
在Linux上两种AIO是完全不同的；<br>
POSIX AIO实现在用户层，实际上进行的操作是普通的多线程阻塞操作，表现为I/O操作是异步的，这种AIO的优点是兼容性和可移植性好，缺点是操作队列长度受限于最大线程数量。<br>
Linux AIO是内核提供的AIO函数接口，I/O操作请求的队列在内核中维护，这种AIO的缺点是并不支持所有的文件系统，Linux AIO在某些情况下的磁盘操作是会阻塞的。<br></p>
</div>
</div>
</div>

<div id="outline-container-org8a12225" class="outline-2">
<h2 id="org8a12225">
<span class="section-number-2">2</span> 阻塞和非阻塞</h2>
<div class="outline-text-2" id="text-2">
<p>
阻塞与非阻塞的概念针对的是函数是否会立即返回。<br>
非阻塞模型常与IO复用技术组合使用。<br>
可以通过函数将IO设备设置为非阻塞模式。<br></p>
</div>
</div>


<div id="outline-container-org88af75c" class="outline-2">
<h2 id="org88af75c">
<span class="section-number-2">3</span> 如何理解阻塞非阻塞与同步异步的区别</h2>
<div class="outline-text-2" id="text-3">
<p>
在处理 IO 的时候，阻塞和非阻塞都是同步 IO。<br>
只有使用了特殊的 API 才是异步 IO。<br></p>
</div>
</div>


<div id="outline-container-org5d093f7" class="outline-2">
<h2 id="org5d093f7">
<span class="section-number-2">4</span> 参考资料</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li>
<a href="https://blog.csdn.net/hguisu/article/details/38638183">csdn.net</a><br>
</li>
<li>
<a href="https://github.com/littledan/linux-aio%20repo">github.com linux-aio</a><br>
</li>
<li>
<a href="https://www.ibm.com/developerworks/linux/library/l-async/index.html">ibm developerworks</a><br>
</li>
</ul>
</div>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/check-system-information-on-linux/" class="u-url">查看Linux系统的相关信息</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-06-20T10:30:50+08:00" itemprop="datePublished" title="2018-06-20 10:30">Jun 20 2018  (10:30)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/check-system-information-on-linux/#disqus_thread" data-disqus-identifier="cache/posts/check-system-information-on-linux.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/linux/" rel="tag">linux</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <p>
查看Linux系统相关信息有助于排查和解决软件和硬件的兼容性问题。系统信息包括硬件信息和软件信息，硬件信息主要有CPU信息、内存信息、PCI信息、USB信息、硬盘信息等等。软件信息主要有系统版本、分区使用状态等等。本文主要介绍了获取当前Linux系统信息的命令。<br></p>

<div id="outline-container-org1ee169f" class="outline-2">
<h2 id="org1ee169f">查看系统相关信息</h2>
<div class="outline-text-2" id="text-org1ee169f">
<p>
<code>uname</code> 指令提供了查询系统信息的功能，使用该命令能够快速获取操作系统信息概览。<br></p>

<p>
查看内核名称<br></p>
<div class="highlight"><pre><span></span>uname -s
</pre></div>

<p>
查看处理器类型<br></p>
<div class="highlight"><pre><span></span>uname -p
</pre></div>

<p>
查看硬件架构<br></p>
<div class="highlight"><pre><span></span>uname -i
</pre></div>

<p>
查看内核版本<br></p>
<div class="highlight"><pre><span></span>uname -r
</pre></div>

<p>
查看所有系统信息<br></p>
<div class="highlight"><pre><span></span>uname -a
</pre></div>

<p>
查看操作系统信息（发行版信息）<br></p>
<div class="highlight"><pre><span></span>cat /etc/os-release
cat /proc/version
lsb_release -a
hostnamectl
</pre></div>
</div>
</div>

<div id="outline-container-org6a4b7f4" class="outline-2">
<h2 id="org6a4b7f4">查看CPU相关信息</h2>
<div class="outline-text-2" id="text-org6a4b7f4">
<p>
<code>lscpu</code> 指令能够查看当前系统中CPU的详细信息，包括型号、主频、构架、大小端等信息。<br></p>
</div>
</div>

<div id="outline-container-org4123b8c" class="outline-2">
<h2 id="org4123b8c">查看硬盘相关信息</h2>
<div class="outline-text-2" id="text-org4123b8c">
<p>
<code>lsblk</code> 指令能够查看块设备（block device）的详细信息，块设备主要指系统中的存储设备如硬盘和闪存。<br></p>
</div>
</div>

<div id="outline-container-org4f098cd" class="outline-2">
<h2 id="org4f098cd">查看PCI设备的相关信息</h2>
<div class="outline-text-2" id="text-org4f098cd">
<p>
<code>lspci</code> 指令能够查看PCI设备的信息，PCI设备包括USB、显卡、串口、网卡等其他外围设备。<br></p>

<p>
输出树形结果<br></p>
<div class="highlight"><pre><span></span>lspci -t
</pre></div>

<p>
输出详细信息<br></p>
<div class="highlight"><pre><span></span>lspci -v
lspci -vv
</pre></div>
</div>
</div>

<div id="outline-container-orgb5bc29e" class="outline-2">
<h2 id="orgb5bc29e">查看USB设备的相关信息</h2>
<div class="outline-text-2" id="text-orgb5bc29e">
<p>
<code>lsusb</code> 指令能够查看USBS设备的信息。<br></p>
</div>
</div>

<div id="outline-container-orgd7e58ee" class="outline-2">
<h2 id="orgd7e58ee">查看文件系统相关信息</h2>
<div class="outline-text-2" id="text-orgd7e58ee">
<p>
<code>fdisk</code> 命令能够查看和操作linux系统的分区表。<br></p>

<p>
查看文件系统信息<br></p>
<div class="highlight"><pre><span></span>fdisk -l
</pre></div>

<p>
<code>df</code> 命令能够查看分区信息和硬盘使用信息<br></p>

<p>
使输出信息更容易理解<br></p>
<div class="highlight"><pre><span></span>df -h
</pre></div>
</div>
</div>

<div id="outline-container-org14bb3dc" class="outline-2">
<h2 id="org14bb3dc">参考资料</h2>
<div class="outline-text-2" id="text-org14bb3dc">
<ul class="org-ul">
<li>
<a href="https://www.tecmint.com/commands-to-collect-system-and-hardware-information-in-linux/">tecmint.com</a><br>
</li>
<li>
<a href="https://www.binarytides.com/linux-commands-hardware-info/">binarytides.com</a><br>
</li>
</ul>
</div>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/linux-command-examples-top/" class="u-url">Linux常用命令行指令 - top</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-06-14T11:26:53+08:00" itemprop="datePublished" title="2018-06-14 11:26">Jun 14 2018  (11:26)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/linux-command-examples-top/#disqus_thread" data-disqus-identifier="cache/posts/linux-command-examples-top.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/linux/" rel="tag">linux</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <p>
linux的top命令能够动态显示当前系统的运行状态。它能够显示操作系统的汇总信息和当前系统上的正在运行的进程列表。<br></p>

<div id="outline-container-org677ac1f" class="outline-2">
<h2 id="org677ac1f">
<span class="section-number-2">1</span> 统计信息说明</h2>
<div class="outline-text-2" id="text-1">
<p>
(可以通过配置文件修改通计信息区的显示格式，下文所描述的都是在默认配置下的显示内容)<br></p>
</div>
<div id="outline-container-org6448e70" class="outline-3">
<h3 id="org6448e70">
<span class="section-number-3">1.1</span> 第1行</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>当前系统时间<br>
</li>
<li>up 当前系统的启动时长<br>
</li>
<li>当前登录的用户数量<br>
</li>
<li>当前系统的平均负载（分别是1min,5min,10min的平均负载）<br>
</li>
</ul>
<p>
这一行信息也可以通过 <code>uptime</code> 和 <code>w</code> 指令获得<br></p>
</div>
</div>
<div id="outline-container-orgf49540b" class="outline-3">
<h3 id="orgf49540b">
<span class="section-number-3">1.2</span> 第2行</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>总进程数<br>
</li>
<li>正在运行的进程数<br>
</li>
<li>休眠的进程数<br>
</li>
<li>停止的进程数<br>
</li>
<li>僵尸进程数<br>
</li>
</ul>
</div>
</div>
<div id="outline-container-org25abe6c" class="outline-3">
<h3 id="org25abe6c">
<span class="section-number-3">1.3</span> 第3行</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>us 用户空间占用CPU百分比<br>
</li>
<li>sy 内核空间占用CPU百分比<br>
</li>
<li>ni 用户进程空间内改变过优先级的进程占用CPU百分比<br>
</li>
<li>id 空闲CPU百分比<br>
</li>
<li>wa 等待输入输出的CPU时间百分比<br>
</li>
<li>hi CPU服务于硬件中断所耗费的时间总额<br>
</li>
<li>si CPU服务软中断所耗费的时间总额<br>
</li>
<li>st Steal time 虚拟机被hypervisor偷去的CPU时间（如果当前处于一个hypervisor下的vm，实际上hypervisor也是要消耗一部分CPU处理时间的）<br>
</li>
</ul>
</div>
</div>

<div id="outline-container-org7ea0422" class="outline-3">
<h3 id="org7ea0422">
<span class="section-number-3">1.4</span> 第4行</h3>
<div class="outline-text-3" id="text-1-4">
<ul class="org-ul">
<li>物理内存总量<br>
</li>
<li>使用的物理内存总量<br>
</li>
<li>空闲内存总量<br>
</li>
<li>用作内核缓存的内存量<br>
</li>
</ul>
</div>
</div>

<div id="outline-container-org81adfd7" class="outline-3">
<h3 id="org81adfd7">
<span class="section-number-3">1.5</span> 第5行</h3>
<div class="outline-text-3" id="text-1-5">
<ul class="org-ul">
<li>交换区总量<br>
</li>
<li>使用的交换区总量<br>
</li>
<li>空间交换区总量<br>
</li>
<li>缓冲交换区总量<br>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgc725ef8" class="outline-2">
<h2 id="orgc725ef8">
<span class="section-number-2">2</span> 进程信息</h2>
<div class="outline-text-2" id="text-2">
<p>
在top命令中按f按可以查看显示的列信息，按对应字母来开启/关闭列，大写字母表示开启，小写字母表示关闭。带*号的是默认列。<br></p>

<p>
A: PID = (Process Id) 进程Id；<br>
E: USER = (User Name) 进程所有者的用户名；<br>
H: PR = (Priority) 优先级<br>
I: NI = (Nice value) nice值。负值表示高优先级，正值表示低优先级<br>
O: VIRT = (Virtual Image (kb)) 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES<br>
Q: RES = (Resident size (kb)) 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA<br>
T: SHR = (Shared Mem size (kb)) 共享内存大小，单位kb<br>
W: S = (Process Status) 进程状态。D=不可中断的睡眠状态,R=运行,S=睡眠,T=跟踪/停止,Z=僵尸进程<br>
K: %CPU = (CPU usage) 上次更新到现在的CPU时间占用百分比<br>
N: %MEM = (Memory usage (RES)) 进程使用的物理内存百分比<br>
M: TIME+ = (CPU Time, hundredths) 进程使用的CPU时间总计，单位1/100秒<br>
b: PPID = (Parent Process Pid) 父进程Id<br>
c: RUSER = (Real user name)<br>
d: UID = (User Id) 进程所有者的用户id<br>
f: GROUP = (Group Name) 进程所有者的组名<br>
g: TTY = (Controlling Tty) 启动进程的终端名。不是从终端启动的进程则显示为 ?<br>
j: P = (Last used cpu (SMP)) 最后使用的CPU，仅在多CPU环境下有意义<br>
p: SWAP = (Swapped size (kb)) 进程使用的虚拟内存中，被换出的大小，单位kb<br>
l: TIME = (CPU Time) 进程使用的CPU时间总计，单位秒<br>
r: CODE = (Code size (kb)) 可执行代码占用的物理内存大小，单位kb<br>
s: DATA = (Data+Stack size (kb)) 可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb<br>
u: nFLT = (Page Fault count) 页面错误次数<br>
v: nDRT = (Dirty Pages count) 最后一次写入到现在，被修改过的页面数<br>
y: WCHAN = (Sleeping in Function) 若该进程在睡眠，则显示睡眠中的系统函数名<br>
z: Flags = (Task Flags &lt;sched.h&gt;) 任务标志，参考 sched.h<br>
X: COMMAND = (Command name/line) 命令名/命令行<br></p>
</div>
</div>


<div id="outline-container-org9bf3445" class="outline-2">
<h2 id="org9bf3445">
<span class="section-number-2">3</span> 参考资料</h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li>
<a href="https://www.tecmint.com/12-top-command-examples-in-linux/">tecmint.com</a><br>
</li>
<li>
<a href="https://blog.csdn.net/sanshiqiduer/article/details/1933625">csdn blog</a><br>
</li>
</ul>
</div>
</div>
    </div>

  </article>
</div>



        
       <script>var disqus_shortname="samsonwang-me";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script>
</div>

      <div class="col-lg-3 col-md-3 col-sm-12 col-xs-12 sidebar">
       
<div class="sidebar-module sidebar-module-inset">
  <h4>About Me</h4>
  
        <div class="sidebar-aboutme">
        <p>Zeal for coding, C++ developer. Focus on linux server dev. I use EMACS, and I am learning python.</p>
        <p>View my code on <a href="https://github.com/samsonwang"> Github</a></p>
</div>
</div>

       
<div class="sidebar-module">
  <h4>Categories</h4>
  
        <ol class="list-unstyled sidebar-category">
<li>
<a href="/tags/category-cpp/">cpp</a>
        </li>
<li>
<a href="/tags/category-emacs/">emacs</a>
        </li>
<li>
<a href="/tags/category-linux/">linux</a>
        </li>
<li>
<a href="/tags/category-windows/">windows</a>
        </li>
</ol>
</div>

      </div>
<!--.sidebar-->
    </div>
<!--.row-->

    

        <nav class="postindexpager"><ul class="pager">
<li class="next">
                <a href="/index-1.html" rel="prev">Newer posts</a>
            </li>
            <li class="previous">
                <a href="/index-3.html" rel="next">Older posts</a>
            </li>
        </ul></nav><!--End of body content--><footer id="footer"><div class="text-center">
<p>Contents © 2017-2018 <a href="mailto:wangzhilv@gmail.com">Samson Wang</a>
 - Powered by <a href="https://getnikola.com/" rel="nofollow">Nikola</a>
 - Hosted on <a href="https://pages.github.com/" rel="nofollow">Github Pages</a>
 - 
<a rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/"><img alt="知识共享许可协议" style="padding-bottom:2px" src="https://i.creativecommons.org/l/by-nc/4.0/80x15.png"></a>
</p>
</div>

      
    </footer>
</div>
</div>

<div id="scroll-top" title="back to top">
  <div id="scroll-top-arrow"></div>
  <div id="scroll-top-stick"></div>
</div>


            <script src="/assets/js/jquery.min.js"></script><script src="/assets/js/jquery.colorbox-min.js"></script><script src="/assets/js/jquery.lazyload.min.js"></script><script src="/assets/js/popper.min.js"></script><script src="/assets/js/bootstrap.min.js"></script><script src="/assets/js/moment-with-locales.min.js"></script><script src="/assets/js/fancydates.js"></script><script src="/assets/js/cerulean.js"></script><!-- fancy dates --><script>
  moment.locale("en");
  fancydates(0, "YYYY-MM-DD HH:mm");
</script><!-- end fancy dates --><!-- Baidu Analytics --><script>
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?7ec47c52179b8ca4f9aee81282bd7b20";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>
</body>
</html>
