<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#" lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="Personal handnote on software development">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Hack Note (old posts, page 2) | Hack Note</title>
<link href="https://cdn.staticfile.org/twitter-bootstrap/4.1.1/css/bootstrap.min.css" rel="stylesheet">
<link href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link href="/blog/assets/css/code.css" rel="stylesheet" type="text/css">
<link href="/blog/assets/css/colorbox.css" rel="stylesheet" type="text/css">
<link href="/blog/assets/css/highlight.css" rel="stylesheet" type="text/css">
<link href="/blog/assets/css/cerulean.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="en" href="/blog/rss.xml">
<link rel="canonical" href="https://samsonwang.github.io/blog/index-2.html">
<link rel="icon" href="/blog/favicon.ico" sizes="64x64">
<link rel="prev" href="/blog/index-1.html" type="text/html">
<link rel="next" href="/blog/index-3.html" type="text/html">
<!--[if lt IE 9]><script src="https://html5shim.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
</head>
<body class="preload">
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->
<nav id="top-nav" class="navbar navbar-expand-md fixed-top mb-4 navbar-dark bg-dark"><div class="container">   <!-- This keeps the margins nice -->
    <a class="navbar-brand" href="/blog/">

      <span id="blog-title">Hack Note</span>
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div class="collapse navbar-collapse" id="bs-navbar">
      <ul class="navbar-nav ml-auto">
<li class="nav-item">
<a href="/blog/archive/" class="nav-link">Archives</a>
                </li>
<li class="nav-item">
<a href="/blog/tags/" class="nav-link">Tags</a>
                </li>
<li class="nav-item">
<a href="/blog/rss.xml" class="nav-link">RSS Feed</a>

        
      </li>
</ul>
<ul class="navbar-nav navbar-right"></ul>
</div>
<!-- /.navbar-collapse -->
  </div>
<!-- /.container -->
</nav><!-- End of Menubar --><div class="container" id="content" role="main">
  <div class="body-content">
    <!--Body content-->
    <div class="row">

      <div class="col-lg-9 col-md-9 col-sm-12 col-xs-12">
        
        


  



  


<div class="postindex">


  <article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/blog/posts/router-modem-and-switch/" class="u-url">路由、调制解调器和交换机</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-09-27T18:34:54+08:00" itemprop="datePublished" title="2018-09-27 18:34">Sep 27 2018</time>
</div>

        

        
    <div class="comment blur-1">
      
        
    <a href="/blog/posts/router-modem-and-switch/#disqus_thread" data-disqus-identifier="cache/archives/2018/router-modem-and-switch.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/blog/tags/moderm/" rel="tag">moderm</a></li>
        <li><a class="tag p-category" href="/blog/tags/network/" rel="tag">network</a></li>
        <li><a class="tag p-category" href="/blog/tags/router/" rel="tag">router</a></li>
        <li><a class="tag p-category" href="/blog/tags/switch/" rel="tag">switch</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <div>
<p>
路由、调制解调器和交换机，这三个是我们经常使用的网络设备。它们在网络中的作用是什么？它们工作在网络模型的哪一层？本篇文章将带你了解他们的原理与和区别。<br></p>

<p class="more"><a href="/blog/posts/router-modem-and-switch/">Read more…</a></p>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/blog/posts/internet-protocol/" class="u-url">IP协议（RFC791）</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-09-24T20:16:15+08:00" itemprop="datePublished" title="2018-09-24 20:16">Sep 24 2018</time>
</div>

        

        
    <div class="comment blur-1">
      
        
    <a href="/blog/posts/internet-protocol/#disqus_thread" data-disqus-identifier="cache/archives/2018/internet-protocol.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/blog/tags/ip/" rel="tag">ip</a></li>
        <li><a class="tag p-category" href="/blog/tags/network/" rel="tag">network</a></li>
        <li><a class="tag p-category" href="/blog/tags/protocol/" rel="tag">protocol</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <div>
<p>
本文是IPv4协议的摘要和笔记，IPv4协议格式由RFC791规定，RFC791协议的原文可以在 <a href="https://tools.ietf.org/html/rfc791">这里</a> 找到。<br></p>

<p class="more"><a href="/blog/posts/internet-protocol/">Read more…</a></p>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/blog/posts/network-protocol-suite/" class="u-url">网络通信协议</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-09-21T17:51:57+08:00" itemprop="datePublished" title="2018-09-21 17:51">Sep 21 2018</time>
</div>

        

        
    <div class="comment blur-1">
      
        
    <a href="/blog/posts/network-protocol-suite/#disqus_thread" data-disqus-identifier="cache/archives/2018/network-protocol-suite.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/blog/tags/ip/" rel="tag">ip</a></li>
        <li><a class="tag p-category" href="/blog/tags/network/" rel="tag">network</a></li>
        <li><a class="tag p-category" href="/blog/tags/osi/" rel="tag">osi</a></li>
        <li><a class="tag p-category" href="/blog/tags/tcp/" rel="tag">tcp</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <div>
<p>
本文总结了两种常见的网络模型，OSI模型和TCP/IP模型，并比较了二者之间的区别。<br></p>

<p class="more"><a href="/blog/posts/network-protocol-suite/">Read more…</a></p>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/blog/posts/breadth-first-search/" class="u-url">广度优先搜索</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-09-19T09:13:57+08:00" itemprop="datePublished" title="2018-09-19 09:13">Sep 19 2018</time>
</div>

        

        
    <div class="comment blur-1">
      
        
    <a href="/blog/posts/breadth-first-search/#disqus_thread" data-disqus-identifier="cache/archives/2018/breadth-first-search.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/blog/tags/algorithm/" rel="tag">algorithm</a></li>
        <li><a class="tag p-category" href="/blog/tags/bfs/" rel="tag">bfs</a></li>
        <li><a class="tag p-category" href="/blog/tags/dfs/" rel="tag">dfs</a></li>
        <li><a class="tag p-category" href="/blog/tags/graph/" rel="tag">graph</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">引言</h2>
<div class="outline-text-2" id="text-1">
<p>
在求解 <a href="/blog/posts/algorithm-weekly-letter-combinations-of-a-phone-number/" class="post-url">leetcode 17</a> 时，我遇到了BFS（广度优先搜索）这个概念。在深入了解后发现，BFS是图（graph）的一个知识点，我对这一知识点进行展开学习，并将找到的资料汇总起来。本文主要整理了图和广度优先搜索的相关知识点。<br></p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">图的存储方式</h2>
<div class="outline-text-2" id="text-2">
<p>
研究图就需要使用计算机语言对其进行描述。图的存储结构除了要存储图中各个顶点的本身的信息外，同时还要存储顶点与顶点之间的所有关系（边的信息）。因此，图的结构比较复杂，很难以数据元素在存储区中的物理位置来表示元素之间的关系，但也正是由于其任意的特性，故物理表示方法很多。常用的图的存储结构有邻接矩阵、邻接表、十字链表和邻接多重表。<br></p>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">相邻矩阵（adjacency martix）</h3>
<div class="outline-text-3" id="text-2-1">
<p>
对于一个具有 <code>n</code> 个顶点的图，可以使用 <code>n*n</code> 的矩阵（二维数组）来表示它们间的邻接关系。下图中，矩阵 <code>A(i，j)=1</code> 表示图中存在一条边 <code>(Vi，Vj)</code> ，而 <code>A(i，j)=0</code> 表示图中不存在边 <code>(Vi，Vj)</code> 。实际编程时，当图为不带权图时，可以在二维数组中存放bool值， <code>A(i，j)=true</code> 表示存在边 <code>(Vi，Vj)</code> ， <code>A(i，j)=false</code> 表示不存在边 <code>(Vi，Vj)</code> ；当图带权值时，则可以直接在二维数组中存放权值， <code>A(i，j)=null</code> 表示不存在边 <code>(Vi，Vj)</code> 。<br></p>

<p>
<img src="/blog/assets/images/spinner.svg" data-src="/blog/images/post-breadth-first-search-1.jpg" alt="图的相邻矩阵表示方法"><br></p>

<p>
左图所示的是无向图的邻接矩阵表示法，可以观察到，矩阵延对角线对称，即 <code>A(i，j)=A(j，i)</code> 。无向图邻接矩阵的第 <code>i</code> 行或第 <code>i</code> 列非零元素的个数其实就是第 <code>i</code> 个顶点的度。这表示无向图邻接矩阵存在一定的数据冗余。<br></p>

<p>
右图所示的是有向图邻接矩阵表示法，矩阵并不延对角线对称， <code>A(i，j)=1</code> 表示顶点 <code>Vi</code> 邻接到顶点 <code>Vj</code> ； <code>A(j，i)=1</code> 则表示顶点 <code>Vi</code> 邻接自顶点 <code>Vj</code> 。两者并不象无向图邻接矩阵那样表示相同的意思。有向图邻接矩阵的第 <code>i</code> 行非零元素的个数其实就是第 <code>i</code> 个顶点的出度，而第 <code>i</code> 列非零元素的个数是第 <code>i</code> 个顶点的入度，即第 <code>i</code> 个顶点的度是第 <code>i</code> 行和第 <code>i</code> 列非零元素个数之和。<br></p>

<p>
由于存在 <code>n</code> 个顶点的图需要 <code>n^2</code> 个数组元素进行存储，当图为稀疏图时，使用邻接矩阵存储方法将出现大量零元素，照成极大地空间浪费，这时应该使用邻接表表示法存储图中的数据。<br></p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">邻接表（adjacency list）</h3>
<div class="outline-text-3" id="text-2-2">
<p>
邻接表（adjacency list）是一种常用的表示图的数据结构。邻接表是许多链表的集合，每个链表描述了一个顶点（ <code>vectex</code> ）的相邻元素（ <code>Neighbor</code> ）。更形象地讲，邻接表是一个二维容器，第一维描述某个点，第二维描述这个点所对应的边集们。<br>
图的邻接矩阵存储方法跟树的孩子链表示法相类似，是一种顺序分配和链式分配相结合的存储结构。邻接表由表头结点和表结点两部分组成，其中图中每个顶点均对应一个存储在数组中的表头结点。如这个表头结点所对应的顶点存在相邻顶点，则把相邻顶点依次存放于表头结点所指向的单向链表中。如下图所示，表结点存放的是邻接顶点在数组中的索引。对于无向图来说，使用邻接表进行存储也会出现数据冗余，表头结点 <code>A</code> 所指链表中存在一个指向 <code>C</code> 的表结点的同时，表头结点 <code>C</code> 所指链表也会存在一个指向 <code>A</code> 的表结点。<br><img src="/blog/assets/images/spinner.svg" data-src="/blog/images/post-breadth-first-search-2.jpg" alt="图的相邻表表示方法"><br></p>

<p>
有向图的邻接表有出边表和入边表（又称逆邻接表）之分。出边表的表结点存放的是从表头结点出发的有向边所指的尾顶点；入边表的表结点存放的则是指向表头结点的某个头顶点。如下图所示，图(b)和(c)分别为有向图(a)的出边表和入边表。<br><img src="/blog/assets/images/spinner.svg" data-src="/blog/images/post-breadth-first-search-3.jpg" alt="有向图的相邻表表示方法"><br></p>

<p>
以上所讨论的邻接表所表示的都是不带权的图，如果要表示带权图，可以在表结点中增加一个存放权的字段，其效果如下图所示。<br><img src="/blog/assets/images/spinner.svg" data-src="/blog/images/post-breadth-first-search-4.jpg" alt="加权图的相邻表表示方法"><br>
观察上图可以发现，当删除存储表头结点的数组中的某一元素，有可能使部分表头结点索引号的改变，从而导致大面积修改表结点的情况发生。可以在表结点中直接存放指向表头结点的指针以解决这个问题（在链表中存放类实例即是存放指针，但必须要保证表头结点是类而不是结构体）。在实际创建邻接表时，甚至可以使用链表代替数组存放表头结点或使用顺序表存代替链表存放表结点。<br></p>

<p>
本节所有的图片摘自 <a href="https://www.cnblogs.com/abatei/archive/2008/06/06/1215114.html">cnblogs.com - abatei</a><br></p>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">图的遍历</h2>
<div class="outline-text-2" id="text-3">
<p>
和树的遍历类似，在此，我们希望从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫做图的遍历(traversing graph)。如果只访问图的顶点而不关注边的信息，那么图的遍历十分简单，使用一个 <code>foreach</code> 语句遍历存放顶点信息的数组即可。但如果为了实现特定算法，就需要根据边的信息按照一定顺序进行遍历。图的遍历算法是求解图的连通性问题、拓扑排序和求关键路径等算法的基础。<br></p>

<p>
图的遍历要比树的遍历复杂得多，由于图的任一顶点都可能和其余顶点相邻接，故在访问了某顶点之后，可能顺着某条边又访问到了已访问过的顶点，因此，在图的遍历过程中，必须记下每个访问过的顶点，以免同一个顶点被访问多次。为此给顶点附设访问标志 <code>visited</code> ，其初值为 <code>false</code> ，一旦某个顶点被访问，则其 <code>visited</code> 标志置为 <code>true</code> 。<br></p>

<p>
图的遍历方法有两种：一种是深度优先搜索遍历（depth first search 简称DFS），另一种是广度优先搜索遍历（breadth first search 简称BFS）。<br></p>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">广度优先搜索（breadth first search）</h2>
<div class="outline-text-2" id="text-4">
<p>
图的广度优先搜索遍历算法是一个分层遍历的过程，和二叉树的广度优先搜索遍历类同。它从图的某一顶点 <code>Vi</code> 出发，访问此顶点后，依次访问 <code>Vi</code> 的各个未曾访问过的邻接点，然后分别从这些邻接点出发，直至图中所有已有已被访问的顶点的邻接点都被访问到。对于无向连通图，若顶点 <code>Vi</code> 为初始访问的顶点，则广度优先搜索遍历顺序如下所示。<br><img src="/blog/assets/images/spinner.svg" data-src="/blog/images/post-breadth-first-search-5.jpg" alt="图的广度优先搜索遍历"><br></p>

<p>
广度优先搜索的伪代码如下：<br></p>
<pre class="example">
BFS (G, s)  // Where G is the graph and s is the source node
  let Q be queue.
  Q.enqueue( s )  // Inserting s in queue until all its neighbour vertices are marked.

  mark s as visited.

  while ( Q is not empty )
    // Removing that vertex from queue, whose neighbour will be visited now
    v  =  Q.dequeue( )

    // processing all the neighbours of v
    for all neighbours w of v in Graph G
      if w is not visited
        Q.enqueue( w )  // Stores w in Q to further visit its neighbour
        mark w as visited.
</pre>

<p>
<b>时间复杂度</b><br>
BFS的时间复杂度为 <code>O(V+E)</code> ，其中 <code>V</code> 是节点的数量， <code>E</code> 是边的数量。<br></p>

<p>
<b>BFS的应用场景</b><br></p>
<ul class="org-ul">
<li>最短路径问题<br>
</li>
<li>P2P网络，网络广播<br>
</li>
<li>GPS导航系统<br>
</li>
<li>搜索引擎的网络爬虫<br>
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">参考资料</h2>
<div class="outline-text-2" id="text-5">
<ul class="org-ul">
<li>
<a href="https://www.hackerearth.com/zh/practice/algorithms/graphs/breadth-first-search/tutorial/">hackerearth.com - breath first search tutorial</a><br>
</li>
<li>
<a href="http://www.cnblogs.com/abatei/archive/2010/02/25/1215114.html">cnblogs - 图的遍历</a><br>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Adjacency_matrix">wikipedia - adjacency matrix</a><br>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Adjacency_list">wikipedia - adjacency list</a><br>
</li>
<li>
<a href="https://baike.baidu.com/item/%25E9%2582%25BB%25E6%258E%25A5%25E8%25A1%25A8">百度百科 - 邻接表</a><br>
</li>
<li>
<a href="https://www.geeksforgeeks.org/applications-of-breadth-first-traversal/">geeksforgeeks - application of BFS</a><br>
</li>
</ul>
</div>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/blog/posts/using-regexp-in-linux-shell/" class="u-url">在shell中使用正则表达式</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-09-16T09:47:01+08:00" itemprop="datePublished" title="2018-09-16 09:47">Sep 16 2018</time>
</div>

        

        
    <div class="comment blur-1">
      
        
    <a href="/blog/posts/using-regexp-in-linux-shell/#disqus_thread" data-disqus-identifier="cache/archives/2018/using-regexp-in-linux-shell.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/blog/tags/egrep/" rel="tag">egrep</a></li>
        <li><a class="tag p-category" href="/blog/tags/grep/" rel="tag">grep</a></li>
        <li><a class="tag p-category" href="/blog/tags/liunx/" rel="tag">liunx</a></li>
        <li><a class="tag p-category" href="/blog/tags/shell/" rel="tag">shell</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">引言</h2>
<div class="outline-text-2" id="text-1">
<p>
本篇文章主要是针对shell中的 <code>grep</code> 和 <code>egrep</code> 的讲解，对于正则表达式的规则本身并没有太多的内容。在阅读本篇文章之前，读者应该对正则表达式有个大致的了解。<br></p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">
<code>grep</code> 命令</h2>
<div class="outline-text-2" id="text-2">
<p>
<code>grep</code> 命令是linux终端中最常用的命令之一，它的全称是“global regular expression print”，从字面上理解， <code>grep</code> 可以用来进行正则表达式匹配。<br></p>

<p>
<b>常用选项</b><br>
使用一些选项命令能够更加方便地进行匹配<br><code>-i</code> 忽略大小写<br><code>-v</code> 进行逆向匹配<br><code>-n</code> 打印行号<br><code>--color=auto</code> 彩色输出结果<br></p>

<p>
<b>支持的表达式</b><br>
正则表达式有很多规则， <code>grep</code> 支持的有如下：<br>
在每一行的开始<br></p>
<div class="highlight"><pre><span></span>grep <span class="s2">"^GUN"</span> GPL-3
</pre></div>

<p>
在每一行的结尾<br></p>
<div class="highlight"><pre><span></span>grep <span class="s2">"and</span>$<span class="s2">"</span> GPL-3
</pre></div>

<p>
匹配任意字符<br></p>
<div class="highlight"><pre><span></span>grep <span class="s2">"..cept"</span> GPL-3
</pre></div>

<p>
在指定的字符中进行匹配<br></p>
<div class="highlight"><pre><span></span>grep <span class="s2">"t[wo]o"</span> GPL-3
</pre></div>

<p>
在指定的字符中进行逆向匹配<br></p>
<div class="highlight"><pre><span></span>grep <span class="s2">"[^c]ode"</span> GPL-3
</pre></div>

<p>
使用范围来指定字符<br></p>
<div class="highlight"><pre><span></span>grep <span class="s2">"^[A-Z]"</span> GPL-3
</pre></div>

<p>
限定出现的次数为0次或0次以上<br></p>
<div class="highlight"><pre><span></span>grep <span class="s2">"([A-Za-z ]*)"</span> GPL-3
</pre></div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">
<code>egrep</code> 命令</h2>
<div class="outline-text-2" id="text-3">
<p>
<code>egrep</code> 的含义为“extended grep”，相对于 <code>grep</code> 有更多的正则表达式特性。同样，可以在使用 <code>grep</code> 时增加 <code>-E</code> 参数获得相同的效果。<br></p>

<p>
<b>表达式分组</b><br>
使用括号能够将表达式进行分组，下面的任何一个都能够实现这个效果<br></p>
<div class="highlight"><pre><span></span>grep <span class="s2">"\(grouping\)"</span> file.txt
grep -E <span class="s2">"(grouping)"</span> file.txt
egrep <span class="s2">"(grouping)"</span> file.txt
</pre></div>

<p>
表达式进行中多选一<br></p>
<div class="highlight"><pre><span></span>egrep <span class="s2">"(GPL|General Public License)"</span> GPL-3
</pre></div>

<p>
匹配的重复次数为0次或0次以上，与 <code>*</code> 限定符类似，但是 <code>?</code> 可以作用于一组字符<br></p>
<div class="highlight"><pre><span></span>egrep <span class="s2">"(copy)?right"</span> GPL-3
</pre></div>

<p>
指定匹配的重复次数<br></p>
<div class="highlight"><pre><span></span>egrep <span class="s2">"[AEIOUaeiou]{3}"</span> GPL-3
</pre></div>
</div>
</div>


<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">参考资料</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li>
<a href="https://www.digitalocean.com/community/tutorials/using-grep-regular-expressions-to-search-for-text-patterns-in-linux">digital ocean - grep tutorial</a><br>
</li>
<li>
<a href="http://man7.org/linux/man-pages/man1/grep.1.html">linux man page</a><br>
</li>
</ul>
</div>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/blog/posts/compares-between-thread-and-process/" class="u-url">线程与进程的比较</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-09-14T09:51:15+08:00" itemprop="datePublished" title="2018-09-14 09:51">Sep 14 2018</time>
</div>

        
    <div class="updated blur-1">
      <time class="published dt-published" datetime="2019-01-11T10:45:15+08:00" itemprop="datePublished" title="2019-01-11 10:45">Jan 11 2019</time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/blog/posts/compares-between-thread-and-process/#disqus_thread" data-disqus-identifier="cache/archives/2018/compares-between-thread-and-process.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/blog/tags/computer-science/" rel="tag">computer science</a></li>
        <li><a class="tag p-category" href="/blog/tags/process/" rel="tag">process</a></li>
        <li><a class="tag p-category" href="/blog/tags/thread/" rel="tag">thread</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">进程与线程之间有什么区别</h2>
<div class="outline-text-2" id="text-1">
<p>
进程（process）是指在系统中正在运行的一个应用程序，是系统资源分配的基本单位，在内存中有其完备的数据空间和代码空间，拥有完整的虚拟空间地址。一个进程所拥有的数据和变量只属于它自己。<br></p>

<p>
线程（thread）是进程内相对独立的可执行单元，所以也被称为轻量进程（lightweight processes）。线程是操作系统进行任务调度的基本单元，它与父进程的其它线程共享该进程所拥有的全部代码空间和全局变量，但拥有独立的堆栈（即局部变量对于线程来说是私有的）。<br></p>

<p>
进程和线程都具有就绪、阻塞和运行三种基本状态。<br></p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">联系</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>一个进程至少拥有一个线程(主线程)，也可以拥有多个线程<br>
</li>
<li>一个线程必须有一个父进程，多个进程可以并发执行<br>
</li>
<li>一个线程可以创建和撤销另一个线程<br>
</li>
<li>同一个进程中的多个线程之间可以并发执行<br>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">区别</h3>
<div class="outline-text-3" id="text-1-2">
<p>
系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销<br>
资源管理：进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。<br></p>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">通信方式</h3>
<div class="outline-text-3" id="text-1-3">
<p>
进程间通信主要包括管道、系统IPC(包括消息队列，信号量，共享存储)、SOCKET，具体说明参考linux进程间通信方式。进程间通信其实是指分属于不同进程的线程之间的通讯，所以进程间的通信方法同样适用于线程间的通信。但对于同一进程的不同线程来说，使用全局变量进行通信效率会更高。<br></p>
</div>
</div>
</div>


<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">什么情况下适合使用线程</h2>
<div class="outline-text-2" id="text-2">
<p>
线程相对于进程的优势：<br></p>
<ul class="org-ul">
<li>线程间通信（数据交互）比进程间通信更加简便快捷。<br>
</li>
<li>线程之间的上下文切换速度要比进程间的快，也就是说，对于操作系统而言，停止一个线程并启动另一个线程的速度比进程之间相似操作更快。<br>
</li>
<li>创建一个线程的速度比创建一个进程的速度快。<br>
</li>
</ul>
<p>
下面的一些情景更适合使用线程来完成：<br></p>
<ul class="org-ul">
<li>进行耗时较长的处理：当一个windows界面程序正在计算时，它就不能处理其他消息（message）了，界面就不能及时更新。<br>
</li>
<li>进行后台处理：有些任务并不是时间紧迫的，但是需要定期执行。<br>
</li>
<li>进行 <code>I/O</code> 处理： <code>I/O</code> 操作或网络操作一般都会有一定的延迟，线程能保证程序中的其他部分不会受到延迟的影响。<br>
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">什么情况下适合使用进程</h2>
<div class="outline-text-2" id="text-3">
<p>
进程相对于线程的优势：<br></p>
<ul class="org-ul">
<li>多线程系单进程的软件只能运行在一台机器上，而多进程的软件可以运行在多台机器上。这在一定程度上限制软件的可拓展性，单台机器的性能总是有限的。<br>
</li>
<li>多进程模型的鲁棒性更好，有更好的容错性。运行在同一进程下的多个线程会相互影响，如果其中的一个线程出了问题，可能会波及整个进程。<br>
</li>
<li>有些功能模块并不是线程安全的，这时就只能使用多进程模型了。<br>
</li>
</ul>
<p>
以chrome浏览器为例，它使用了多进程模型。每一个标签页都是一个进程，这样能够将渲染引擎中的bug隔离在该进程内，从而使整个程序免受影响。多进程模型将JavaScript隔离在每个进程中，这样就能防止其因占用过多的CPU或内存，使整个软件失去响应。另一方面，多进程模型的系统开销也是比较大的，这点能够从chrome的高额内存使用中看出来。不过chrome的优化策略可以让较低内存的情况下有更好内存使用效率。当一个标签页处于非激活状态，其对应的内存可以在需要时被交换进硬盘中，这样用户当前操作的页面就能够保持响应状态。如果使用的是多线程模型，区分活跃内存和非活跃内存就变得十分困难，导致内存使用效率的下降。<br></p>
</div>
</div>


<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">参考资料</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li>
<a href="https://www.backblaze.com/blog/whats-the-diff-programs-processes-and-threads/">backblaze.com - difference between process and thread</a><br>
</li>
<li>
<a href="https://docs.microsoft.com/zh-cn/windows/desktop/ProcThread/about-processes-and-threads">msdn - about processes and threads</a><br>
</li>
<li>
<a href="https://blog.csdn.net/xiexievv/article/details/7294189">csdn - blog</a><br>
</li>
<li>
<a href="https://stackoverflow.com/questions/617787/why-should-i-use-a-thread-vs-using-a-process">stackoverflow - why should I use thread vs process</a><br>
</li>
<li>
<a href="https://blog.chromium.org/2008/09/multi-process-architecture.html">chromium blog - multi process architecture</a><br>
</li>
</ul>
<p>
（全文完）<br></p>
</div>
</div>
    </div>

  </article>
</div>



        
       <script>var disqus_shortname="samsonwang-blog";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script>
</div>

      <div class="col-lg-3 col-md-3 col-sm-12 col-xs-12 sidebar">
       
<div class="sidebar-module sidebar-module-inset">
  <h4>About Me</h4>
  
        <div class="sidebar-aboutme">
        <p>Zeal for coding, C++ developer. Focused on Linux server develop. I use EMACS on a daily basis.</p>
        </div>
</div>

       
<div class="sidebar-module sidebar-module-inset">
  <h4>Categories</h4>
  
        <ol class="list-unstyled sidebar-category">
<li>
<a href="/blog/tags/category-cpp/">cpp</a>
        </li>
<li>
<a href="/blog/tags/category-emacs/">emacs</a>
        </li>
<li>
<a href="/blog/tags/category-linux/">linux</a>
        </li>
<li>
<a href="/blog/tags/category-windows/">windows</a>
        </li>
</ol>
</div>

      </div>
<!--.sidebar-->
    </div>
<!--.row-->

    

    <nav class="postindexpager"><ul class="pager">
<li class="left">
             <a href="/blog/index-3.html" rel="next">Older posts</a>
          </li>
          <li class="right">
            <a href="/blog/index-1.html" rel="prev">Newer posts</a>
          </li>
      </ul></nav><!--End of body content--><footer id="footer"><div class="text-center">
<p>Contents © 2017-2020 <a href="mailto:wangzhilv@gmail.com">Samson Wang</a>
 - Powered by <a href="https://getnikola.com/" rel="nofollow">Nikola</a>
 - Hosted on <a href="https://pages.github.com/" rel="nofollow">Github Pages</a>
 - 
<a rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/"><img alt="知识共享许可协议" style="padding-bottom:2px" src="https://i.creativecommons.org/l/by-nc/4.0/80x15.png"></a>
</p>
</div>

      
    </footer>
</div>
</div>

<div id="scroll-top" title="back to top">
  <div id="scroll-top-arrow"></div>
  <div id="scroll-top-stick"></div>
</div>


            <script src="https://cdn.staticfile.org/jquery/3.3.1/jquery.min.js"></script><script src="https://cdn.staticfile.org/jquery.colorbox/1.6.4/jquery.colorbox-min.js"></script><script src="https://cdn.staticfile.org/jquery_lazyload/1.9.7/jquery.lazyload.min.js"></script><script src="https://cdn.staticfile.org/popper.js/1.14.3/umd/popper.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.1.1/js/bootstrap.min.js"></script><script src="/blog/assets/js/moment-with-locales.min.js"></script><script src="/blog/assets/js/fancydates.js"></script><script src="/blog/assets/js/cerulean.js"></script><!-- fancy dates --><script>
  moment.locale("en");
  fancydates(0, "YYYY-MM-DD HH:mm");
</script><!-- end fancy dates --><script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?1dcffb5494ab56e69005c957d7320ad1";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>
</body>
</html>
