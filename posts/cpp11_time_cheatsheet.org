#+BEGIN_COMMENT
.. title: C++11常用的时间接口
.. slug: cpp11_time_cheatsheet
.. date: 2019-01-04 16:05:56 UTC+08:00
.. tags: cpp11, cpp11, time, chrono
.. category: cpp
.. link:
.. description:
.. type: text
.. status: draft
#+END_COMMENT
#+OPTIONS: num:t

#+TITLE: C++11常用的时间接口

与时间相关的操作在开发中是十分常见的，本文总结了常用时间接口，并给出了示例代码。

** 获取当前系统的时间

*** 获取 =time_t= 格式的时间
    使用 =std::time_t time(std::time_t* arg)= 获取当前时间。


*** 获取 =struct tm= 格式的时间
    使用 =std::tm* localetime(const std::time_t* time)= 将 =time_t= 转化为 =struct tm= 。
    在多线程情况下，推荐使用线程安全的版本 =std::tm* localetime_s(const std::time_t* time, struct tm* result);= ，这个版本使用了用户指定的变量地址用来存储结果。


*** 获取 =struct timeval= 格式的时间
    在linux系统中，使用 =int gettimeofday(struct tm* tp, void* tzp)= 获取当前时间。

    在windows系统中，没有 =gettimeofday= 的官方实现，可以使用以下代码获取 =struct timeval= 。

#+BEGIN_SRC cpp
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <stdint.h> // portable: uint64_t   MSVC: __int64

// MSVC defines this in winsock2.h!?
typedef struct timeval {
    long tv_sec;
    long tv_usec;
} timeval;

int gettimeofday(struct timeval * tp, struct timezone * tzp) {
    // Note: some broken versions only have 8 trailing zero's, the correct epoch has 9 trailing zero's
    // This magic number is the number of 100 nanosecond intervals since January 1, 1601 (UTC)
    // until 00:00:00 January 1, 1970
    static const uint64_t EPOCH = ((uint64_t) 116444736000000000ULL);

    SYSTEMTIME  system_time;
    FILETIME    file_time;
    uint64_t    time;

    GetSystemTime( &system_time );
    SystemTimeToFileTime( &system_time, &file_time );
    time =  ((uint64_t)file_time.dwLowDateTime )      ;
    time += ((uint64_t)file_time.dwHighDateTime) << 32;

    tp->tv_sec  = (long) ((time - EPOCH) / 10000000L);
    tp->tv_usec = (long) (system_time.wMilliseconds * 1000);
    return 0;
}
#+END_SRC



** 时间形式的转换
*** =std::time_t= 与 =std::tm= 转换


*** =std::time_t= 与 =std::string= 转换
    =std::put_time= 在gcc4.9的c++11中没有实现。


*** =std::tm= 与 =std::string= 转换


** 计算时间间隔
   推荐使用 =std::chrono::steady_clock= 进行时间间隔的计算，因为 =steady_clock= 是单调的，不会受到校时的影响。不推荐使用 =std::chrono::system_clock= 进行时间间隔的计算，由于它会受到系统时间更改的影响，如果在计时间隔中修改了系统时间，则本次的计算结果会收到影响。

   如果编译器不支持C++11，可以考虑以系统启动时间作为基准进行时间间隔的计算。




** 参考资料
- https://stackoverflow.com/questions/10905892/equivalent-of-gettimeday-for-windows
