#+BEGIN_COMMENT
.. title: 客户端使用非阻塞socket进行connect的流程
.. slug: non-blocking-socket-connect-tips
.. date: 2018-08-31 17:04:19 UTC+08:00
.. tags: draft, network, socket, nio, non-blocking
.. category: network
.. link:
.. description:
.. type: text
#+END_COMMENT

#+TITLE: 客户端使用非阻塞socket进行connect的流程

** 问题
使用非阻塞（ =non-blocking= ） socket尝试与服务端建立连接（ =connect= ）时，由于是io非阻塞的，所以 =connect= 函数会立即返回，那么如何判断client与server连接成功了呢？

** 解答
客户端建立连接的示例代码如下：
#+BEGIN_SRC c
int res = connect(fd, ...);
if (res < 0 && errno != EINPROGRESS) {
    // case1. error, fail somehow, close socket
    return;
}

if (res == 0) {
    // case2. connection has succeeded immediately
} else {
    // case3. connection attempt is in progress
}
#+END_SRC
由于是非阻塞模式，所以 =connect= 之后会直接返回，一般情况会进case 1，表示程序正在连接。


#+BEGIN_SRC c
int result;
socklen_t result_len = sizeof(result);
if (getsockopt(fd, SOL_SOCKET, SO_ERROR, &result, &result_len) < 0) {
    // case4. error, fail somehow, close socket
    return;
}

if (result != 0) {
    // case5. connection failed; error code is in 'result'
    return;
}

// case6. socket is ready for read()/write()
#+END_SRC

** 参考资料
 - [[https://stackoverflow.com/questions/10187347/async-connect-and-disconnect-with-epoll-linux/10194883#10194883][stackoverflow.com]]
