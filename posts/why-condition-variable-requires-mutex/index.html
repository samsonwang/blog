<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns#" lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta http-equiv="x-ua-compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>为什么条件变量需要与互斥锁配合使用 | Hack Note</title>
<meta name="theme-color" content="#04519b">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" href="/rss.xml">
<link href="https://cdn.jsdelivr.net/gh/samsonwang/blog@master/assets/css/minima.min.css" rel="stylesheet" type="text/css">
<link rel="canonical" href="https://blog.wangzhl.com/posts/why-condition-variable-requires-mutex/">
<link rel="icon" href="/favicon.ico" sizes="64x64">
<link rel="prev" href="/posts/max-number-of-threads-per-process/" title="单个进程内最多可以有多少个线程" type="text/html">
<link rel="next" href="/posts/fopen-api-compare/" title="文件操作函数接口的比较" type="text/html">
<meta name="author" content="Samson Wang">
<meta property="og:site_name" content="Hack Note">
<meta property="og:title" content="为什么条件变量需要与互斥锁配合使用">
<meta property="og:url" content="https://blog.wangzhl.com/posts/why-condition-variable-requires-mutex/">
<meta property="og:description" content="条件变量（condition variable）是常用的线程同步技术，通常用于让线程阻塞并等待某个条件满足。它需要与互斥锁搭配使用，但是你有想过为什么需要搭配一个互斥锁呢？





1 条件变量的标准范式


条件变量常用于生产者消费者模式。以下是条件变量的伪代码范例，适用于单消费者模型。

thread:
    initialise.
    lock mutex.
    while th">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2019-12-12T22:38:41+08:00">
<meta property="article:tag" content="boost">
<meta property="article:tag" content="condition variable">
<meta property="article:tag" content="cpp">
<meta property="article:tag" content="cpp11">
<meta property="article:tag" content="mutex">
<meta property="article:tag" content="thread">
</head>
<body>
  <header class="site-header nav-custom"><div class="wrapper">
      <a class="site-title" rel="author" href="/">Hack Note</a>
      <nav class="site-nav"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger">
          <span class="menu-icon">
            <svg viewbox="0 0 18 15" width="18px" height="15px"><use href="/assets/svg/theme.svg#menu-icon"></use></svg></span>
        </label>
        <div class="trigger">
          
            <a class="page-link" href="/">Home</a>
            <a class="page-link" href="/archive/">Archives</a>
            <a class="page-link" href="/tags/">Tags</a>
            <a class="page-link" href="/rss.xml">RSS Feed</a>

        </div>
      </nav>
</div>
  </header><main class="page-content" aria-label="Content"><div class="wrapper">

    

    
<article class="post h-entry" itemscope="" itemtype="http://schema.org/BlogPosting"><header class="post-header"><h1 class="post-title p-name" itemprop="name headline">为什么条件变量需要与互斥锁配合使用</h1>

    <p class="post-meta">
      
    <time class="dt-published" datetime="2019-12-12T22:38:41+08:00" itemprop="datePublished">Dec 12, 2019</time></p>
  </header><div class="post-content e-content" itemprop="articleBody text">
    <p>
条件变量（condition variable）是常用的线程同步技术，通常用于让线程阻塞并等待某个条件满足。它需要与互斥锁搭配使用，但是你有想过为什么需要搭配一个互斥锁呢？<br></p>

<!-- TEASER_END -->

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">
<span class="section-number-2">1</span> 条件变量的标准范式</h2>
<div class="outline-text-2" id="text-1">
<p>
条件变量常用于生产者消费者模式。以下是条件变量的伪代码范例，适用于单消费者模型。<br></p>
<div class="highlight"><pre><span></span>thread:
    initialise.
    lock mutex.
    while thread not told to stop working:
	wait on condvar using mutex.
	if work is available to be done:
	    do the work.
    unlock mutex.
    clean up.
    exit thread.
</pre></div>
<p>
在上述伪代码中，互斥量是用来保护条件变量的，这就是在条件变量调用等待 <code>wait</code> 之前，需要互斥量上锁的原因。等待 <code>wait</code> 操作会释放互斥锁，这样其他线程就有机会操作条件变量了。当条件变量被唤醒后，会自动对互斥量加锁。<br></p>

<p>
条件变量省去了轮询是否达到某个条件的操作，可以等待其他线程在条件满足时通知等待的线程，伪代码如下。<br></p>
<div class="highlight"><pre><span></span>lock mutex.
flag work as available.
signal condition variable.
unlock mutex.
</pre></div>

<p>
对于多消费者模型，在上述伪代码中，当其中一个消费者满足工作条件时，互斥量仍是锁定状态，这样其他线程在这时就会阻塞。所以，需要在消费者线程开始工作之前解锁互斥量以允许其他消费者线程可以正常运行。示例代码如下：<br></p>
<div class="highlight"><pre><span></span>thread:
    initialise.
    lock mutex.
    while thread not told to stop working:
	wait on condvar using mutex.
	if work is available to be done:
	    copy work to thread local storage.
	    unlock mutex.
	    do the work.
	    lock mutex.
    unlock mutex.
    clean up.
    exit thread.
</pre></div>
</div>
</div>


<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">
<span class="section-number-2">2</span> 条件变量的虚假唤醒（spurious wakeup）</h2>
<div class="outline-text-2" id="text-2">
<p>
虚假唤醒是指在等待 <code>wait</code> 条件变量时，会在没有被其他线程通知的情况下提前结束等待。虚假唤醒是偶发的，所以就需要在条件变量等待结束时判断是否怎的满足了执行条件。<br></p>
<blockquote>
<p>
This means that when you wait on a condition variable, the wait may (occasionally) return when no thread specifically broadcast or signaled that condition variable. Spurious wakeups may sound strange, but on some multiprocessor systems, making condition wakeup completely predictable might substantially slow all condition variable operations. The race conditions that cause spurious wakeups should be considered rare.<br></p>
</blockquote>
</div>
</div>


<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">
<span class="section-number-2">3</span> C++11 中的条件变量</h2>
<div class="outline-text-2" id="text-3">
<p>
以下代码是C++11标准下的线程和条件变量示例代码，可以看到条件变量搭配了互斥量一起使用，用于保护条件变量和两个标志变量（ <code>ready</code> 和 <code>processed</code> ）。需要注意的是，在标准库条件变量的 <code>notify</code> 操作之前是不需要互斥量的锁定状态的，这点与pthread接口有些不同。<br></p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;condition_variable&gt;</span><span class="cp"></span>

<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">cv</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">data</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">ready</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">processed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">worker_thread</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Wait until main() sends data</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
    <span class="n">cv</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lk</span><span class="p">,</span> <span class="p">[]{</span><span class="k">return</span> <span class="n">ready</span><span class="p">;});</span>

    <span class="c1">// after the wait, we own the lock.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Worker thread is processing data</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">data</span> <span class="o">+=</span> <span class="s">" after processing"</span><span class="p">;</span>

    <span class="c1">// Send data back to main()</span>
    <span class="n">processed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Worker thread signals data processing completed</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="c1">// Manual unlocking is done before notifying, to avoid waking up</span>
    <span class="c1">// the waiting thread only to block again (see notify_one for details)</span>
    <span class="n">lk</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
    <span class="n">cv</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">worker</span><span class="p">(</span><span class="n">worker_thread</span><span class="p">);</span>

    <span class="n">data</span> <span class="o">=</span> <span class="s">"Example data"</span><span class="p">;</span>
    <span class="c1">// send data to the worker thread</span>
    <span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
	<span class="n">ready</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"main() signals data ready for processing</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cv</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>

    <span class="c1">// wait for the worker</span>
    <span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
	<span class="n">cv</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lk</span><span class="p">,</span> <span class="p">[]{</span><span class="k">return</span> <span class="n">processed</span><span class="p">;});</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Back in main(), data = "</span> <span class="o">&lt;&lt;</span> <span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

    <span class="n">worker</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">
<span class="section-number-2">4</span> boost 中的条件变量</h2>
<div class="outline-text-2" id="text-4">
<p>
以下代码是boost库的条件变量示例代码。<br></p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;boost/thread.hpp&gt;</span><span class="cp"></span>

<span class="n">boost</span><span class="o">::</span><span class="n">mutex</span> <span class="n">io_mutex</span><span class="p">;</span>
<span class="n">boost</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">condition</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">worker_is_done</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">workFunction</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Waiting a little..."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">posix_time</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>

    <span class="p">{</span>
	<span class="n">boost</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">guard</span><span class="p">(</span><span class="n">io_mutex</span><span class="p">);</span>
	<span class="n">worker_is_done</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Notifying condition..."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">condition</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Waiting a little more..."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">posix_time</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">boost</span><span class="o">::</span><span class="kr">thread</span> <span class="n">workThread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">workFunction</span><span class="p">);</span>

    <span class="n">boost</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">io_mutex</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">worker_is_done</span><span class="p">)</span>
	 <span class="n">condition</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Condition notified."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">workThread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Thread finished."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">
<span class="section-number-2">5</span> 参考资料</h2>
<div class="outline-text-2" id="text-5">
<ul class="org-ul">
<li>
<a href="https://en.cppreference.com/w/cpp/thread/condition_variable">cppreference.com - condition variable</a><br>
</li>
<li>
<a href="https://stackoverflow.com/questions/2763714/why-do-pthreads-condition-variable-functions-require-a-mutex">stackoverflow.com - why pthread condition variable require a mutex</a><br>
</li>
<li>
<a href="https://stackoverflow.com/questions/46088363/why-does-stdcondition-variablewait-need-mutex">stackoverflow.com - why std condition variable need mutex</a><br>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Spurious_wakeup">wikipedia.org - spurious wakeup</a><br>
</li>
</ul>
</div>
</div>
  </div>
  
  <ul class="tags-list vertical-center">
<li>
      <a class="badge" href="/tags/boost/" rel="tag">boost</a>
    </li>
    <li>
      <a class="badge" href="/tags/condition-variable/" rel="tag">condition variable</a>
    </li>
    <li>
      <a class="badge" href="/tags/cpp/" rel="tag">cpp</a>
    </li>
    <li>
      <a class="badge" href="/tags/cpp11/" rel="tag">cpp11</a>
    </li>
    <li>
      <a class="badge" href="/tags/mutex/" rel="tag">mutex</a>
    </li>
    <li>
      <a class="badge" href="/tags/thread/" rel="tag">thread</a>
    </li>
  </ul></article><ul class="post-pager hidden-print">
<li class="previous">
      <a href="/posts/max-number-of-threads-per-process/" rel="prev">Previous post
        <br><span>单个进程内最多可以有多少个线程</span>
      </a>
    </li>
    <li class="next">
      <a href="/posts/fopen-api-compare/" rel="next">Next post
        <br><span>文件操作函数接口的比较</span>
      </a>
    </li>
  </ul>
<section class="comments hidden-print"><div id="disqus_thread"></div>
        <script>
        var disqus_shortname ="samsonwang-blog",
            disqus_url="https://blog.wangzhl.com/posts/why-condition-variable-requires-mutex/",
        disqus_title="\u4e3a\u4ec0\u4e48\u6761\u4ef6\u53d8\u91cf\u9700\u8981\u4e0e\u4e92\u65a5\u9501\u914d\u5408\u4f7f\u7528",
        disqus_identifier="_cache/archives/2019/why-condition-variable-requires-mutex.html",
        disqus_config = function () {
            this.language = "en";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.async = true;
            dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript>
    <a href="https://disqus.com" class="dsq-brlink" rel="nofollow">Comments powered by <span class="logo-disqus">Disqus</span></a>


  </section><script>var disqus_shortname="samsonwang-blog";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script>
</div>
  </main><footer class="site-footer h-card"><div class="wrapper">
      <div class="footer-col-wrapper">

        <div class="footer-col">
          <p class="site-desc">Personal handnote on software development</p>
        </div>

        <div class="footer-col">
          <div class="p-name">Samson Wang</div>
          <div class="u-email"><a href="mailto:wangzhilv@gmail.com">wangzhilv@gmail.com</a></div>
          <div class="copyright">Contents © 2020, all rights reservered.</div>
          <div class="social-links">
            <ul class="social-media-list">
<li><a rel="me" href="/rss.xml">
                <svg class="svg-icon grey"><use href="/assets/svg/social-icons.svg#rss"></use></svg></a></li>
              <li><a rel="nofollow" href="https://github.com/samsonwang">
                <svg class="svg-icon grey"><use href="/assets/svg/social-icons.svg#github"></use></svg></a></li>
              <li><a rel="nofollow" href="https://twitter.com/samsonwangcn">
                <svg class="svg-icon grey"><use href="/assets/svg/social-icons.svg#twitter"></use></svg></a></li>
              <li><a rel="nofollow" href="https://facebook.com/samsonwangcn">
                 <svg class="svg-icon grey"><use href="/assets/svg/social-icons.svg#facebook"></use></svg></a></li>
            </ul>
</div>

        </div>

      </div>

    </div>

  </footer><div id="scroll-top" title="back to top">
  <div id="scroll-top-arrow"></div>
  <div id="scroll-top-stick"></div>
</div>


      <script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@15.1.1/dist/lazyload.min.js"></script><script src="https://cdn.jsdelivr.net/gh/samsonwang/blog@master/assets/js/minima.min.js"></script><!-- baidu tongji --><script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?1dcffb5494ab56e69005c957d7320ad1";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script><!-- Google Analytics - Global site tag (gtag.js) --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-108507797-1"></script><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-108507797-1');
</script>
</body>
</html>
