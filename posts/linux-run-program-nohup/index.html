<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns#" lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta http-equiv="x-ua-compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>[转]Linux 技巧：让进程在后台可靠运行的几种方法 | Hack Note</title>
<meta name="theme-color" content="#04519b">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" href="/rss.xml">
<link href="/assets/css/minima.min.css" rel="stylesheet" type="text/css">
<link rel="canonical" href="https://blog.wangzhl.com/posts/linux-run-program-nohup/">
<link rel="icon" href="/favicon.ico" sizes="64x64">
<link rel="prev" href="/posts/algorithm-weekly-search-in-rotated-sorted-array/" title="每周算法：搜索有序的回环数组" type="text/html">
<link rel="next" href="/posts/algorithm-weekly-find-first-and-last-position-of-element-in-sorted-array/" title="每周算法：从有序数组中找到目标出现的第一次和最后一次的位置" type="text/html">
<meta name="author" content="Samson Wang">
<meta property="og:site_name" content="Hack Note">
<meta property="og:title" content="[转]Linux 技巧：让进程在后台可靠运行的几种方法">
<meta property="og:url" content="https://blog.wangzhl.com/posts/linux-run-program-nohup/">
<meta property="og:description" content="我们经常会碰到这样的问题，用 telnet/ssh 登录了远程的 Linux 服务器，运行了一些耗时较长的任务， 结果却由于网络的不稳定导致任务中途失败。如何让命令提交后不受本地关闭终端窗口/网络断开连接的干扰呢？下面举了一些例子， 您可以针对不同的场景选择不同的方式来处理这个问题。





nohup / setsid / &amp;


场景：
如果只是临时有一个命令需要长时间运行，什么方法能最简便">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2018-10-28T18:19:42+08:00">
<meta property="article:tag" content="disown">
<meta property="article:tag" content="linux">
<meta property="article:tag" content="nohup">
<meta property="article:tag" content="screen">
<meta property="article:tag" content="setsid">
</head>
<body>
  <header class="site-header nav-custom"><div class="wrapper">
      <a class="site-title" rel="author" href="/">Hack Note</a>
      <nav class="site-nav"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger">
          <span class="menu-icon">
            <svg viewbox="0 0 18 15" width="18px" height="15px"><use href="/assets/svg/theme.svg#menu-icon"></use></svg></span>
        </label>
        <div class="trigger">
          
            <a class="page-link" href="/">Home</a>
            <a class="page-link" href="/archive/">Archive</a>
            <a class="page-link" href="/tags/">Tags</a>
            <a class="page-link" href="/about/">About</a>

        </div>
      </nav>
</div>
  </header><main class="page-content" aria-label="Content"><div class="wrapper">

    

    
<article class="post h-entry" itemscope="" itemtype="http://schema.org/BlogPosting"><header class="post-header"><h1 class="post-title p-name" itemprop="name headline">[转]Linux 技巧：让进程在后台可靠运行的几种方法</h1>

    <p class="post-meta">
      
    <time class="dt-published" datetime="2018-10-28T18:19:42+08:00" itemprop="datePublished">Oct 28, 2018</time><span class="dt-updated"> / updated <time datetime="2019-10-30T18:19:42+08:00" itemprop="dateUpdated">Oct 30, 2019</time></span>

      

    </p>
  </header><div class="post-content e-content" itemprop="articleBody text">
    <p>
我们经常会碰到这样的问题，用 telnet/ssh 登录了远程的 Linux 服务器，运行了一些耗时较长的任务， 结果却由于网络的不稳定导致任务中途失败。如何让命令提交后不受本地关闭终端窗口/网络断开连接的干扰呢？下面举了一些例子， 您可以针对不同的场景选择不同的方式来处理这个问题。<br></p>

<!-- TEASER_END -->

<div id="outline-container-orgc6de57b" class="outline-2">
<h2 id="orgc6de57b">nohup / setsid / &amp;</h2>
<div class="outline-text-2" id="text-orgc6de57b">
<p>
<b>场景：</b><br>
如果只是临时有一个命令需要长时间运行，什么方法能最简便的保证它在后台稳定运行呢？<br></p>

<p>
<b>解决方法：</b><br>
我们知道，当用户注销（logout）或者网络断开时，终端会收到 HUP（hangup）信号从而关闭其所有子进程。因此，我们的解决办法就有两种途径：要么让进程忽略 HUP 信号，要么让进程运行在新的会话里从而成为不属于此终端的子进程。<br></p>

<blockquote>
<p>
hangup 名称的来由<br>
在 Unix 的早期版本中，每个终端都会通过 modem 和系统通讯。当用户 logout 时，modem 就会挂断（hang up）电话。 同理，当 modem 断开连接时，就会给终端发送 hangup 信号来通知其关闭所有子进程。<br></p>
</blockquote>
</div>

<div id="outline-container-org4acf19c" class="outline-3">
<h3 id="org4acf19c">1. nohup</h3>
<div class="outline-text-3" id="text-org4acf19c">
<p>
nohup 无疑是我们首先想到的办法。顾名思义，nohup 的用途就是让提交的命令忽略 hangup 信号。让我们先来看一下 nohup 的帮助信息：<br></p>

<pre class="example">
NOHUP(1)                        User Commands                        NOHUP(1)

NAME
       nohup - run a command immune to hangups, with output to a non-tty

SYNOPSIS
       nohup COMMAND [ARG]...
       nohup OPTION

DESCRIPTION
       Run COMMAND, ignoring hangup signals.

       --help display this help and exit

       --version
              output version information and exit
</pre>
<p>
可见，nohup 的使用是十分方便的，只需在要处理的命令前加上 nohup 即可，标准输出和标准错误缺省会被重定向到 nohup.out 文件中。一般我们可在结尾加上"&amp;"来将命令同时放入后台运行，也可用"&gt;filename 2&gt;&amp;1"来更改缺省的重定向文件名。<br></p>

<p>
nohup 示例:<br></p>
<pre class="example">
[root@pvcent107 ~]# nohup ping www.ibm.com &amp;
[1] 3059
nohup: appending output to `nohup.out'
[root@pvcent107 ~]# ps -ef |grep 3059
root      3059   984  0 21:06 pts/3    00:00:00 ping www.ibm.com
root      3067   984  0 21:06 pts/3    00:00:00 grep 3059
[root@pvcent107 ~]#
</pre>
</div>
</div>

<div id="outline-container-orga11b39c" class="outline-3">
<h3 id="orga11b39c">2. setsid</h3>
<div class="outline-text-3" id="text-orga11b39c">
<p>
nohup 无疑能通过忽略 HUP 信号来使我们的进程避免中途被中断，但如果我们换个角度思考，如果我们的进程不属于接受 HUP 信号的终端的子进程，那么自然也就不会受到 HUP 信号的影响了。setsid 就能帮助我们做到这一点。让我们先来看一下 setsid 的帮助信息：<br></p>

<pre class="example">
SETSID(8)                 Linux Programmer’s Manual                 SETSID(8)

NAME
       setsid - run a program in a new session

SYNOPSIS
       setsid program [ arg ... ]

DESCRIPTION
       setsid runs a program in a new session.
</pre>

<p>
可见 setsid 的使用也是非常方便的，也只需在要处理的命令前加上 setsid 即可。<br></p>

<p>
setsid 示例<br></p>
<pre class="example">
[root@pvcent107 ~]# setsid ping www.ibm.com
[root@pvcent107 ~]# ps -ef |grep www.ibm.com
root     31094     1  0 07:28 ?        00:00:00 ping www.ibm.com
root     31102 29217  0 07:29 pts/4    00:00:00 grep www.ibm.com
[root@pvcent107 ~]#
</pre>

<p>
值得注意的是，上例中我们的进程 ID(PID)为31094，而它的父 ID（PPID）为1（即为 init 进程 ID），并不是当前终端的进程 ID。请将此例与nohup 例中的父 ID 做比较。<br></p>
</div>
</div>

<div id="outline-container-org1241d3c" class="outline-3">
<h3 id="org1241d3c">3. &amp;</h3>
<div class="outline-text-3" id="text-org1241d3c">
<p>
这里还有一个关于 subshell 的小技巧。我们知道，将一个或多个命名包含在“()”中就能让这些命令在子 shell 中运行中，从而扩展出很多有趣的功能，我们现在要讨论的就是其中之一。<br></p>

<p>
当我们将"&amp;"也放入“()”内之后，我们就会发现所提交的作业并不在作业列表中，也就是说，是无法通过jobs来查看的。让我们来看看为什么这样就能躲过 HUP 信号的影响吧。<br></p>

<p>
subshell 示例<br></p>
<pre class="example">
[root@pvcent107 ~]# (ping www.ibm.com &amp;)
[root@pvcent107 ~]# ps -ef |grep www.ibm.com
root     16270     1  0 14:13 pts/4    00:00:00 ping www.ibm.com
root     16278 15362  0 14:13 pts/4    00:00:00 grep www.ibm.com
[root@pvcent107 ~]#
</pre>

<p>
从上例中可以看出，新提交的进程的父 ID（PPID）为1（init 进程的 PID），并不是当前终端的进程 ID。因此并不属于当前终端的子进程，从而也就不会受到当前终端的 HUP 信号的影响了。<br></p>
</div>
</div>
</div>

<div id="outline-container-org892e0f8" class="outline-2">
<h2 id="org892e0f8">disown</h2>
<div class="outline-text-2" id="text-org892e0f8">
<p>
<b>场景：</b><br>
我们已经知道，如果事先在命令前加上 nohup 或者 setsid 就可以避免 HUP 信号的影响。但是如果我们未加任何处理就已经提交了命令，该如何补救才能让它避免 HUP 信号的影响呢？<br></p>

<p>
<b>解决方法：</b><br>
这时想加 nohup 或者 setsid 已经为时已晚，只能通过作业调度和 disown 来解决这个问题了。让我们来看一下 disown 的帮助信息：<br></p>

<pre class="example">
disown [-ar] [-h] [jobspec ...]
    Without options, each jobspec is  removed  from  the  table  of
    active  jobs.   If  the -h option is given, each jobspec is not
    removed from the table, but is marked so  that  SIGHUP  is  not
    sent  to the job if the shell receives a SIGHUP.  If no jobspec
    is present, and neither the -a nor the -r option  is  supplied,
    the  current  job  is  used.  If no jobspec is supplied, the -a
    option means to remove or mark all jobs; the -r option  without
    a  jobspec  argument  restricts operation to running jobs.  The
    return value is 0 unless a jobspec does  not  specify  a  valid
    job.
</pre>

<p>
可以看出，我们可以用如下方式来达成我们的目的。<br></p>
<ul class="org-ul">
<li>用disown -h jobspec来使某个作业忽略HUP信号。<br>
</li>
<li>用disown -ah 来使所有的作业都忽略HUP信号。<br>
</li>
<li>用disown -rh 来使正在运行的作业忽略HUP信号。<br>
</li>
</ul>
<p>
需要注意的是，当使用过 disown 之后，会将把目标作业从作业列表中移除，我们将不能再使用jobs来查看它，但是依然能够用ps -ef查找到它。<br></p>

<p>
但是还有一个问题，这种方法的操作对象是作业，如果我们在运行命令时在结尾加了"&amp;"来使它成为一个作业并在后台运行，那么就万事大吉了，我们可以通过jobs命令来得到所有作业的列表。但是如果并没有把当前命令作为作业来运行，如何才能得到它的作业号呢？答案就是用 CTRL-z（按住Ctrl键的同时按住z键）了！<br></p>

<p>
CTRL-z 的用途就是将当前进程挂起（Suspend），然后我们就可以用jobs命令来查询它的作业号，再用bg jobspec来将它放入后台并继续运行。需要注意的是，如果挂起会影响当前进程的运行结果，请慎用此方法。<br></p>

<blockquote>
<p>
灵活运用 CTRL-z<br>
在我们的日常工作中，我们可以用 CTRL-z 来将当前进程挂起到后台暂停运行，执行一些别的操作，然后再用 fg 来将挂起的进程重新放回前台（也可用 bg 来将挂起的进程放在后台）继续运行。这样我们就可以在一个终端内灵活切换运行多个任务，这一点在调试代码时尤为有用。因为将代码编辑器挂起到后台再重新放回时，光标定位仍然停留在上次挂起时的位置，避免了重新定位的麻烦。<br></p>
</blockquote>

<p>
<b>disown 示例1</b> （如果提交命令时已经用“&amp;”将命令放入后台运行，则可以直接使用“disown”）<br></p>

<pre class="example">
[root@pvcent107 build]# cp -r testLargeFile largeFile &amp;
[1] 4825
[root@pvcent107 build]# jobs
[1]+  Running                 cp -i -r testLargeFile largeFile &amp;
[root@pvcent107 build]# disown -h %1
[root@pvcent107 build]# ps -ef |grep largeFile
root      4825   968  1 09:46 pts/4    00:00:00 cp -i -r testLargeFile largeFile
root      4853   968  0 09:46 pts/4    00:00:00 grep largeFile
[root@pvcent107 build]# logout
</pre>

<p>
<b>disown 示例2</b> （如果提交命令时未使用“&amp;”将命令放入后台运行，可使用 CTRL-z 和“bg”将其放入后台，再使用“disown”）<br></p>

<pre class="example">
[root@pvcent107 build]# cp -r testLargeFile largeFile2

[1]+  Stopped                 cp -i -r testLargeFile largeFile2
[root@pvcent107 build]# bg %1
[1]+ cp -i -r testLargeFile largeFile2 &amp;
[root@pvcent107 build]# jobs
[1]+  Running                 cp -i -r testLargeFile largeFile2 &amp;
[root@pvcent107 build]# disown -h %1
[root@pvcent107 build]# ps -ef |grep largeFile2
root      5790  5577  1 10:04 pts/3    00:00:00 cp -i -r testLargeFile largeFile2
root      5824  5577  0 10:05 pts/3    00:00:00 grep largeFile2
[root@pvcent107 build]#
</pre>
</div>
</div>

<div id="outline-container-org0ea6fee" class="outline-2">
<h2 id="org0ea6fee">screen</h2>
<div class="outline-text-2" id="text-org0ea6fee">
<p>
<b>场景：</b><br>
我们已经知道了如何让进程免受 HUP 信号的影响，但是如果有大量这种命令需要在稳定的后台里运行，如何避免对每条命令都做这样的操作呢？<br></p>

<p>
<b>解决方法：</b><br>
此时最方便的方法就是 screen 了。简单的说，screen 提供了 ANSI/VT100 的终端模拟器，使它能够在一个真实终端下运行多个全屏的伪终端。screen 的参数很多，具有很强大的功能，我们在此仅介绍其常用功能以及简要分析一下为什么使用 screen 能够避免 HUP 信号的影响。我们先看一下 screen 的帮助信息：<br></p>

<pre class="example">
SCREEN(1)                                                           SCREEN(1)

NAME
       screen - screen manager with VT100/ANSI terminal emulation

SYNOPSIS
       screen [ -options ] [ cmd [ args ] ]
       screen -r [[pid.]tty[.host]]
       screen -r sessionowner/[[pid.]tty[.host]]

DESCRIPTION
       Screen  is  a  full-screen  window manager that multiplexes a physical
       terminal between several  processes  (typically  interactive  shells).
       Each  virtual  terminal provides the functions of a DEC VT100 terminal
       and, in addition, several control functions from the  ISO  6429  (ECMA
       48,  ANSI  X3.64)  and ISO 2022 standards (e.g. insert/delete line and
       support for multiple character sets).  There is a  scrollback  history
       buffer  for  each virtual terminal and a copy-and-paste mechanism that
       allows moving text regions between windows.
</pre>

<p>
使用 screen 很方便，有以下几个常用选项：<br></p>
<ul class="org-ul">
<li>用screen -dmS session name来建立一个处于断开模式下的会话（并指定其会话名）。<br>
</li>
<li>用screen -list 来列出所有会话。<br>
</li>
<li>用screen -r session name来重新连接指定会话。<br>
</li>
<li>用快捷键CTRL-a d 来暂时断开当前会话。<br>
</li>
</ul>
<p>
screen 示例<br></p>
<pre class="example">
[root@pvcent107 ~]# screen -dmS Urumchi
[root@pvcent107 ~]# screen -list
There is a screen on:
        12842.Urumchi   (Detached)
1 Socket in /tmp/screens/S-root.

[root@pvcent107 ~]# screen -r Urumchi
</pre>

<p>
当我们用“-r”连接到 screen 会话后，我们就可以在这个伪终端里面为所欲为，再也不用担心 HUP 信号会对我们的进程造成影响，也不用给每个命令前都加上“nohup”或者“setsid”了。这是为什么呢？让我来看一下下面两个例子吧。<br></p>

<ol class="org-ol">
<li>未使用 screen 时新进程的进程树<br>
</li>
</ol>
<pre class="example">
[root@pvcent107 ~]# ping www.google.com &amp;
[1] 9499
[root@pvcent107 ~]# pstree -H 9499
init─┬─Xvnc
     ├─acpid
     ├─atd
     ├─2*[sendmail]
     ├─sshd─┬─sshd───bash───pstree
     │       └─sshd───bash───ping
</pre>


<p>
我们可以看出，未使用 screen 时我们所处的 bash 是 sshd 的子进程，当 ssh 断开连接时，HUP 信号自然会影响到它下面的所有子进程（包括我们新建立的 ping 进程）。<br></p>

<ol class="org-ol">
<li>使用了 screen 后新进程的进程树<br>
</li>
</ol>
<pre class="example">
[root@pvcent107 ~]# screen -r Urumchi
[root@pvcent107 ~]# ping www.ibm.com &amp;
[1] 9488
[root@pvcent107 ~]# pstree -H 9488
init─┬─Xvnc
     ├─acpid
     ├─atd
     ├─screen───bash───ping
     ├─2*[sendmail]
</pre>

<p>
而使用了 screen 后就不同了，此时 bash 是 screen 的子进程，而 screen 是 init（PID为1）的子进程。那么当 ssh 断开连接时，HUP 信号自然不会影响到 screen 下面的子进程了。<br></p>
</div>
</div>

<div id="outline-container-org42305b9" class="outline-2">
<h2 id="org42305b9">总结</h2>
<div class="outline-text-2" id="text-org42305b9">
<p>
现在几种方法已经介绍完毕，我们可以根据不同的场景来选择不同的方案。nohup/setsid 无疑是临时需要时最方便的方法，disown 能帮助我们来事后补救当前已经在运行了的作业，而 screen 则是在大批量操作时不二的选择了。<br></p>
</div>
</div>
  </div>
  
  <ul class="tags-list vertical-center">
<li>
      <a class="badge" href="/tags/disown/" rel="tag">disown</a>
    </li>
    <li>
      <a class="badge" href="/tags/linux/" rel="tag">linux</a>
    </li>
    <li>
      <a class="badge" href="/tags/nohup/" rel="tag">nohup</a>
    </li>
    <li>
      <a class="badge" href="/tags/screen/" rel="tag">screen</a>
    </li>
    <li>
      <a class="badge" href="/tags/setsid/" rel="tag">setsid</a>
    </li>
  </ul></article><ul class="post-pager hidden-print">
<li class="previous">
      <a href="/posts/algorithm-weekly-search-in-rotated-sorted-array/" rel="prev">Previous post
        <br><span>每周算法：搜索有序的回环数组</span>
      </a>
    </li>
    <li class="next">
      <a href="/posts/algorithm-weekly-find-first-and-last-position-of-element-in-sorted-array/" rel="next">Next post
        <br><span>每周算法：从有序数组中找到目标出现的第一次和最后一次的位置</span>
      </a>
    </li>
  </ul>
<section class="comments hidden-print"><div id="disqus_thread"></div>
        <script>
        var disqus_shortname ="samsonwang-blog",
            disqus_url="https://blog.wangzhl.com/posts/linux-run-program-nohup/",
        disqus_title="[\u8f6c]Linux \u6280\u5de7\uff1a\u8ba9\u8fdb\u7a0b\u5728\u540e\u53f0\u53ef\u9760\u8fd0\u884c\u7684\u51e0\u79cd\u65b9\u6cd5",
        disqus_identifier="_cache/archives/2018/linux-run-program-nohup.html",
        disqus_config = function () {
            this.language = "en";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.async = true;
            dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript>
    <a href="https://disqus.com" class="dsq-brlink" rel="nofollow">Comments powered by <span class="logo-disqus">Disqus</span></a>


  </section><script>var disqus_shortname="samsonwang-blog";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script>
</div>
  </main><footer class="site-footer h-card"><div class="wrapper">
      <div class="footer-col-wrapper">

        <div class="footer-col">
          <p class="site-desc">Personal handnote on software development</p>
        </div>

        <div class="footer-col">
          <div class="p-name">Samson Wang</div>
          <div class="copyright">Copyright 2021, all rights reserved.</div>
          <div class="social-links">
            <ul class="social-media-list">
<li><a rel="me" href="/rss.xml">
                <svg class="svg-icon grey"><use href="/assets/svg/social-icons.svg#rss"></use></svg></a></li>
              <li><a rel="nofollow" href="https://github.com/samsonwang">
                <svg class="svg-icon grey"><use href="/assets/svg/social-icons.svg#github"></use></svg></a></li>
              <li><a rel="nofollow" href="https://twitter.com/samsonwangcn">
                <svg class="svg-icon grey"><use href="/assets/svg/social-icons.svg#twitter"></use></svg></a></li>
              <li><a rel="nofollow" href="https://facebook.com/samsonwangcn">
                 <svg class="svg-icon grey"><use href="/assets/svg/social-icons.svg#facebook"></use></svg></a></li>
            </ul>
</div>

        </div>

      </div>

    </div>

  </footer><div id="scroll-top" title="back to top">
  <div id="scroll-top-arrow"></div>
  <div id="scroll-top-stick"></div>
</div>


      <script src="/assets/js/lazyload.min.js"></script><script src="/assets/js/minima.min.js"></script><!-- google adsense --><script data-ad-client="ca-pub-6303134192857919" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- Google Analytics - Global site tag (gtag.js) --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-108507797-1"></script><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-108507797-1');
</script><!-- baidu tongji --><script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?1dcffb5494ab56e69005c957d7320ad1";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>
</body>
</html>
