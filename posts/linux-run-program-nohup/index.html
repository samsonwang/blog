<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#" lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>[转]Linux 技巧：让进程在后台可靠运行的几种方法 | Hack Note</title>
<link href="/assets/css/bootstrap.min.css" rel="stylesheet" type="text/css">
<link href="/assets/css/font-awesome.min.css" rel="stylesheet" type="text/css">
<link href="/assets/css/code.css" rel="stylesheet" type="text/css">
<link href="/assets/css/colorbox.css" rel="stylesheet" type="text/css">
<link href="/assets/css/highlight.css" rel="stylesheet" type="text/css">
<link href="/assets/css/cerulean.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="en" href="/rss.xml">
<link rel="canonical" href="https://samsonwang.me/posts/linux-run-program-nohup/">
<link rel="icon" href="/favicon.ico" sizes="64x64">
<!--[if lt IE 9]><script src="/assets/js/html5.js"></script><![endif]--><meta name="author" content="Samson Wang">
<link rel="prev" href="/posts/algorithm-weekly-search-in-rotated-sorted-array/" title="每周算法：搜索有序的回环数组" type="text/html">
<link rel="next" href="/posts/algorithm-weekly-find-first-and-last-position-of-element-in-sorted-array/" title="每周算法：从有序数组中找到目标出现的第一次和最后一次的位置" type="text/html">
</head>
<body class="preload">
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->
<nav id="top-nav" class="navbar navbar-expand-md fixed-top mb-4 navbar-dark bg-dark"><div class="container">   <!-- This keeps the margins nice -->
    <a class="navbar-brand" href="/">

      <span id="blog-title">Hack Note</span>
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div class="collapse navbar-collapse" id="bs-navbar">
      <ul class="navbar-nav ml-auto">
<li class="nav-item">
<a href="/archive/" class="nav-link">Archives</a>
                </li>
<li class="nav-item">
<a href="/tags/" class="nav-link">Tags</a>
                </li>
<li class="nav-item">
<a href="/rss.xml" class="nav-link">RSS Feed</a>

        
      </li>
</ul>
<ul class="navbar-nav navbar-right"></ul>
</div>
<!-- /.navbar-collapse -->
  </div>
<!-- /.container -->
</nav><!-- End of Menubar --><div class="container" id="content" role="main">
  <div class="body-content">
    <!--Body content-->
    <div class="row">

      <div class="col-lg-9 col-md-9 col-sm-12 col-xs-12">
        
        
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name">[转]Linux 技巧：让进程在后台可靠运行的几种方法</h1>

    <div class="metadata">
      

      
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-10-28T18:19:42+08:00" itemprop="datePublished" title="2018-10-28 18:19">Oct 28 2018  (18:19)</time>
</div>

      

      
    <div class="source blur-1">
      <a href="/posts/linux-run-program-nohup/index.org" class="sourcelink">Source</a>
    </div>

      
     <div class="link blur-1">
       <a href="https://www.ibm.com/developerworks/cn/linux/l-cn-nohup/">Original site</a>
     </div>

      
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/linux/" rel="tag">linux</a></li>
        <li><a class="tag p-category" href="/tags/nohup/" rel="tag">nohup</a></li>
        <li><a class="tag p-category" href="/tags/sreen/" rel="tag">sreen</a></li>
    </ul>
</div>

      

    </div>
  </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>
我们经常会碰到这样的问题，用 telnet/ssh 登录了远程的 Linux 服务器，运行了一些耗时较长的任务， 结果却由于网络的不稳定导致任务中途失败。如何让命令提交后不受本地关闭终端窗口/网络断开连接的干扰呢？下面举了一些例子， 您可以针对不同的场景选择不同的方式来处理这个问题。<br></p>

<!-- TEASER_END -->

<div id="outline-container-orge330fd6" class="outline-2">
<h2 id="orge330fd6">nohup / setsid / &amp;</h2>
<div class="outline-text-2" id="text-orge330fd6">
<p>
<b>场景：</b><br>
如果只是临时有一个命令需要长时间运行，什么方法能最简便的保证它在后台稳定运行呢？<br></p>

<p>
<b>解决方法：</b><br>
我们知道，当用户注销（logout）或者网络断开时，终端会收到 HUP（hangup）信号从而关闭其所有子进程。因此，我们的解决办法就有两种途径：要么让进程忽略 HUP 信号，要么让进程运行在新的会话里从而成为不属于此终端的子进程。<br></p>

<blockquote>
<p>
hangup 名称的来由<br>
在 Unix 的早期版本中，每个终端都会通过 modem 和系统通讯。当用户 logout 时，modem 就会挂断（hang up）电话。 同理，当 modem 断开连接时，就会给终端发送 hangup 信号来通知其关闭所有子进程。<br></p>
</blockquote>
</div>

<div id="outline-container-org272a190" class="outline-3">
<h3 id="org272a190">1. nohup</h3>
<div class="outline-text-3" id="text-org272a190">
<p>
nohup 无疑是我们首先想到的办法。顾名思义，nohup 的用途就是让提交的命令忽略 hangup 信号。让我们先来看一下 nohup 的帮助信息：<br></p>

<pre class="example">
NOHUP(1)                        User Commands                        NOHUP(1)

NAME
       nohup - run a command immune to hangups, with output to a non-tty

SYNOPSIS
       nohup COMMAND [ARG]...
       nohup OPTION

DESCRIPTION
       Run COMMAND, ignoring hangup signals.

       --help display this help and exit

       --version
              output version information and exit
</pre>
<p>
可见，nohup 的使用是十分方便的，只需在要处理的命令前加上 nohup 即可，标准输出和标准错误缺省会被重定向到 nohup.out 文件中。一般我们可在结尾加上"&amp;"来将命令同时放入后台运行，也可用"&gt;filename 2&gt;&amp;1"来更改缺省的重定向文件名。<br></p>

<p>
nohup 示例:<br></p>
<pre class="example">
[root@pvcent107 ~]# nohup ping www.ibm.com &amp;
[1] 3059
nohup: appending output to `nohup.out'
[root@pvcent107 ~]# ps -ef |grep 3059
root      3059   984  0 21:06 pts/3    00:00:00 ping www.ibm.com
root      3067   984  0 21:06 pts/3    00:00:00 grep 3059
[root@pvcent107 ~]#
</pre>
</div>
</div>

<div id="outline-container-org4b00d6e" class="outline-3">
<h3 id="org4b00d6e">2. setsid</h3>
<div class="outline-text-3" id="text-org4b00d6e">
<p>
nohup 无疑能通过忽略 HUP 信号来使我们的进程避免中途被中断，但如果我们换个角度思考，如果我们的进程不属于接受 HUP 信号的终端的子进程，那么自然也就不会受到 HUP 信号的影响了。setsid 就能帮助我们做到这一点。让我们先来看一下 setsid 的帮助信息：<br></p>

<pre class="example">
SETSID(8)                 Linux Programmer’s Manual                 SETSID(8)

NAME
       setsid - run a program in a new session

SYNOPSIS
       setsid program [ arg ... ]

DESCRIPTION
       setsid runs a program in a new session.
</pre>

<p>
可见 setsid 的使用也是非常方便的，也只需在要处理的命令前加上 setsid 即可。<br></p>

<p>
setsid 示例<br></p>
<pre class="example">
[root@pvcent107 ~]# setsid ping www.ibm.com
[root@pvcent107 ~]# ps -ef |grep www.ibm.com
root     31094     1  0 07:28 ?        00:00:00 ping www.ibm.com
root     31102 29217  0 07:29 pts/4    00:00:00 grep www.ibm.com
[root@pvcent107 ~]#
</pre>

<p>
值得注意的是，上例中我们的进程 ID(PID)为31094，而它的父 ID（PPID）为1（即为 init 进程 ID），并不是当前终端的进程 ID。请将此例与nohup 例中的父 ID 做比较。<br></p>
</div>
</div>

<div id="outline-container-org4209ba0" class="outline-3">
<h3 id="org4209ba0">3. &amp;</h3>
<div class="outline-text-3" id="text-org4209ba0">
<p>
这里还有一个关于 subshell 的小技巧。我们知道，将一个或多个命名包含在“()”中就能让这些命令在子 shell 中运行中，从而扩展出很多有趣的功能，我们现在要讨论的就是其中之一。<br></p>

<p>
当我们将"&amp;"也放入“()”内之后，我们就会发现所提交的作业并不在作业列表中，也就是说，是无法通过jobs来查看的。让我们来看看为什么这样就能躲过 HUP 信号的影响吧。<br></p>

<p>
subshell 示例<br></p>
<pre class="example">
[root@pvcent107 ~]# (ping www.ibm.com &amp;)
[root@pvcent107 ~]# ps -ef |grep www.ibm.com
root     16270     1  0 14:13 pts/4    00:00:00 ping www.ibm.com
root     16278 15362  0 14:13 pts/4    00:00:00 grep www.ibm.com
[root@pvcent107 ~]#
</pre>

<p>
从上例中可以看出，新提交的进程的父 ID（PPID）为1（init 进程的 PID），并不是当前终端的进程 ID。因此并不属于当前终端的子进程，从而也就不会受到当前终端的 HUP 信号的影响了。<br></p>
</div>
</div>
</div>

<div id="outline-container-org744cf50" class="outline-2">
<h2 id="org744cf50">disown</h2>
<div class="outline-text-2" id="text-org744cf50">
<p>
<b>场景：</b><br>
我们已经知道，如果事先在命令前加上 nohup 或者 setsid 就可以避免 HUP 信号的影响。但是如果我们未加任何处理就已经提交了命令，该如何补救才能让它避免 HUP 信号的影响呢？<br></p>

<p>
<b>解决方法：</b><br>
这时想加 nohup 或者 setsid 已经为时已晚，只能通过作业调度和 disown 来解决这个问题了。让我们来看一下 disown 的帮助信息：<br></p>

<pre class="example">
disown [-ar] [-h] [jobspec ...]
    Without options, each jobspec is  removed  from  the  table  of
    active  jobs.   If  the -h option is given, each jobspec is not
    removed from the table, but is marked so  that  SIGHUP  is  not
    sent  to the job if the shell receives a SIGHUP.  If no jobspec
    is present, and neither the -a nor the -r option  is  supplied,
    the  current  job  is  used.  If no jobspec is supplied, the -a
    option means to remove or mark all jobs; the -r option  without
    a  jobspec  argument  restricts operation to running jobs.  The
    return value is 0 unless a jobspec does  not  specify  a  valid
    job.
</pre>

<p>
可以看出，我们可以用如下方式来达成我们的目的。<br></p>
<ul class="org-ul">
<li>用disown -h jobspec来使某个作业忽略HUP信号。<br>
</li>
<li>用disown -ah 来使所有的作业都忽略HUP信号。<br>
</li>
<li>用disown -rh 来使正在运行的作业忽略HUP信号。<br>
</li>
</ul>
<p>
需要注意的是，当使用过 disown 之后，会将把目标作业从作业列表中移除，我们将不能再使用jobs来查看它，但是依然能够用ps -ef查找到它。<br></p>

<p>
但是还有一个问题，这种方法的操作对象是作业，如果我们在运行命令时在结尾加了"&amp;"来使它成为一个作业并在后台运行，那么就万事大吉了，我们可以通过jobs命令来得到所有作业的列表。但是如果并没有把当前命令作为作业来运行，如何才能得到它的作业号呢？答案就是用 CTRL-z（按住Ctrl键的同时按住z键）了！<br></p>

<p>
CTRL-z 的用途就是将当前进程挂起（Suspend），然后我们就可以用jobs命令来查询它的作业号，再用bg jobspec来将它放入后台并继续运行。需要注意的是，如果挂起会影响当前进程的运行结果，请慎用此方法。<br></p>

<blockquote>
<p>
灵活运用 CTRL-z<br>
在我们的日常工作中，我们可以用 CTRL-z 来将当前进程挂起到后台暂停运行，执行一些别的操作，然后再用 fg 来将挂起的进程重新放回前台（也可用 bg 来将挂起的进程放在后台）继续运行。这样我们就可以在一个终端内灵活切换运行多个任务，这一点在调试代码时尤为有用。因为将代码编辑器挂起到后台再重新放回时，光标定位仍然停留在上次挂起时的位置，避免了重新定位的麻烦。<br></p>
</blockquote>

<p>
<b>disown 示例1</b> （如果提交命令时已经用“&amp;”将命令放入后台运行，则可以直接使用“disown”）<br></p>

<pre class="example">
[root@pvcent107 build]# cp -r testLargeFile largeFile &amp;
[1] 4825
[root@pvcent107 build]# jobs
[1]+  Running                 cp -i -r testLargeFile largeFile &amp;
[root@pvcent107 build]# disown -h %1
[root@pvcent107 build]# ps -ef |grep largeFile
root      4825   968  1 09:46 pts/4    00:00:00 cp -i -r testLargeFile largeFile
root      4853   968  0 09:46 pts/4    00:00:00 grep largeFile
[root@pvcent107 build]# logout
</pre>

<p>
<b>disown 示例2</b> （如果提交命令时未使用“&amp;”将命令放入后台运行，可使用 CTRL-z 和“bg”将其放入后台，再使用“disown”）<br></p>

<pre class="example">
[root@pvcent107 build]# cp -r testLargeFile largeFile2

[1]+  Stopped                 cp -i -r testLargeFile largeFile2
[root@pvcent107 build]# bg %1
[1]+ cp -i -r testLargeFile largeFile2 &amp;
[root@pvcent107 build]# jobs
[1]+  Running                 cp -i -r testLargeFile largeFile2 &amp;
[root@pvcent107 build]# disown -h %1
[root@pvcent107 build]# ps -ef |grep largeFile2
root      5790  5577  1 10:04 pts/3    00:00:00 cp -i -r testLargeFile largeFile2
root      5824  5577  0 10:05 pts/3    00:00:00 grep largeFile2
[root@pvcent107 build]#
</pre>
</div>
</div>

<div id="outline-container-org6b353f3" class="outline-2">
<h2 id="org6b353f3">screen</h2>
<div class="outline-text-2" id="text-org6b353f3">
<p>
<b>场景：</b><br>
我们已经知道了如何让进程免受 HUP 信号的影响，但是如果有大量这种命令需要在稳定的后台里运行，如何避免对每条命令都做这样的操作呢？<br></p>

<p>
<b>解决方法：</b><br>
此时最方便的方法就是 screen 了。简单的说，screen 提供了 ANSI/VT100 的终端模拟器，使它能够在一个真实终端下运行多个全屏的伪终端。screen 的参数很多，具有很强大的功能，我们在此仅介绍其常用功能以及简要分析一下为什么使用 screen 能够避免 HUP 信号的影响。我们先看一下 screen 的帮助信息：<br></p>

<pre class="example">
SCREEN(1)                                                           SCREEN(1)

NAME
       screen - screen manager with VT100/ANSI terminal emulation

SYNOPSIS
       screen [ -options ] [ cmd [ args ] ]
       screen -r [[pid.]tty[.host]]
       screen -r sessionowner/[[pid.]tty[.host]]

DESCRIPTION
       Screen  is  a  full-screen  window manager that multiplexes a physical
       terminal between several  processes  (typically  interactive  shells).
       Each  virtual  terminal provides the functions of a DEC VT100 terminal
       and, in addition, several control functions from the  ISO  6429  (ECMA
       48,  ANSI  X3.64)  and ISO 2022 standards (e.g. insert/delete line and
       support for multiple character sets).  There is a  scrollback  history
       buffer  for  each virtual terminal and a copy-and-paste mechanism that
       allows moving text regions between windows.
</pre>

<p>
使用 screen 很方便，有以下几个常用选项：<br></p>
<ul class="org-ul">
<li>用screen -dmS session name来建立一个处于断开模式下的会话（并指定其会话名）。<br>
</li>
<li>用screen -list 来列出所有会话。<br>
</li>
<li>用screen -r session name来重新连接指定会话。<br>
</li>
<li>用快捷键CTRL-a d 来暂时断开当前会话。<br>
</li>
</ul>
<p>
screen 示例<br></p>
<pre class="example">
[root@pvcent107 ~]# screen -dmS Urumchi
[root@pvcent107 ~]# screen -list
There is a screen on:
        12842.Urumchi   (Detached)
1 Socket in /tmp/screens/S-root.

[root@pvcent107 ~]# screen -r Urumchi
</pre>

<p>
当我们用“-r”连接到 screen 会话后，我们就可以在这个伪终端里面为所欲为，再也不用担心 HUP 信号会对我们的进程造成影响，也不用给每个命令前都加上“nohup”或者“setsid”了。这是为什么呢？让我来看一下下面两个例子吧。<br></p>

<ol class="org-ol">
<li>未使用 screen 时新进程的进程树<br>
</li>
</ol>
<pre class="example">
[root@pvcent107 ~]# ping www.google.com &amp;
[1] 9499
[root@pvcent107 ~]# pstree -H 9499
init─┬─Xvnc
     ├─acpid
     ├─atd
     ├─2*[sendmail]
     ├─sshd─┬─sshd───bash───pstree
     │       └─sshd───bash───ping
</pre>


<p>
我们可以看出，未使用 screen 时我们所处的 bash 是 sshd 的子进程，当 ssh 断开连接时，HUP 信号自然会影响到它下面的所有子进程（包括我们新建立的 ping 进程）。<br></p>

<ol class="org-ol">
<li>使用了 screen 后新进程的进程树<br>
</li>
</ol>
<pre class="example">
[root@pvcent107 ~]# screen -r Urumchi
[root@pvcent107 ~]# ping www.ibm.com &amp;
[1] 9488
[root@pvcent107 ~]# pstree -H 9488
init─┬─Xvnc
     ├─acpid
     ├─atd
     ├─screen───bash───ping
     ├─2*[sendmail]
</pre>

<p>
而使用了 screen 后就不同了，此时 bash 是 screen 的子进程，而 screen 是 init（PID为1）的子进程。那么当 ssh 断开连接时，HUP 信号自然不会影响到 screen 下面的子进程了。<br></p>
</div>
</div>

<div id="outline-container-orga438383" class="outline-2">
<h2 id="orga438383">总结</h2>
<div class="outline-text-2" id="text-orga438383">
<p>
现在几种方法已经介绍完毕，我们可以根据不同的场景来选择不同的方案。nohup/setsid 无疑是临时需要时最方便的方法，disown 能帮助我们来事后补救当前已经在运行了的作业，而 screen 则是在大批量操作时不二的选择了。<br></p>
</div>
</div>
  </div>
  

</article>
</div>

      <div class="col-lg-3 col-md-3 col-sm-12 col-xs-12 sidebar">
       
<div class="sidebar-module sidebar-module-inset">
  <h4>About Me</h4>
  
        <div class="sidebar-aboutme">
        <p>Zeal for coding, C++ developer. Focused on Linux server develop. I use EMACS on a daily basis.</p>
        </div>
</div>

       
<div class="sidebar-module sidebar-module-inset">
  <h4>Categories</h4>
  
        <ol class="list-unstyled sidebar-category">
<li>
<a href="/tags/category-cpp/">cpp</a>
        </li>
<li>
<a href="/tags/category-emacs/">emacs</a>
        </li>
<li>
<a href="/tags/category-linux/">linux</a>
        </li>
<li>
<a href="/tags/category-windows/">windows</a>
        </li>
</ol>
</div>

      </div>
<!--.sidebar-->
    </div>
<!--.row-->

    

    <ul class="pager hidden-print">
<li class="left">
          <a href="/posts/algorithm-weekly-search-in-rotated-sorted-array/" rel="prev">
            <p class="title">每周算法：搜索有序的回环数组</p>
            <p>Previous post</p>
          </a>
      </li>
      <li class="right">
          <a href="/posts/algorithm-weekly-find-first-and-last-position-of-element-in-sorted-array/" rel="next">
            <p class="title">每周算法：从有序数组中找到目标出现的第一次和最后一次的位置</p>
            <p>Next post</p>
          </a>
      </li>
    </ul>
<section class="comments hidden-print"><h2>Comments</h2>
    
        
        <div id="disqus_thread"></div>
        <script>
        var disqus_shortname ="samsonwang-me",
            disqus_url="https://samsonwang.me/posts/linux-run-program-nohup/",
        disqus_title="[\u8f6c]Linux \u6280\u5de7\uff1a\u8ba9\u8fdb\u7a0b\u5728\u540e\u53f0\u53ef\u9760\u8fd0\u884c\u7684\u51e0\u79cd\u65b9\u6cd5",
        disqus_identifier="cache/archives/2018/linux-run-program-nohup.html",
        disqus_config = function () {
            this.language = "en";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.async = true;
            dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript>
    <a href="https://disqus.com" class="dsq-brlink" rel="nofollow">Comments powered by <span class="logo-disqus">Disqus</span></a>


  </section><script>var disqus_shortname="samsonwang-me";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script><!--End of body content--><footer id="footer"><div class="text-center">
<p>Contents © 2017-2019 <a href="mailto:wangzhilv@gmail.com">Samson Wang</a>
 - Powered by <a href="https://getnikola.com/" rel="nofollow">Nikola</a>
 - Hosted on <a href="https://pages.github.com/" rel="nofollow">Github Pages</a>
 - 
<a rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/"><img alt="知识共享许可协议" style="padding-bottom:2px" src="https://i.creativecommons.org/l/by-nc/4.0/80x15.png"></a>
</p>
</div>

      
    </footer>
</div>
</div>

<div id="scroll-top" title="back to top">
  <div id="scroll-top-arrow"></div>
  <div id="scroll-top-stick"></div>
</div>


            <script src="/assets/js/jquery.min.js"></script><script src="/assets/js/jquery.colorbox-min.js"></script><script src="/assets/js/jquery.lazyload.min.js"></script><script src="/assets/js/popper.min.js"></script><script src="/assets/js/bootstrap.min.js"></script><script src="/assets/js/moment-with-locales.min.js"></script><script src="/assets/js/fancydates.js"></script><script src="/assets/js/cerulean.js"></script><!-- fancy dates --><script>
  moment.locale("en");
  fancydates(0, "YYYY-MM-DD HH:mm");
</script><!-- end fancy dates --><!-- Baidu Analytics --><script>
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?7ec47c52179b8ca4f9aee81282bd7b20";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>
</body>
</html>
