<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#" lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>深入探索C++内存模型（4） | Hack Note</title>
<link href="/blog/assets/css/bootstrap.min.css" rel="stylesheet" type="text/css">
<link href="/blog/assets/css/font-awesome.min.css" rel="stylesheet" type="text/css">
<link href="/blog/assets/css/code.css" rel="stylesheet" type="text/css">
<link href="/blog/assets/css/colorbox.css" rel="stylesheet" type="text/css">
<link href="/blog/assets/css/highlight.css" rel="stylesheet" type="text/css">
<link href="/blog/assets/css/cerulean.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="en" href="/blog/rss.xml">
<link rel="canonical" href="https://samsonwang.github.io/blog/posts/inside-the-cpp-object-model-4/">
<link rel="icon" href="/blog/favicon.ico" sizes="64x64">
<!--[if lt IE 9]><script src="/blog/assets/js/html5.js"></script><![endif]--><meta name="author" content="Samson Wang">
<link rel="prev" href="/blog/posts/inside-the-cpp-object-model-3/" title="深入探索C++内存模型（3）" type="text/html">
<link rel="next" href="/blog/posts/redis-fundamental/" title="redis基础" type="text/html">
</head>
<body class="preload">
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->
<nav id="top-nav" class="navbar navbar-expand-md fixed-top mb-4 navbar-dark bg-dark"><div class="container">   <!-- This keeps the margins nice -->
    <a class="navbar-brand" href="/blog/">

      <span id="blog-title">Hack Note</span>
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div class="collapse navbar-collapse" id="bs-navbar">
      <ul class="navbar-nav ml-auto">
<li class="nav-item">
<a href="/blog/archive/" class="nav-link">Archives</a>
                </li>
<li class="nav-item">
<a href="/blog/tags/" class="nav-link">Tags</a>
                </li>
<li class="nav-item">
<a href="/blog/rss.xml" class="nav-link">RSS Feed</a>

        
      </li>
</ul>
<ul class="navbar-nav navbar-right"></ul>
</div>
<!-- /.navbar-collapse -->
  </div>
<!-- /.container -->
</nav><!-- End of Menubar --><div class="container" id="content" role="main">
  <div class="body-content">
    <!--Body content-->
    <div class="row">

      <div class="col-lg-9 col-md-9 col-sm-12 col-xs-12">
        
        
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name">深入探索C++内存模型（4）</h1>

    <div class="metadata">
      

      
  <div class="date blur-1">
    <time class="published dt-published" datetime="2019-04-22T10:27:22+08:00" itemprop="datePublished" title="2019-04-22 10:27">Apr 22 2019</time>
</div>

      

      
    <div class="source blur-1">
      <a href="/blog/posts/inside-the-cpp-object-model-4/index.org" class="sourcelink">Source</a>
    </div>

      

      
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/blog/tags/cpp/" rel="tag">cpp</a></li>
        <li><a class="tag p-category" href="/blog/tags/digest/" rel="tag">digest</a></li>
        <li><a class="tag p-category" href="/blog/tags/lippman/" rel="tag">Lippman</a></li>
        <li><a class="tag p-category" href="/blog/tags/memory-layout/" rel="tag">memory layout</a></li>
        <li><a class="tag p-category" href="/blog/tags/object-model/" rel="tag">object model</a></li>
    </ul>
</div>

      

    </div>
  </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>
第四章是Function语意学，这一章主要介绍类相关函数的底层实现原理，就虚函数进行了展开讨论，通过实际代码的测试结果验证分析结论。对 inline 函数可能会出现的问题进行了分析，对 inline 函数的使用提出了指导意见。<br></p>

<!-- TEASER_END -->

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">第4章 Function 语意学 （the semantics of function）</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">4.1 Member 的各种调用方式</h3>
<div class="outline-text-3" id="text-1-1">
</div>
<div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">Nonstatic Member Functions（非静态成员函数）</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
C++ 的设计准则之一就是：nonstatic member function 至少必须和一版的nonmember function有相同的效率。<br></p>

<p>
编译器会将member function重写成一个外部函数，对函数名称进行“mangling”处理，使它在程序中成为独一无二的语汇。在这过程中也会施行NRV优化。<br></p>
</div>
</div>

<div id="outline-container-sec-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">名称的特殊处理（name mangling）</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
一版而言，member的名称前面汇被加上 class 名称，行程独一无二的命名。<br></p>

<p>
对于类中的成员变量也会进行换名，以应对可能在继承关系中引入的同名成员变量。<br></p>

<p>
两个实体如果拥有独一无二的 name mangling，那么任何不正确的调用操作在链接时期就因无法决议（resolved）而失败，有是由我们可以乐观地称此为“确保类型安全的链接行为”（type-safe linkage）。我说“乐观地”是因为它只可以捕捉函数的标记（signature，即函数名称 + 参数数目 + 参数类型）错误，如果“返回类型”声明错误，就没办法检查出来。<br></p>

<p>
当前的编译系统中，有一种所谓的 demangling 工具，用来拦截名称并将其转换回去，使用者仍然可以不关心其内部名称发生的转换。<br></p>
</div>
</div>

<div id="outline-container-sec-1-1-3" class="outline-4">
<h4 id="sec-1-1-3">virtual member functions（虚拟成员函数）</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
使用指针调用虚函数会从虚函数表找到对应的虚函数地址，使用该虚函数地址完成函数的调用。<br></p>

<p>
如果使用类域明确地调用虚函数，则会压制由于虚拟机制而产生的不必要的重复查找虚函数表操作。<br></p>
</div>
</div>

<div id="outline-container-sec-1-1-4" class="outline-4">
<h4 id="sec-1-1-4">static member functions（静态成员函数）</h4>
<div class="outline-text-4" id="text-1-1-4">
<p>
静态成员函数的特性：<br></p>
<ol class="org-ol">
<li>没有 this 指针<br>
</li>
<li>不能直接存取其 class 中的 nonstatic members<br>
</li>
<li>不能比声明为 const 、 volatile 或 virtual<br>
</li>
<li>不需要经由 class object 才被调用 （虽然大部分时候它是这样被调用的）<br>
</li>
</ol>
<p>
一个 static member function 当然会被体书于 class 声明之外，并给予一个经过“mangled”的适当名称。<br></p>

<p>
如果取一个 static member function 的地址，获得的是其在内存中的位置，也就其地址。由于 static member function 没有 this 指针，所以其地址的类型并不是一个 “指向 class member function 的指针”，而是一个 “nonmember function 的指针”。也就是说：<br></p>
<div class="highlight"><pre><span></span><span class="o">&amp;</span><span class="n">Point3d</span><span class="o">::</span><span class="n">object_count</span><span class="p">();</span>
</pre></div>
<p>
会得到一个数值，类型是：<br></p>
<div class="highlight"><pre><span></span><span class="kt">unsigned</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="p">)();</span>
</pre></div>
<p>
而不是：<br></p>
<div class="highlight"><pre><span></span><span class="kt">unsigned</span> <span class="nf">int</span> <span class="p">(</span><span class="n">Point3d</span><span class="o">::*</span><span class="p">)();</span>
</pre></div>

<p>
static member function 由于缺乏 this 指针，因此差不多等同于 nonmember function。它提供了一个意想不到的好处：成为一个 callback 函数，也可以应用在线程（thread）函数上。<br></p>
</div>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">4.2 virtual member function (虚拟成员函数)</h3>
<div class="outline-text-3" id="text-1-2">
<p>
为了支持 virtual function 机制，必须首先能够对于多态对象有某种形式的“执行期判断法（runtime type resolution）”。在添加这些特性时，必定会增加类空间的负担，还需要考虑到对C语言的兼容性。<br></p>

<p>
在C++中，多态（polymorphism）表示“以一个public base class 的指针（或reference），寻址出一个 derived class object”的意思。<br></p>

<p>
指针的多态机能主要扮演一个输送机制（transport mechanism）的角色，我们可以通过它在程序的任何地方采用一组 public derived 类型。这种多态形式被称为是消极的，可以在编译时期完成。当被指出的对象真正被使用时，多态也就编程积极的（active）了。<br></p>

<p>
在runtime type identification （RTTI）性质于1993年被引入 C++ 语言之前， C++ 对“积极多态（active polymorphism）”的唯一支持，就是对于 virtual function call 的决议（resolution）操作。有了RTTI，就能够在执行期查询一个多态的 pointer 或多态的 reference 了。<br></p>

<p>
欲鉴定哪些 class 展现多态特性，我们需要额外的执行期信息。适当的方法就是看看啊它是否有任何 virtual function，只要 class 拥有一个 virtual function，它就需要这份额外的执行期信息。<br></p>

<p>
在 C++ 中， virtual functions可以在编译时期获知，这一组地址是固定不变的，执行期不可能新增或替换之。在程序执行时，表格的大小和内容都不会改变，多亿其构建和存取皆可以由编译器完全掌握，不需要执行期的任何介入。<br></p>

<p>
一个 class 只会有一个 virtual table，没一个 table 内含其对应的 class object 中所有 active virtual functions 函数实体的地址。这些 active virtual functions 包括：<br></p>
<ol class="org-ol">
<li>这个 class 所定义的函数实体，它会改写（overriding）一个可能存在的 base class virtual function 函数实体。<br>
</li>
<li>继承自 base class 的函数实体，这是在 derived class 决定不改写 virtual function 时才会出现的情况。<br>
</li>
<li>一个 pure<sub>virtual</sub><sub>called</sub>() 函数实体，它既可以扮演 pure virtual function 的空间保卫者角色，也可以当作执行期异常处理函数。<br>
</li>
</ol>
<p>
每一个 virtual function 都被指派一个固定的索引值，这个索引在整个继承体系中保持与特定的 virtual function 的关联。<br></p>

<p>
对于虚函数表在派生过程中的修改和拓展，在书中有很多详尽的代码示例可供参考。<br></p>

<p>
如何在编译时期设定 virtual function 的调用：<br></p>
<ol class="org-ol">
<li>我们并不知道 <code>ptr</code> 所指内向的真正类型，然而我知道，经由 ptr 可以存取到该对象的 virtual table。<br>
</li>
<li>虽然我不知道那个 <code>z()</code> 函数实体会被调用，但我知道每一个 <code>z()</code> 函数地址都被放在指定位置（slot4）。<br>
</li>
</ol>
<p>
这些信息使得编译器可以将该调用转化为：<br></p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">vptr</span><span class="p">[</span><span class="mi">4</span><span class="p">])(</span><span class="n">ptr</span><span class="p">);</span>
</pre></div>

<p>
在一个单一继承体系中，virtual function 机制的行为十分良好，不但有效而且很容易塑造出模型来，但是在多重继承和虚拟继承之中，对 virtual functions 的支持就没有那么美好了。<br></p>
</div>

<div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">多重继承下的 virtual functions</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
在多重继承中支持 virtual functions，其复杂度围绕在第二个及后继的 base class 身上，以及“必须在执行期调整 this 指针”这一点。<br></p>

<p>
对于 derived class 的必要的 this 指针调整操作，必须在执行期完成。即 offset 的大小，以及把 offset 加到 this 指针上头的那一小段程序代码，必须有编译器在某个地方插入。<br></p>

<p>
比较有效率的解决方法是利用所谓的 thunk (thunk 是 knuth 博士的倒拼字）。所谓 thunk 是一小段 assembly 码，用来（1）以适当的 offset 值调整 this 指针，（2）跳到 virtual function 去。<br></p>

<p>
Thunk 技术允许 virtual table slot 继续内含一个简单的指针，因此多重继承不需要任何空间上的额外负担。 slots 中的地址可以直接指向 virtual function，也可以指向一个相关的 thunk（如果需要调整 this 指针的话）。于是，对于那些不需要调整 this 指针的 virtual function，也就不需要承担效率上的额外负担。<br></p>

<p>
调整 this 指针的第二个额外负担就是，由于两种不同的可能：（1）经由 derived class （或第一个 base class）调用，（2）经由第二个（或其后继） base class 调用，同一函数在 virtual table 中可能需要多个对应的 slosts。例如：<br></p>
<div class="highlight"><pre><span></span><span class="n">Base</span><span class="o">*</span> <span class="n">pbase1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Derived</span><span class="p">;</span>
<span class="n">Base</span><span class="o">*</span> <span class="n">pbase2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Derived</span><span class="p">;</span>

<span class="k">delete</span> <span class="n">pbase1</span><span class="p">;</span>
<span class="k">delete</span> <span class="n">pbase2</span><span class="p">;</span>
</pre></div>
<p>
虽然两个 delete 操作导致相同的 derived destructor，但它们需要两个不同的 virtual table slots：<br></p>
<ol class="org-ol">
<li>
<code>pbase1</code> 不需要调整 this 指针（因为 Base1 是最左端 base class，它已经指向 Derived 对象的起始处），其 virtual table slot 需放置真正的 destructor 地址。<br>
</li>
<li>
<code>pbase2</code> 需要调整 this 指针，其 virtual table slot 需要相关的 thunk 地址。<br>
</li>
</ol>
<p>
在多重继承下， 一个 derived class 内含 n-1 个额外的 virtual tables， n 表示其上一层 base class 的数目。因此，单一继承将不会有额外的 virtual table。<br></p>
</div>
</div>

<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2">虚继承下的 virtual function</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
在虚拟继承中，也需要调整 this 指针，至于在虚拟继承的情况下要消除 thunks，一般而言已经被证明是一项高难度技术。<br></p>

<p>
当一个 virtual base class 从另一个 virtual base class 派生而来，并且两者都支持 virtual function 和 nonstatic data member 时， 编译器对于 virtual base class 的支持简直就像进了迷宫一行。<br></p>

<p>
作者的建议是，不要在一个 virtual base class 中声明 nonstatic data members。<br></p>
</div>
</div>
</div>


<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">4.3 函数的效能</h3>
<div class="outline-text-3" id="text-1-3">
<p>
本章节主要针对前文中分析的各种函数调用情况，编写代码进行测试，并对实验结果进行了分析。<br></p>

<p>
按照前文的分析，nonmember 或 static member 或 nonstatic member 函数都被转化为完全相同的形式，所以从结果中能看到三者的效率完全相同。<br></p>

<p>
对于 inline 函数，未优化的情况提高了 25% 左右的效率，而其优化版本的表现提升十分明显。这归功于编译器将“被视为不变的表达式（expressions）”提到循环之外，因此只计算一次。此例显示，inline函数不仅能够节省一般函数调用所带来的额外负担，也提供了程序优化的额外机会。<br></p>

<p>
虚函数的执行效率降低了 4% 到 11% 不等，这是由虚拟机制产生的。<br></p>
</div>
</div>


<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">4.4 指向 member function 的指针 （pointer to member functions）</h3>
<div class="outline-text-3" id="text-1-4">
<p>
由前文的论述中可以得知，取一个 nonstatic data member 的地址，得到的结果是该 member 在 class 布局中的 byte 位置（再加1）.可以想象它是一个不完整的值，需要被绑定于某个 class object 的地址上，才能够被存取。<br></p>

<p>
取一个 nonstatic member function 的地址，如果该函数是 nonvirtual，则得到的结果是它在内存中的真正地址。然而这个值也是不完全的，它也需要被绑定于某个 class object 的地址上，才能够通过它调用该函数。所有的 nonstatic member function 都需要对象的地址（以参数 this 指出）。<br></p>

<p>
使用一个 “member function 指针”，如果并不用于 virtual function、多重继承、virtual base class 等情况的话，并不会比使用一个“nonmember function 指针”的成本更高，编译器可以为它们提供相同的效率。<br></p>
</div>


<div id="outline-container-sec-1-4-1" class="outline-4">
<h4 id="sec-1-4-1">支持“指向 virtual member function”的指针</h4>
<div class="outline-text-4" id="text-1-4-1">
<p>
注意下面的程序片段：<br></p>
<div class="highlight"><pre><span></span><span class="kt">float</span> <span class="p">(</span><span class="n">Point</span><span class="o">::*</span><span class="n">pmf</span><span class="p">)()</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Point</span><span class="o">::</span><span class="n">z</span><span class="p">;</span>
<span class="n">Point</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point3d</span><span class="p">;</span>
</pre></div>
<p>
<code>pmf</code> , 一个指向 member function 的指针，被设置为 Point::z() (一个 virtual function) 的地址，ptr 则被指定以一个 Point3d 对象，如果直接由 <code>ptr</code> 调用 <code>z()</code> :<br></p>
<div class="highlight"><pre><span></span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">z</span><span class="p">();</span>
</pre></div>
<p>
则被调用的是 Point3d::z()，但如果我们从 <code>pmf</code> 间接调用 <code>z()</code> 呢？<br></p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="n">ptr</span><span class="o">-&gt;*</span><span class="n">pmf</span><span class="p">)();</span>
</pre></div>
<p>
仍然是 Point3d::z() 被调用吗？答案是 yes，也就是说，虚拟机制仍然能够在使用“指向 member function 的指针”的情况下运行。<br></p>

<p>
结合前面章节，对一个 nonstatic member function 取其地址，将获得该函数在内存中的地址，然而对一个 virtual function，其地址在编译时期时候未知的，所能知道的近视 virtual function 在其相关 virtual table 中的索引值。也就是说，对一个 virtual member function 取其地址，所能获得的只是一个索引值。<br></p>

<p>
通过 <code>pmf</code> 来调用 <code>z()</code> 会被内部转化为一个编译时期的式子，一般形式如下：<br></p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">vptr</span><span class="p">[(</span><span class="kt">int</span><span class="p">)</span><span class="n">pmf</span><span class="p">])(</span><span class="n">ptr</span><span class="p">);</span>
</pre></div>
</div>
</div>

<div id="outline-container-sec-1-4-2" class="outline-4">
<h4 id="sec-1-4-2">多重继承下，指向 member function 的指针</h4>
<div class="outline-text-4" id="text-1-4-2">
<p>
为了让指向 member function 的指针也能够支持多重继承和虚拟继承，Stroustrup设计了下面一个结构体：<br></p>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">__mptr</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">delta</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
    <span class="k">union</span> <span class="p">{</span>
	<span class="n">ptrtofunc</span> <span class="n">faddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">v_offset</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">};</span>
</pre></div>

<p>
<code>index</code> 和 <code>faddr</code> 分别（不同时）带有 virtual table 索引和 nonvirtual member function 地址。为了方便，当 index 不指向 virtual table 时，会被设置为 -1。<br></p>

<p>
在该模型之下，像这样的调用操作：<br></p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="n">ptr</span><span class="o">-&gt;*</span><span class="n">pmf</span><span class="p">)();</span>
</pre></div>
<p>
会变成：<br></p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="n">pmf</span><span class="p">.</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
  <span class="o">?</span> <span class="c1">// non-virtual invocation</span>
  <span class="p">(</span><span class="o">*</span><span class="n">pmf</span><span class="p">.</span><span class="n">faddr</span><span class="p">)(</span><span class="n">ptr</span><span class="p">)</span>
  <span class="o">:</span> <span class="c1">// virtual invocation</span>
  <span class="p">(</span><span class="o">*</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">vptr</span><span class="p">[</span><span class="n">pmf</span><span class="p">.</span><span class="n">index</span><span class="p">]</span> <span class="p">(</span><span class="n">ptr</span><span class="p">));</span>
</pre></div>

<p>
这种方法的缺点是：<br></p>
<ol class="org-ol">
<li>每一个调用操作都得付出上述成本，检查其是否为 virtual 或 nonvirtual；<br>
</li>
<li>当传递一个不变值的指针给 member function 时，它需要产生一个临时性对象。<br>
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-4-3" class="outline-4">
<h4 id="sec-1-4-3">“指向 member function 的指针”的效率</h4>
<div class="outline-text-4" id="text-1-4-3">
<p>
本节测试了函数经由一以方式调用的效率：<br></p>
<ol class="org-ol">
<li>指向 nonmember function 的指针；<br>
</li>
<li>指向 class member function 的指针；<br>
</li>
<li>指向 virtual member function 的指针；<br>
</li>
<li>多重继承下的 nonvirtual 及 virtual member function 调用；<br>
</li>
<li>虚拟继承下的 nonvirtual 及 virtual member function 调用。<br>
</li>
</ol>
</div>
</div>
</div>


<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">4.5 inline functions</h3>
<div class="outline-text-3" id="text-1-5">
<p>
处理一个 inline 函数，有两个阶段：<br></p>
<ol class="org-ol">
<li>分析函数定义，以决定函数的“intrinsic inline ability”（本质的 inline 能力）。“intrinsic”（本质的、固有的）在这里意指“与编译器相关”。如果函数因其复杂度，或因其构建问题，被判断不可成为inline，它会被转为一个 static 函数，并在“被编译模块”内产生对应的函数定义。<br>
</li>
<li>真正的 inline 函数拓展操作是在调用的那一点上，这回带来参数的求值操作（evaluation）以及临时性对象的管理。同样是在拓展点上，编译器将决定这个调用是否“不可为inline”。<br>
</li>
</ol>
<p>
大部分编译器厂商（UNIX和PC都有）似乎认为不值得在 inline 支持技术上做详细的讨论，通常你必须进入到汇编器（assembler）中才能看到是否真的实现了 inline。<br></p>
</div>

<div id="outline-container-sec-1-5-1" class="outline-4">
<h4 id="sec-1-5-1">形式参数（formal argument）</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
在 inline 拓展期间，每一个形式参数都会被对应的实际参数取代。其副作用为，不可以只是简单地塞入程序中出现的每一个形式参数，因为这将导致对于时间参数的多次求值操作（evaluation）。<br></p>

<p>
一般而言，面对“会带来副作用的实际参数”，通常都需要引入临时性对象。换句话说，如果实际参数十一个常量表达式（constant expression），我们可以在替换之间先完成其求值操作（evalutaion）；后继的 inline 替换，就可以把常量直接“绑”上去，如果既不是个常量表达式，也不是个带有副作用的表达式，那么就直接代换之。<br></p>

<p>
示例代码如下：<br></p>
<div class="highlight"><pre><span></span><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">min</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="o">?</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">j</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 调用操作</span>
<span class="kr">inline</span> <span class="kt">int</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">minval</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">val1</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">val2</span> <span class="o">=</span> <span class="mi">2048</span><span class="p">;</span>
    <span class="cm">/*(1)*/</span> <span class="n">minval</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">val1</span><span class="p">,</span> <span class="n">val2</span><span class="p">);</span>
    <span class="cm">/*(2)*/</span> <span class="n">minval</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="mi">2048</span><span class="p">);</span>
    <span class="cm">/*(3)*/</span> <span class="n">minval</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">foo</span><span class="p">(),</span> <span class="n">bar</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">minval</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>
分析如下：<br>
标记为（1）的那一行会被拓展为：<br></p>
<div class="highlight"><pre><span></span><span class="c1">// 参数直接代换</span>
<span class="n">minval</span> <span class="o">=</span> <span class="n">val1</span> <span class="o">&lt;</span> <span class="n">val2</span> <span class="o">?</span> <span class="nl">val1</span> <span class="p">:</span> <span class="n">val2</span><span class="p">;</span>
</pre></div>

<p>
标记为（2）的那一行直接拥抱常量：<br></p>
<div class="highlight"><pre><span></span><span class="c1">// 代换之后，直接使用常量</span>
<span class="n">minval</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
</pre></div>

<p>
标记为（3）的那一行则引发参数的副作用，它需要引入一个临时对象，以避免重复求值（multiple evaluation）：<br></p>
<div class="highlight"><pre><span></span><span class="c1">// 有副作用，所以导入临时对象</span>
<span class="kt">int</span> <span class="n">t1</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">t2</span><span class="p">;</span>
<span class="n">minval</span> <span class="o">=</span> <span class="p">(</span><span class="n">t1</span> <span class="o">=</span> <span class="n">foo</span><span class="p">()),</span> <span class="p">(</span><span class="n">t2</span> <span class="o">=</span> <span class="n">bar</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">t1</span> <span class="o">&lt;</span> <span class="n">t2</span> <span class="o">?</span> <span class="nl">t1</span> <span class="p">:</span> <span class="n">t2</span><span class="p">;</span>
</pre></div>
</div>
</div>

<div id="outline-container-sec-1-5-2" class="outline-4">
<h4 id="sec-1-5-2">局部变量（local variables）</h4>
<div class="outline-text-4" id="text-1-5-2">
<p>
如果在 inline 定义中加入一个局部变量，会怎样：<br></p>
<div class="highlight"><pre><span></span><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">min</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">minval</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="o">?</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">j</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">minval</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>
这时，如果我们有一下的调用操作：<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">local_var</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">minval</span><span class="p">;</span>
<span class="c1">// ...</span>
<span class="n">minval</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">val1</span><span class="p">,</span> <span class="n">val2</span><span class="p">);</span>
</pre></div>

<p>
会被转化为：<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">local_var</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">minval</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">__min_lv_minval</span><span class="p">;</span>
<span class="n">minval</span> <span class="o">=</span> <span class="p">(</span><span class="n">__min_lv_minval</span> <span class="o">=</span> <span class="n">val1</span> <span class="o">&lt;</span> <span class="n">val2</span> <span class="o">?</span> <span class="nl">val1</span> <span class="p">:</span> <span class="n">val2</span><span class="p">),</span>
	  <span class="n">__min_lv_minval</span><span class="p">;</span>
</pre></div>

<p>
一般而言，inline 函数中的每一个局部变量都必须被放在函数调用的一个粉笔区段中，拥有一个独一无二的名称。如果 inline 函数以单一表达式（expression）拓展多次，那么每次拓展都需要自己的一组局部变量。如果 inline 函数以分离的多个式子（discrete statements）被拓展多次，那么只需要一组局部变量，就可以重复使用（因为它们被放在一个封闭区段中，有自己的 scope）。<br></p>

<p>
inline 函数中的局部变量，再加上有副作用的参数，可能会导致大量临时对象的产生。特别是如果它以单一表达式（expression）被拓展多次时。<br></p>

<p>
inline 函数对于封装提供了一种必要的支持，可以有效存取封装于 class 中的 nonpublic 数据。它同时也是 C 程序中大量使用的 <code>#define</code> （前置处理宏）的一个安全替代品，特别是如果红肿的参数有副作用的话。然而一个 inline 函数如果被调用太多次的话，会产生大量的拓展码，使程序的大小暴涨。<br></p>

<p>
对于既要安全又要效率的程序，inline函数提供了一个强而有力的工具。然而，与 non-inline 函数比起来，它们需要更加小心地处理。<br></p>

<p>
（全文完）<br></p>
</div>
</div>
</div>
</div>
  </div>
  

</article>
</div>

      <div class="col-lg-3 col-md-3 col-sm-12 col-xs-12 sidebar">
       
<div class="sidebar-module sidebar-module-inset">
  <h4>About Me</h4>
  
        <div class="sidebar-aboutme">
        <p>Zeal for coding, C++ developer. Focused on Linux server develop. I use EMACS on a daily basis.</p>
        </div>
</div>

       
<div class="sidebar-module sidebar-module-inset">
  <h4>Categories</h4>
  
        <ol class="list-unstyled sidebar-category">
<li>
<a href="/blog/tags/category-cpp/">cpp</a>
        </li>
<li>
<a href="/blog/tags/category-emacs/">emacs</a>
        </li>
<li>
<a href="/blog/tags/category-linux/">linux</a>
        </li>
<li>
<a href="/blog/tags/category-windows/">windows</a>
        </li>
</ol>
</div>

      </div>
<!--.sidebar-->
    </div>
<!--.row-->

    

    <ul class="pager hidden-print">
<li class="left">
          <a href="/blog/posts/inside-the-cpp-object-model-3/" rel="prev">
            <p class="title">深入探索C++内存模型（3）</p>
            <p>Previous post</p>
          </a>
      </li>
      <li class="right">
          <a href="/blog/posts/redis-fundamental/" rel="next">
            <p class="title">redis基础</p>
            <p>Next post</p>
          </a>
      </li>
    </ul>
<section class="comments hidden-print"><h2>Comments</h2>
    
        
        <div id="disqus_thread"></div>
        <script>
        var disqus_shortname ="samsonwang-me",
            disqus_url="https://samsonwang.github.io/blog/posts/inside-the-cpp-object-model-4/",
        disqus_title="\u6df1\u5165\u63a2\u7d22C++\u5185\u5b58\u6a21\u578b\uff084\uff09",
        disqus_identifier="cache/posts/inside-the-cpp-object-model-4.html",
        disqus_config = function () {
            this.language = "en";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.async = true;
            dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript>
    <a href="https://disqus.com" class="dsq-brlink" rel="nofollow">Comments powered by <span class="logo-disqus">Disqus</span></a>


  </section><script>var disqus_shortname="samsonwang-me";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script><!--End of body content--><footer id="footer"><div class="text-center">
<p>Contents © 2017-2019 <a href="mailto:wangzhilv@gmail.com">Samson Wang</a>
 - Powered by <a href="https://getnikola.com/" rel="nofollow">Nikola</a>
 - Hosted on <a href="https://pages.github.com/" rel="nofollow">Github Pages</a>
 - 
<a rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/"><img alt="知识共享许可协议" style="padding-bottom:2px" src="https://i.creativecommons.org/l/by-nc/4.0/80x15.png"></a>
</p>
</div>

      
    </footer>
</div>
</div>

<div id="scroll-top" title="back to top">
  <div id="scroll-top-arrow"></div>
  <div id="scroll-top-stick"></div>
</div>


            <script src="/blog/assets/js/jquery.min.js"></script><script src="/blog/assets/js/jquery.colorbox-min.js"></script><script src="/blog/assets/js/jquery.lazyload.min.js"></script><script src="/blog/assets/js/popper.min.js"></script><script src="/blog/assets/js/bootstrap.min.js"></script><script src="/blog/assets/js/moment-with-locales.min.js"></script><script src="/blog/assets/js/fancydates.js"></script><script src="/blog/assets/js/cerulean.js"></script><!-- fancy dates --><script>
  moment.locale("en");
  fancydates(0, "YYYY-MM-DD HH:mm");
</script><!-- end fancy dates --><!-- Baidu Analytics --><script>
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?7ec47c52179b8ca4f9aee81282bd7b20";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>
</body>
</html>
