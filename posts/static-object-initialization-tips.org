#+BEGIN_COMMENT
.. title: 静态变量初始化的几个问题
.. slug: static-object-initialization-tips
.. date: 2020-05-25 22:54:26 UTC+08:00
.. tags: cpp, static, singleton
.. category: cpp
.. link:
.. description:
.. type: text
.. status: draft
#+END_COMMENT
#+OPTIONS: num:nil

#+TITLE: 静态变量初始化的几个问题

本文介绍了静态变量、全局变量、单例模式在使用中需要注意的几个小问题，由于这些问题的出现条件都比较特殊，所以它们在使用中常常会被忽略。但是在设计和开发中考虑了这些问题后，能让你的代码更加稳健。

{{{TEASER_END}}}

** 全局变量初始化的顺序
通常，全局变量在 ~main~ 函数之前初始化完成，多个全局变量之间并没有确定的初始化顺序。这样，我们在编写代码时不能假设某个全局变量在另一个全局变量之前初始化完成。最好保证全局变量在构造（初始化）时不调用其他全局变量提供的接口，因为那个被调用的全局变量函数接口的对象有可能没有来得及初始化（这意味着构造函数未执行，成员变量没有初始化、各种资源可能没来得及申请）。

** 单例模式初始化的顺序
使用单例模式能够解决全局变量初始化问题。在单例模式中通常会有个静态函数用于返回单例类（class）的对象（object）的指针或引用，这样就保证了在使用这个单例对象时该对象肯定是被初始化了的。

#+BEGIN_SRC cpp
Singleton* Inst() {
    static Singleton* s_pObj = new Singleton;
    return s_pObj;
}
#+END_SRC

上面就是单例模式的示例代码，它返回了单例对象的指针。这种单例模式在解决了全局变量初始化顺序问题的同时又引入了一个新的问题，即内存泄漏的资源释放问题。这个问题在大多数情况下并无大碍，因为单例对象的生存期随着程序的运行结束而结束，在程序结束时操作系统会自动回收程序运行时申请的内存。但是在有些情况下需要显式调用析构函数完成资源释放，这些资源有可能是进程间交互所使用的资源，也可能是需要在对象析构时执行某些特定的操作。

#+BEGIN_COMMENT
这里还有个知识点，就是多线程下的单例模式对象的构造问题。
#+END_COMMENT

** 单例模式中返回对象
另一种单例模式的形式是返回对象的引用，如下所示。

#+BEGIN_SRC cpp
Singleton& Inst() {
    static Singleton s_obj;
    return s_obj;
}
#+END_SRC

静态全局变量在程序退出前一定会销毁，这样就避免了内存泄漏问题，也保证了单例对象的析构函数一定会被调用。但是这样做也存在者一些问题，即多个单例模式对象的析构顺序是不确定的。当某个单例模式对象在析构时依赖了另一个单例模式对象就会出现问题。

** 单例模式的终极形式
那么是否有一种单例模式的范例能够同时解决内存泄漏问题和析构顺序问题呢？答案是有的，只不过存在一定的性能损失。

#+BEGIN_COMMENT
C++ FAQ chapter 16.16, 16.17
#+END_COMMENT

** 总结
以上介绍的几种写法分别适用于什么情况。

** 参考资料
- [[http://www.cs.technion.ac.il/users/yechiel/c++-faq/static-init-order-on-first-use.html][C++ FAQ - static init order on first use]]
- [[http://www.cs.technion.ac.il/users/yechiel/c++-faq/construct-on-first-use-v2.html][C++ FAQ - construct on first use]]
- [[https://dreamdota.com/chaining-static-objects-with-static-linked-list/][dreamdota.com - chain static objects with linked list]]

（全文完）
