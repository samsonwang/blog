#+BEGIN_COMMENT
.. title: 静态初始化顺序问题
.. slug: static-initialization-order-problem
.. date: 2020-11-05 22:54:26 UTC+08:00
.. tags: cpp, static, singleton
.. category: cpp
.. link:
.. description:
.. type: text
.. status: draft
#+END_COMMENT
#+OPTIONS: num:nil

#+TITLE: 静态初始化顺序问题

本文介绍了静态变量构造顺序和析构顺序所带来的一系列问题，由于这些问题的出现条件都比较特殊，它们在使用中常常会被忽略。但是在设计和开发中这些问题是不可忽略的，最严重的可能导致程序崩溃。在考虑了这些问题后，能让你的代码更加稳健。

{{{TEASER_END}}}

** 静态初始化顺序
这个问题所涉及到的对象有：类域中的静态变量、文件中的和命名空间中的（全局）变量。

通常，全局变量会在 ~main~ 函数之前初始化完成，但是多个全局变量之间并没有确定的初始化顺序。我们在编写代码时不能假设某个全局变量在另一个全局变量之前初始化完成，要保证全局变量在初始化时（构造函数中）不调用其他全局变量提供的接口。因为那个被调用的全局变量函数接口的对象有可能没有来得及初始化，这意味着构造函数未执行，成员变量没有初始化，各种资源可能没来得及申请。

#+BEGIN_QUOTE
The nightmare scenario occurs when there is an order dependency between initializations across different compilation units (that is, different =.cpp= files). This can be both dangerous andsubtle.
#+END_QUOTE

这段话摘自《C++ FAQs》，它给出了更加详细的阐述，当静态变量出现在不同的编译单元中时（即不同的 =.cpp= 文件中），它们的初始化过程间不应该有相互依赖关系。

同时它也隐含了另一层意思，处在同一个编译单元中的变量在初始化时是有序的，会按照变量声明的先后顺序进行初始化。即在一个作用域中，先出现的（靠上的）对象在初始化时要早于后出现的（靠下的）对象。

** 单例模式初始化的顺序
使用单例模式能够解决全局变量初始化问题。在单例模式中通常会有个静态函数用于返回单例类（class）的对象（object）的引用，这样就保证了在使用这个单例对象时该对象肯定是被初始化了的。

类似的，我们可以通过函数返回这个静态变量的引用。

#+BEGIN_SRC cpp
Singleton& Instance() {
    static Singleton* s_pObj = new Singleton;
    return *s_pObj;
}
#+END_SRC

示例代码如上，它返回了单例对象的指针。这种单例模式在解决了全局变量初始化顺序问题的同时又引入了一个新的问题，即内存泄漏的资源释放问题。这个问题在大多数情况下并无大碍，因为单例对象的生存期随着程序的运行结束而结束，在程序结束时操作系统会自动回收程序运行时申请的内存。但是在有些情况下需要显式调用析构函数完成资源释放，这些资源有可能是进程间交互所使用的资源，也可能是需要在对象析构时执行某些特定的操作，如果跳过了。

#+BEGIN_COMMENT
这里还有个知识点，就是多线程下的单例模式对象的构造问题。
#+END_COMMENT


** 单例模式中返回对象的引用
另一种单例模式的形式是返回对象的引用，如下所示。

#+BEGIN_SRC cpp
Singleton& Instance() {
    static Singleton s_obj;
    return s_obj;
}
#+END_SRC

静态全局变量在程序退出前一定会销毁，这样就避免了内存泄漏问题，也保证了单例对象的析构函数一定会被调用。

但是这样做也存在者一些问题，即多个单例模式对象的析构顺序是不确定的。当某个单例模式对象在析构时依赖了另一个单例模式对象就可能会出现问题，其原理与构造顺序不确定相似。即由于析构顺序是随机的，当某个对象在析构时调用了另一个已经析构完成的对象的成员函数，问题就出现了。


** 单例模式的终极形式
那么是否有一种单例模式的范例能够同时解决内存泄漏问题和析构顺序问题呢？答案是有的，只不过写法稍微复杂，并且存在一定的性能损失。

#+BEGIN_COMMENT
C++ FAQ chapter 16.16, 16.17
#+END_COMMENT

#+BEGIN_SRC cpp
class Singleton
#+END_SRC




** 总结
以上介绍的几种写法分别适用于什么情况。


** 参考资料
- [[http://www.cs.technion.ac.il/users/yechiel/c++-faq/static-init-order-on-first-use.html][C++ FAQs - static init order on first use]]
- [[http://www.cs.technion.ac.il/users/yechiel/c++-faq/construct-on-first-use-v2.html][C++ FAQs - construct on first use]]
- [[https://dreamdota.com/chaining-static-objects-with-static-linked-list/][dreamdota.com - chain static objects with linked list]]

（全文完）
