#+BEGIN_COMMENT
.. title: 静态初始化顺序问题
.. slug: static-initialization-order-problem
.. date: 2020-11-05 22:54:26 UTC+08:00
.. tags: cpp, static, singleton
.. category: cpp
.. link:
.. description:
.. type: text
.. status: draft
#+END_COMMENT
#+OPTIONS: num:nil

#+TITLE: 静态初始化顺序问题

本文介绍了静态变量构造顺序和析构顺序所带来的一系列问题，由于这些问题的出现条件都比较特殊，它们在使用中常常会被忽略。但是在设计和开发中这些问题是不可忽略的，最严重的可能导致程序崩溃。在考虑了这些问题后，能让你的代码更加稳健。

{{{TEASER_END}}}

** 静态初始化顺序
这个问题所涉及到的对象有：类域中的静态变量、文件中的和命名空间中的（全局）变量。

通常，全局变量会在 ~main~ 函数之前初始化完成，但是多个全局变量之间并没有确定的初始化顺序。我们在编写代码时不能假设某个全局变量在另一个全局变量之前初始化完成，要保证全局变量在初始化时（构造函数中）不调用其他全局变量提供的接口。因为那个被调用的全局变量函数接口的对象有可能没有来得及初始化，这意味着构造函数未执行，成员变量没有初始化，各种资源可能没来得及申请。

#+BEGIN_QUOTE
The nightmare scenario occurs when there is an order dependency between initializations across different compilation units (that is, different =.cpp= files). This can be both dangerous andsubtle.
#+END_QUOTE

这段话摘自《C++ FAQs》，它给出了更加详细的阐述，当静态变量出现在不同的编译单元中（即不同的 =.cpp= 文件中）时，它们的初始化过程间不应该有相互依赖关系。

同时它也隐含了另一层意思，处在同一个编译单元中的变量在初始化时是有序的，会按照变量声明的先后顺序进行初始化。即在一个作用域中，先出现的（靠上的）对象在初始化时要早于后出现的（靠下的）对象。


** 使用指针的单例模式
使用单例模式能够解决全局变量初始化问题。在单例模式中通常会有个静态函数用于返回单例类（class）的对象（object）的引用，这样就保证了在使用这个单例对象时该对象肯定是被初始化了的。

单例模式能够保证类仅有实例化出一个对象，在代码实现上还需要搭配私有的类构造函数。如果仅需要保证对象在使用前被初始化，我们可以仿照单例模式的写法，通过函数返回静态变量的引用，示例代码如下。

#+BEGIN_SRC cpp
Singleton& Instance() {
    static Singleton* s_pObj = new Singleton;
    return *s_pObj;
}
#+END_SRC

这种仿单例模式的写法在解决了全局变量初始化顺序问题的同时又引入了另一个新的问题，即内存泄漏的资源释放问题。这个问题在大多数情况下并无大碍，因为静态对象的生存期随着程序的运行结束而结束，在程序结束时操作系统会自动回收程序运行时申请的内存。但是，在有些情况下需要显式调用析构函数完成资源释放，也可能是需要在对象析构时执行某些特定的操作。

#+BEGIN_COMMENT
这里还有个知识点，就是多线程下的单例模式对象的构造问题。
#+END_COMMENT


** 使用对象的单例模式
直接使用静态的类对象就能够避免内存泄漏问题。与使用对象指针的写法不同，静态变量在程序退出前一定会销毁，其析构函数一定会被调用。示例代码如下所示。

#+BEGIN_SRC cpp
Singleton& Instance() {
    static Singleton s_obj;
    return s_obj;
}
#+END_SRC

但是这样做也存在着问题，即多个静态对象的析构顺序是不确定的。当静态对象在析构时依赖了另一个静态对象就会出现问题，其原理与构造顺序不确定类似。即由于析构顺序是随机的，多个静态变量在销毁时不能存在相互依赖关系。


** 终极形式的单例模式
那么是否有一种单例模式的范例能够同时解决内存泄漏问题和析构顺序问题呢？答案是有的，只不过写法稍微复杂，并且存在一定的性能损失。

#+BEGIN_COMMENT
C++ FAQ chapter 16.16, 16.17
#+END_COMMENT

#+BEGIN_SRC cpp
class Singleton
#+END_SRC




** 总结
以上介绍的几种写法分别适用于什么情况。


** 参考资料
- [[http://www.cs.technion.ac.il/users/yechiel/c++-faq/static-init-order-on-first-use.html][C++ FAQs - static init order on first use]]
- [[http://www.cs.technion.ac.il/users/yechiel/c++-faq/construct-on-first-use-v2.html][C++ FAQs - construct on first use]]
- [[https://dreamdota.com/chaining-static-objects-with-static-linked-list/][dreamdota.com - chain static objects with linked list]]

（全文完）
