<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns#" lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta http-equiv="x-ua-compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>GCC的内存原子化操作函数接口 | Hack Note</title>
<meta name="theme-color" content="#04519b">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" href="/rss.xml">
<link href="/assets/css/minima.min.css" rel="stylesheet" type="text/css">
<link rel="canonical" href="https://blog.wangzhl.com/posts/2018/gcc-built-in-functions-for-atomic-memory-access/">
<link rel="icon" href="/favicon.ico" sizes="64x64">
<link rel="prev" href="/posts/2018/gdb-display-contents-of-memory-address/" title="在gdb中查看指定内存地址的内容" type="text/html">
<link rel="next" href="/posts/2018/cpp-bit-field/" title="C/C++中的位域" type="text/html">
<meta name="author" content="Samson Wang">
<meta property="og:site_name" content="Hack Note">
<meta property="og:title" content="GCC的内存原子化操作函数接口">
<meta property="og:url" content="https://blog.wangzhl.com/posts/2018/gcc-built-in-functions-for-atomic-memory-access/">
<meta property="og:description" content="1 原子化操作


在并发编程中，一个操作或一组操作是原子操作、可线性化操作、不可分操作或不可中断操作（atomic, linearizable, indivisible, uniterruptible），表示该操作执行时不可被中断的。操作的原子性能够保证操作在执行时免受中断、信号、并发进程线程的影响。另外，原子操作大多只有两种结果，要么成功并改变系统中对应的状态，要么没有相关效果。





原">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2018-07-02T17:54:08+08:00">
<meta property="article:tag" content="atomic">
<meta property="article:tag" content="gcc">
<meta property="article:tag" content="linux">
<meta property="article:tag" content="memory barrier">
</head>
<body>
  <header class="site-header nav-custom"><div class="wrapper">
      <a class="site-title" rel="author" href="/">Hack Note</a>
      <nav class="site-nav"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger">
          <span class="menu-icon">
            <svg viewbox="0 0 18 15" width="18px" height="15px"><use href="/assets/svg/theme.svg#menu-icon"></use></svg></span>
        </label>
        <div class="trigger">
          
            <a class="page-link" href="/">Home</a>
            <a class="page-link" href="/archive/">Archive</a>
            <a class="page-link" href="/tags/">Tags</a>
            <a class="page-link" href="/about/">About</a>

        </div>
      </nav>
</div>
  </header><main class="page-content" aria-label="Content"><div class="wrapper">

    

    
<article class="post h-entry" itemscope="" itemtype="http://schema.org/BlogPosting"><header class="post-header"><h1 class="post-title p-name" itemprop="name headline">GCC的内存原子化操作函数接口</h1>

    <p class="post-meta">
      
    <time class="dt-published" datetime="2018-07-02T17:54:08+08:00" itemprop="datePublished">Jul 02, 2018</time><span class="dt-updated"> / updated <time datetime="2020-06-10T10:25:08+08:00" itemprop="dateUpdated">Jun 10, 2020</time></span>

      

    </p>
  </header><div class="post-content e-content" itemprop="articleBody text">
    <div id="outline-container-org4955233" class="outline-2">
<h2 id="org4955233">
<span class="section-number-2">1</span> 原子化操作</h2>
<div class="outline-text-2" id="text-1">
<p>
在并发编程中，一个操作或一组操作是原子操作、可线性化操作、不可分操作或不可中断操作（atomic, linearizable, indivisible, uniterruptible），表示该操作执行时不可被中断的。操作的原子性能够保证操作在执行时免受中断、信号、并发进程线程的影响。另外，原子操作大多只有两种结果，要么成功并改变系统中对应的状态，要么没有相关效果。<br></p>

<!-- TEASER_END -->

<p>
原子化经常由互斥锁来保证，可以在硬件层面建立一个缓存一致性协议，也可以在软件层面使用信号量或加锁。因此，一个原子操作不是必须实际上马上生效，而操作系统让这个操作看起来是直接发生的，这能够让操作系统保持一致。正是如此，只要不影响性能，用户可以忽略较底层的实现细节。<br></p>
</div>
</div>


<div id="outline-container-orgfb06dd7" class="outline-2">
<h2 id="orgfb06dd7">
<span class="section-number-2">2</span> GCC函数接口</h2>
<div class="outline-text-2" id="text-2">
<p>
GCC提供了原子化的操作接口，能够支持长度为1、2、4、8字节的整形变量或指针。<br></p>

<blockquote>
<p>
In most cases, these builtins are considered a full barrier. That is, no memory operand will be moved across the operation, either forward or backward. Further, instructions will be issued as necessary to prevent the processor from speculating loads across the operation and from queuing stores after the operation.<br></p>
</blockquote>
<p>
在大多数情况下，这些内建函数是完全内存屏障（full barrier）的，以上摘自 GCC Manual。<br></p>
</div>

<div id="outline-container-orgb24f26d" class="outline-3">
<h3 id="orgb24f26d">
<span class="section-number-3">2.1</span> 先取值并进行对应操作</h3>
<div class="outline-text-3" id="text-2-1">
<div class="highlight"><pre><span></span><span class="n">type</span><span class="w"> </span><span class="n">__sync_fetch_and_add</span><span class="w"> </span><span class="p">(</span><span class="n">type</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="w"></span>
<span class="n">type</span><span class="w"> </span><span class="n">__sync_fetch_and_sub</span><span class="w"> </span><span class="p">(</span><span class="n">type</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="w"></span>
<span class="n">type</span><span class="w"> </span><span class="n">__sync_fetch_and_or</span><span class="w"> </span><span class="p">(</span><span class="n">type</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="w"></span>
<span class="n">type</span><span class="w"> </span><span class="n">__sync_fetch_and_and</span><span class="w"> </span><span class="p">(</span><span class="n">type</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="w"></span>
<span class="n">type</span><span class="w"> </span><span class="n">__sync_fetch_and_xor</span><span class="w"> </span><span class="p">(</span><span class="n">type</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="w"></span>
<span class="n">type</span><span class="w"> </span><span class="n">__sync_fetch_and_nand</span><span class="w"> </span><span class="p">(</span><span class="n">type</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="w"></span>
</pre></div>

<p>
这些函数接口的执行逻辑如下代码段所示：会执行名称相对应的运算，并将内存中之前存放的值取出并返回。<br></p>

<div class="highlight"><pre><span></span><span class="p">{</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">;</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="n">op</span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">{</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">;</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="n">tmp</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w">   </span><span class="c1">// nand</span>
</pre></div>

<p>
<b>注意</b> ：从GCC 4.4开始 <code>__sync_fetch_and_nand</code> 是按照 <code>*ptr = ~(*ptr &amp; value)</code> 实现的，而不是 <code>*ptr = ~*ptr &amp; value</code><br></p>
</div>
</div>

<div id="outline-container-orgbc946ec" class="outline-3">
<h3 id="orgbc946ec">
<span class="section-number-3">2.2</span> 直接操作并返回最终结果</h3>
<div class="outline-text-3" id="text-2-2">
<div class="highlight"><pre><span></span><span class="n">type</span><span class="w"> </span><span class="n">__sync_add_and_fetch</span><span class="w"> </span><span class="p">(</span><span class="n">type</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="w"></span>
<span class="n">type</span><span class="w"> </span><span class="n">__sync_sub_and_fetch</span><span class="w"> </span><span class="p">(</span><span class="n">type</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="w"></span>
<span class="n">type</span><span class="w"> </span><span class="n">__sync_or_and_fetch</span><span class="w"> </span><span class="p">(</span><span class="n">type</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="w"></span>
<span class="n">type</span><span class="w"> </span><span class="n">__sync_and_and_fetch</span><span class="w"> </span><span class="p">(</span><span class="n">type</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="w"></span>
<span class="n">type</span><span class="w"> </span><span class="n">__sync_xor_and_fetch</span><span class="w"> </span><span class="p">(</span><span class="n">type</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="w"></span>
<span class="n">type</span><span class="w"> </span><span class="n">__sync_nand_and_fetch</span><span class="w"> </span><span class="p">(</span><span class="n">type</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="w"></span>
</pre></div>

<p>
这些函数接口的执行逻辑如下代码段所示：<br></p>

<div class="highlight"><pre><span></span><span class="p">{</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="n">op</span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">{</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w">   </span><span class="c1">// nand</span>
</pre></div>

<p>
<b>注意</b> ：从GCC 4.4开始 <code>__sync_nand_and_fetch</code> 是按照 <code>*ptr = ~(*ptr &amp; value)</code> 实现的，而不是 <code>*ptr = ~*ptr &amp; value</code><br></p>
</div>
</div>

<div id="outline-container-orgdf9cb17" class="outline-3">
<h3 id="orgdf9cb17">
<span class="section-number-3">2.3</span> 比较并交换</h3>
<div class="outline-text-3" id="text-2-3">
<div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">__sync_bool_compare_and_swap</span><span class="w"> </span><span class="p">(</span><span class="n">type</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="n">oldval</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="n">newval</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="w"></span>
<span class="n">type</span><span class="w"> </span><span class="n">__sync_val_compare_and_swap</span><span class="w"> </span><span class="p">(</span><span class="n">type</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="n">oldval</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="n">newval</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>


<div id="outline-container-org14ea16f" class="outline-2">
<h2 id="org14ea16f">
<span class="section-number-2">3</span> 内存屏障（Memory Barrier）</h2>
<div class="outline-text-2" id="text-3">
<p>
在上文中提到了memory barrier，这是CPU指令中的一个术语。内存屏障又叫内存栅栏（memory fence），是一种能够让CPU或编译器约束内存操作指令执行顺序的屏蔽指令。这表示在内存屏障前的指令能够保证在执行时先于内存屏障后的指令。<br></p>

<p>
现代CPU使用的性能优化操作会导致指令在执行时变序，这样的指令变序对于单线程程序一般不会有很大影响，但是在多线程并发编程情况下需要小心地控制，否则会产生不可预知的结果。<br></p>

<p>
内存屏障的典型应用场景是多设备之间的共享内存的底层机器码。这些代码包括原始同步机制、多核系统上的无锁数据结构、与计算机硬件交互的设备驱动。内存屏障对于无锁编程（lock-free）来说是十分重要的。<br></p>
</div>

<div id="outline-container-org3ba0a89" class="outline-3">
<h3 id="org3ba0a89">
<span class="section-number-3">3.1</span> 内存屏障的分类</h3>
<div class="outline-text-3" id="text-3-1">
<p>
内存屏障分为读屏障（read barrier）、写屏障（write barrier）、获取屏障（acquire barrier）、释放屏障（release barrier）等。<br></p>

<p>
“写屏障”用于控制写操作的顺序。由于相对于CPU的执行速度来说，向内存中写入数据是比较慢的，通常会有一个写入请求队列，所以实际的写入操作发生在指令发起之后，队列中指令的顺序可能会被重新排序。写屏障能够防止写操作指令变序。<br></p>

<p>
“读屏障”用于控制读操作的顺序。由于预先执行（CPU会提前将内存中的数据读回来），并且CPU有缓存区（CPU会从缓存中而不是内存中读取数据），读操作可能会出现变序。<br></p>

<p>
“获取屏障”能够保证特定指令块之前的执行顺序。例如获取读，在向读队列中加入读操作，“获取屏障”意味着在这条操作之后可以出现指令变序，而这条操作之前不会出现指令变序。<br></p>

<p>
“释放屏障”能够保证特定指令块之后的执行顺序。例如释放写，在向写队列中加入写操作，“释放屏障”意味着在这条写操作之前的指令不会变序到该指令之后，而这条该操作的之后的指令可能会变序到该指令之前。<br></p>

<p>
“获取屏障”和“释放栅栏”是又叫半栅栏（half barrier），这是因为它们只能防止单方向的指令变序。<br></p>
</div>
</div>

<div id="outline-container-orgb67692b" class="outline-3">
<h3 id="orgb67692b">
<span class="section-number-3">3.2</span> 内存屏障与volatile关键字</h3>
<div class="outline-text-3" id="text-3-2">
<p>
内存屏障并不能保证数值的是“最新的”或“新鲜的”，它只能控制内存访问的相对顺序。<br></p>

<p>
volatile关键字值能通知编译器生成的输出码从内存中重新读取数据，但是不会告诉CPU在如何读取数据、在哪里读取数据。<br></p>
</div>
</div>
</div>


<div id="outline-container-orgf5a2a46" class="outline-2">
<h2 id="orgf5a2a46">
<span class="section-number-2">4</span> 操作原子化能够解决多进程访问共享内存的问题吗？</h2>
<div class="outline-text-2" id="text-4">
<p>
原子化操作是对于CPU而言的指令操作，它不关心线程还是进程，它只关心这一系列的指令是不可分割的。所以，进程间可以使用原子操作完成共享内存的操作同步。<br></p>
</div>
</div>


<div id="outline-container-org469bc60" class="outline-2">
<h2 id="org469bc60">
<span class="section-number-2">5</span> 参考资料</h2>
<div class="outline-text-2" id="text-5">
<ul class="org-ul">
<li>
<a href="https://en.wikipedia.org/wiki/Linearizability">Wikipedia - Linearizability</a><br>
</li>
<li>
<a href="https://gcc.gnu.org/onlinedocs/gcc-4.4.3/gcc/Atomic-Builtins.html">GNU GCC online docs</a><br>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Memory_barrier">Wikipedia - Memory Barrier</a><br>
</li>
<li>
<a href="https://stackoverflow.com/questions/1787450/how-do-i-understand-read-memory-barriers-and-volatile">stackoverflow - memory barrier and volatile</a><br>
</li>
<li>
<a href="https://stackoverflow.com/questions/8160348/lock-freedom-atomic-operations-across-2-processes-instead-of-threads">stackoverflow - atomic operation in multi process</a><br>
</li>
<li>
<a href="https://en.cppreference.com/w/cpp/atomic">cppreference - atomic</a><br>
</li>
</ul>
</div>
</div>
  </div>
  
  <ul class="tags-list vertical-center">
<li>
      <a class="badge" href="/tags/atomic/" rel="tag">atomic</a>
    </li>
    <li>
      <a class="badge" href="/tags/gcc/" rel="tag">gcc</a>
    </li>
    <li>
      <a class="badge" href="/tags/linux/" rel="tag">linux</a>
    </li>
    <li>
      <a class="badge" href="/tags/memory-barrier/" rel="tag">memory barrier</a>
    </li>
  </ul></article><ul class="post-pager hidden-print">
<li class="previous">
      <a href="/posts/2018/gdb-display-contents-of-memory-address/" rel="prev">Previous post
        <br><span>在gdb中查看指定内存地址的内容</span>
      </a>
    </li>
    <li class="next">
      <a href="/posts/2018/cpp-bit-field/" rel="next">Next post
        <br><span>C/C++中的位域</span>
      </a>
    </li>
  </ul>
<section class="comments hidden-print"><div id="disqus_thread"></div>
        <script>
        var disqus_shortname ="samsonwang-blog",
            disqus_url="https://blog.wangzhl.com/posts/2018/gcc-built-in-functions-for-atomic-memory-access/",
        disqus_title="GCC\u7684\u5185\u5b58\u539f\u5b50\u5316\u64cd\u4f5c\u51fd\u6570\u63a5\u53e3",
        disqus_identifier="_cache/posts/2018/gcc-built-in-functions-for-atomic-memory-access.html",
        disqus_config = function () {
            this.language = "en";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.async = true;
            dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript>
    <a href="https://disqus.com" class="dsq-brlink" rel="nofollow">Comments powered by <span class="logo-disqus">Disqus</span></a>


  </section><script>var disqus_shortname="samsonwang-blog";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script>
</div>
  </main><footer class="site-footer h-card"><div class="wrapper">
      <div class="footer-col-wrapper">

        <div class="footer-col">
          <p class="site-desc">Personal handnote on software development</p>
        </div>

        <div class="footer-col">
          <div class="p-name">Samson Wang</div>
          <div class="copyright">Copyright 2024, all rights reserved.</div>
          <div class="social-links">
            <ul class="social-media-list">
<li><a rel="me" href="/rss.xml">
                <svg class="svg-icon grey"><use href="/assets/svg/social-icons.svg#rss"></use></svg></a></li>
              <li><a rel="nofollow" href="https://github.com/samsonwang">
                <svg class="svg-icon grey"><use href="/assets/svg/social-icons.svg#github"></use></svg></a></li>
              <li><a rel="nofollow" href="https://twitter.com/samsonwangcn">
                <svg class="svg-icon grey"><use href="/assets/svg/social-icons.svg#twitter"></use></svg></a></li>
              <li><a rel="nofollow" href="https://facebook.com/samsonwangcn">
                 <svg class="svg-icon grey"><use href="/assets/svg/social-icons.svg#facebook"></use></svg></a></li>
            </ul>
</div>

        </div>

      </div>

    </div>

  </footer><div id="scroll-top" title="back to top">
  <div id="scroll-top-arrow"></div>
  <div id="scroll-top-stick"></div>
</div>


      <script src="/assets/js/lazyload.min.js"></script><script src="/assets/js/minima.min.js"></script><!-- google adsense --><script data-ad-client="ca-pub-6303134192857919" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- Google Analytics - Global site tag (gtag.js) --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-108507797-1"></script><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-108507797-1');
</script>
</body>
</html>
