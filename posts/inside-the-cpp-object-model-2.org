#+BEGIN_COMMENT
.. title: 深入探索C++内存模型（2）
.. slug: inside-the-cpp-object-model-2
.. date: 2019-03-25 15:52:36 UTC+08:00
.. tags: cpp, object model, memory layout, Lippman, digest
.. category: cpp
.. link:
.. description:
.. type: text
.. status: draft
#+END_COMMENT
#+OPTIONS: num:nil

#+TITLE: 深入探索C++内存模型（2）

构造函语意学主要针对构造函数在不同情况的底层实现细节。

{{{TEASER_END}}}

** 第二章 构造函数语意学 （the semantics of constructors）

*** 2.1 default constructor 的构建操作
关键词 =explicit= 之所以被导入这个语言，就是为了提供给程序员一种方法，使他们能够制止“单一参数的 constructor ”被当作一个 conversion 运算符。

默认构造函数在需要的时候被编译器产生出来。但是这个需要有两层含义，一个是程序员的需要，另一个是编译器的需要。
只有在编译器需要的时候，才会合成默认构造函数（default constructor）。此外，被合成出来的 constructor 只执行编译器所需的行动。

**** 带有 default constructor 的 member class object
如果一个 class 没有任何 constructor，但它内含一个有 default constructor 的 member object，那么这个 class 的 implicit default constructor 就是 “nontrivial” ，编译器需要为此 class 合成出一个 default constructor。不过这个合成操作只有在 constructor 真正需要被调用时才会发生。

**** 带有 default constructor 的 base class
如果一个没有任何 constructor 的 class 派生自一个“带有 default constructor”的 base class，那么这个 derived class 的 default constructor 会被视为 nontrivial，因此需要被合成出来。它将调用上一层 base classes 的 default consturctor（根据他们的声明顺序）。对于一个后继派生的class而言，这个合成的 constructor 和一个 “被明确提供的 default constructor” 没有什么异常。


**** 带有 virtual function 的 class
另有两种情况，也需要合成出 default constructor：
1. class 声明（或继承）一个 virtual function；
2. class 派生自一个继承串链，其中有一个或更多的 virtual base classes。

以下两个扩张会在编译期间发生：
1. 一个 virtual function table（vtbl） 会被编译器产生出来，用于存放 class 的 virtual functions 地址；
2. 在每一个 class object 中， 一个额外的 pointer member（vptr）会被编译器合成出来，内含相关的 class vtbl 的地址。

注意：虚函数表（vtbl）属于一个 class，而每个 object 中存放的是虚函数表的地址（vptr）。


**** 带有 virtual base class 的 class
virtual base class 的实现方法在不同的编译器之间有极大的差异。然而，每一种实现方法的共通点在于必须使 virtual base class 在其每一个 derived class object 中的位置能够于执行期准备妥当。（书中举出了cfront编译器的做法：在derived class object 的每一个 virtual base classes 安插一个指针。）对于 class 所定义的每一个 constructor，编译器会安插那些“允许每一个 virtual base class 的执行期存取操作”的代码。如果 class 没有声明任何 constructors，编译器必须为它合成一个 default constructor。


**** 总结
有四种情况，会导致“编译器必须为未声明 constructor 的 class 合成一个 default constructor”。C++ Standard 把那些合成物称为 implicit nontrivial default constructors。被合成出来的 constructor 只能满足编译器（而非程序）的需要。

在合成的 default constructor 中，只有 base class subobjects 和 member class objects 会被初始化，所有其他的 nonstatic data member，如整数、指针、数组等等都不会被初始化。这些初始化操作对程序而言或许有需要，但对编译器则并非必要。

C++新手一般有两个常见的误解：
1. 任何 class 如果没有定义 default constructor，就会被合成出一个来；
2. 编译器合成出来的 default constructor 会明确设定“class 内每一个 data member 的默认值”。
如你所见，没有一个是真的。


*** 2.2 copy constructor 的构建操作
有三种情况，会以一个 object 的内容作为另一个 class object 的初值：
1. 使用等号（“=”）明确地使用另一个object进行赋值
2. object 被当作参数交给（传递给）某个函数
3. 函数传回一个 class object （函数返回对象）

**** default memberwise initialization
如果 class 没有提供一个 explicit copy constructor 时，当 class object 以“相同 class 的另一个 object”作为初值时，其内部都是以所谓的 default memberwise initialization 手法完成的，也就是把每一个内建的或派生的 data member 的值，从某个 object 拷贝一份到另一个 object 身上，不过它并不会拷贝其中的 member class object，而是以递归的方式施行 memberwise initialization。

和以前一样，C++ Standard 把 copy constructor 区分为 trivial 和 nontrivial 两种，只有 nontrivial 的实体才会被合成于程序之中。而决定一个 copy constructor 是否为 trivial 的标准在于 class 是否展现初所谓的“bitwise copy semantics”。

**** bitwise copy semantics （位逐次拷贝）
一个 class 不展现出 “bitwise copy semantics” 的四种情况：
1. 当 class 内含一个 member object 而后者的 class 声明有一个 copy constructor 时 （不论时被 class 设计者明确地声明，或是被编译器合成）；
2. 当 class 继承一个 base class， 而后者存在有一个 copy constructor 时（不论是被声明或是被合成而得）；
3. 当 class 声明了一个或多个 virtual function 时；
4. 当 class 派生自一个继承串链，其中有一个或多个 virtual base class 时。

前面两种情况，编译器必须将 member 或 base class 的 copy constructor 调用操作安插到被合成的 copy constructor 中。而后面两种情况有点复杂，会在接下来的章节讨论。

**** 重新设定 virtual table 的指针
