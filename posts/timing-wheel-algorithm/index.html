<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns#" lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta http-equiv="x-ua-compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>时间轮算法 | Hack Note</title>
<meta name="theme-color" content="#04519b">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" href="/rss.xml">
<link href="/assets/css/minima.min.css" rel="stylesheet" type="text/css">
<link rel="canonical" href="https://blog.wangzhl.com/posts/timing-wheel-algorithm/">
<link rel="icon" href="/favicon.ico" sizes="64x64">
<link rel="prev" href="/posts/windows-system32-and-syswow64/" title="Windows平台下System32和SysWOW64文件夹" type="text/html">
<link rel="next" href="/posts/msvc-legacy-stdio/" title="MSVC的stdio版本适配问题" type="text/html">
<meta name="author" content="Samson Wang">
<meta property="og:site_name" content="Hack Note">
<meta property="og:title" content="时间轮算法">
<meta property="og:url" content="https://blog.wangzhl.com/posts/timing-wheel-algorithm/">
<meta property="og:description" content="在之前的一篇 文章 中谈到了定时器的基本实现原理，其中提到了几种定时器的调度算法。当需要处理的定时器越来越多时，那些调度策略就不再适合了。本篇文章可以看作是前面文章的拓展，主要展开讲时间轮算法的思路和它的变体。





为什么要使用时间轮算法


时间轮算法是为了应对定时器的数量越来越多的情况，在待处理定时器的总数达到几千个甚至上万个时，我们希望定时器的性能仍有保证，定时器的性能要从时间复杂度和">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2020-04-18T09:58:19+08:00">
<meta property="article:tag" content="algorithm">
<meta property="article:tag" content="timer">
<meta property="article:tag" content="timing wheel">
</head>
<body>
  <header class="site-header nav-custom"><div class="wrapper">
      <a class="site-title" rel="author" href="/">Hack Note</a>
      <nav class="site-nav"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger">
          <span class="menu-icon">
            <svg viewbox="0 0 18 15" width="18px" height="15px"><use href="/assets/svg/theme.svg#menu-icon"></use></svg></span>
        </label>
        <div class="trigger">
          
            <a class="page-link" href="/">Home</a>
            <a class="page-link" href="/archive/">Archive</a>
            <a class="page-link" href="/tags/">Tags</a>
            <a class="page-link" href="/about/">About</a>

        </div>
      </nav>
</div>
  </header><main class="page-content" aria-label="Content"><div class="wrapper">

    

    
<article class="post h-entry" itemscope="" itemtype="http://schema.org/BlogPosting"><header class="post-header"><h1 class="post-title p-name" itemprop="name headline">时间轮算法</h1>

    <p class="post-meta">
      
    <time class="dt-published" datetime="2020-04-18T09:58:19+08:00" itemprop="datePublished">Apr 18, 2020</time><span class="dt-updated"> / updated <time datetime="2020-05-08T20:45:19+08:00" itemprop="dateUpdated">May 08, 2020</time></span>

      

    </p>
  </header><div class="post-content e-content" itemprop="articleBody text">
    <p>
在之前的一篇 <a href="/posts/how-to-implement-a-timer/" class="post-url">文章</a> 中谈到了定时器的基本实现原理，其中提到了几种定时器的调度算法。当需要处理的定时器越来越多时，那些调度策略就不再适合了。本篇文章可以看作是前面文章的拓展，主要展开讲时间轮算法的思路和它的变体。<br></p>

<!-- TEASER_END -->

<div id="outline-container-orgc142ba7" class="outline-2">
<h2 id="orgc142ba7">为什么要使用时间轮算法</h2>
<div class="outline-text-2" id="text-orgc142ba7">
<p>
时间轮算法是为了应对定时器的数量越来越多的情况，在待处理定时器的总数达到几千个甚至上万个时，我们希望定时器的性能仍有保证，定时器的性能要从时间复杂度和空间复杂度两方面考虑。<br></p>

<p>
时间复杂度分析主要包括以下几种操作：<br></p>
<ul class="org-ul">
<li>定时器启动：定时器在启动时需要提供超时时间和超时回调函数，并且一般会返回一个用于标识定时器的id。<br>
</li>
<li>定时器取消：定时器在取消时将指定id的定时器移除。<br>
</li>
<li>定时器超时判断：超时判断会有一个检查周期（频率），在每次检查中会找出需要超时触发的定时器。<br>
</li>
</ul>
<p>
空间复杂度指定时器在存储时所消耗的内存，主要受存储时使用的数据结构影响。<br></p>

<p>
一般来讲，时间复杂度和空间复杂度是紧密联系在一起的，并且鱼和熊掌不可兼得，通常需要牺牲一方面性能换取另一方面性能的提升。很显然，定时器是一个对时间很敏感的功能，在定时器调度策略中，我们在考虑时倾向于牺牲空间性能换取时间性能。<br></p>
</div>
</div>

<div id="outline-container-orgc61465a" class="outline-2">
<h2 id="orgc61465a">基础时间轮算法</h2>
<div class="outline-text-2" id="text-orgc61465a">
<p>
在实现前需要假定所有定时器的超时时间（周期数量）都不会超过某个最大值 <code>N</code> ，这样我们可以用一个容量为 <code>N</code> 的环形链表存放定i时器，每个链表节点对应一个超时时间，将所有超时时间相同的定时器存放在同一个链表节点中。链表中有一个节点代表当前时间 <code>i</code> ，在每次执行检查时将当前时间 <code>i</code> 向前移动移动一个节点变成 <code>i+1</code> 节点， 这样 <code>i+1</code> 节点中的所有定时器就需要超时触发了。在添加一个超时时间为 <code>t</code> 新的定时器时，需要将其放在第 <code>(i+t)%N</code> 个节点中。<br></p>

<p>
举一个简单的例子，如下图所示，假设 <code>N</code> 为8且 <code>i</code> 为1，形象地讲就是最大超时时间为8秒，每一个小格代表1秒。在左面的图中，当前时间对应的第1格是第1秒，该节点中所有的定时器执行超时回调函数。在右面的图中，经过1秒后到达了下一个检查周期，即第2秒对应的第2格中的所有定时器超时触发，它们的回调函数会被执行。<br></p>

<p>
<img src="/assets/images/spinner.svg" data-src="/images/post-timing-wheel-algorithm-1.png" alt="nil"><br>
配图来源：<a href="https://www.confluent.io/blog/apache-kafka-purgatory-hierarchical-timing-wheels/">confluent.io</a><br></p>
</div>
</div>

<div id="outline-container-org2fef3cd" class="outline-2">
<h2 id="org2fef3cd">哈希时间轮算法</h2>
<div class="outline-text-2" id="text-org2fef3cd">
<p>
当最大超时时间 <code>N</code> 很大时，基础时间轮中的节点增多，这样会消耗很多内存。我们可以将相邻的定时器归为一组，将这一组作为一个时间轮节点。每次在定时器超时判断时只需关注当前节点中的那一组定时器。这种方法借鉴了哈希运算的思想，可以看作是一种广义上的哈希运算，就是将变化范围大的对象经过哈希函数映射到一个较小的范围。<br></p>

<p>
当然每个节点中定时器的组织方法可以有很多种，如：不排序的链表、排序的链表、优先队列，这部分的处理策略其实就是一个缩小版定时器调度处理。<br></p>
</div>
</div>

<div id="outline-container-org2b7018a" class="outline-2">
<h2 id="org2b7018a">分层时间轮算法</h2>
<div class="outline-text-2" id="text-org2b7018a">
<p>
分层时间轮算法可以看作是哈希时间轮算法的一个特例，即哈希时间轮中的每个节点中存放的仍然是时间轮。以我们生活中的常见的钟表为例：有24个节点表示小时，每个节点表示1小时；小时节点中有60个分钟节点，每个分钟节点表示1分钟；分钟节点中有60个秒节点，每个秒节点表示1秒。其中的时、分、秒就是将时间轮分为了3个层次。<br></p>
</div>
</div>

<div id="outline-container-orgdbed53d" class="outline-2">
<h2 id="orgdbed53d">算法演进的思路分析</h2>
<div class="outline-text-2" id="text-orgdbed53d">
<p>
上面提到的时间轮算法的几个变体是空间与时间转换的典型案例。为了使每次超时判断处理的速度变快，将定时器按照超时时间分开，这样每次只需要关注那一小部分快要超时的定时器，这是空间换时间。为了减少存储定时器所需要内存，将超时时间接近的放在一个节点中，这是时间换空间。而分层时间轮其实就是每层的节点中仍然是时间轮，这又使用是递归思想。仔细品味算法的设计思路，还真的是蛮有意思的。<br></p>
</div>
</div>

<div id="outline-container-orgeb11fdb" class="outline-2">
<h2 id="orgeb11fdb">时间轮算法的实现</h2>
<div class="outline-text-2" id="text-orgeb11fdb">
<p>
我找了几个时间轮算法的实现代码，不过没有深入研究，等以后有时间的时候再仔细看看：<br></p>
<ul class="org-ul">
<li>
<a href="https://github.com/skywind3000/AsyncNet/blob/master/system/itimer.h">github - skywind3000 AsyncNet</a><br>
</li>
<li>
<a href="https://github.com/wahern/timeout">github - wahern timeout</a><br>
</li>
</ul>
</div>
</div>

<div id="outline-container-org5fc820b" class="outline-2">
<h2 id="org5fc820b">参考资料</h2>
<div class="outline-text-2" id="text-org5fc820b">
<ul class="org-ul">
<li>
<a href="http://www.cs.columbia.edu/~nahum/w6998/papers/sosp87-timing-wheels.pdf">columbia edu - timing wheel</a><br>
</li>
<li>
<a href="https://blog.acolyer.org/2015/11/23/hashed-and-hierarchical-timing-wheels/">acolyer blog - hashed and hierarchical timing wheel</a><br>
</li>
</ul>
<p>
（全文完）<br></p>
</div>
</div>
  </div>
  
  <ul class="tags-list vertical-center">
<li>
      <a class="badge" href="/tags/algorithm/" rel="tag">algorithm</a>
    </li>
    <li>
      <a class="badge" href="/tags/timer/" rel="tag">timer</a>
    </li>
    <li>
      <a class="badge" href="/tags/timing-wheel/" rel="tag">timing wheel</a>
    </li>
  </ul></article><ul class="post-pager hidden-print">
<li class="previous">
      <a href="/posts/windows-system32-and-syswow64/" rel="prev">Previous post
        <br><span>Windows平台下System32和SysWOW64文件夹</span>
      </a>
    </li>
    <li class="next">
      <a href="/posts/msvc-legacy-stdio/" rel="next">Next post
        <br><span>MSVC的stdio版本适配问题</span>
      </a>
    </li>
  </ul>
<section class="comments hidden-print"><div id="disqus_thread"></div>
        <script>
        var disqus_shortname ="samsonwang-blog",
            disqus_url="https://blog.wangzhl.com/posts/timing-wheel-algorithm/",
        disqus_title="\u65f6\u95f4\u8f6e\u7b97\u6cd5",
        disqus_identifier="_cache/archives/2020/timing-wheel-algorithm.html",
        disqus_config = function () {
            this.language = "en";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.async = true;
            dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript>
    <a href="https://disqus.com" class="dsq-brlink" rel="nofollow">Comments powered by <span class="logo-disqus">Disqus</span></a>


  </section><script>var disqus_shortname="samsonwang-blog";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script>
</div>
  </main><footer class="site-footer h-card"><div class="wrapper">
      <div class="footer-col-wrapper">

        <div class="footer-col">
          <p class="site-desc">Personal handnote on software development</p>
        </div>

        <div class="footer-col">
          <div class="p-name">Samson Wang</div>
          <div class="copyright">Copyright 2021, all rights reserved.</div>
          <div class="social-links">
            <ul class="social-media-list">
<li><a rel="me" href="/rss.xml">
                <svg class="svg-icon grey"><use href="/assets/svg/social-icons.svg#rss"></use></svg></a></li>
              <li><a rel="nofollow" href="https://github.com/samsonwang">
                <svg class="svg-icon grey"><use href="/assets/svg/social-icons.svg#github"></use></svg></a></li>
              <li><a rel="nofollow" href="https://twitter.com/samsonwangcn">
                <svg class="svg-icon grey"><use href="/assets/svg/social-icons.svg#twitter"></use></svg></a></li>
              <li><a rel="nofollow" href="https://facebook.com/samsonwangcn">
                 <svg class="svg-icon grey"><use href="/assets/svg/social-icons.svg#facebook"></use></svg></a></li>
            </ul>
</div>

        </div>

      </div>

    </div>

  </footer><div id="scroll-top" title="back to top">
  <div id="scroll-top-arrow"></div>
  <div id="scroll-top-stick"></div>
</div>


      <script src="/assets/js/lazyload.min.js"></script><script src="/assets/js/minima.min.js"></script><!-- google adsense --><script data-ad-client="ca-pub-6303134192857919" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- Google Analytics - Global site tag (gtag.js) --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-108507797-1"></script><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-108507797-1');
</script><!-- baidu tongji --><script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?1dcffb5494ab56e69005c957d7320ad1";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>
</body>
</html>
