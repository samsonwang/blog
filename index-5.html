<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#" lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="Personal handnote on software development">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Hack Note (old posts, page 5) | Hack Note</title>
<link href="/assets/css/bootstrap.min.css" rel="stylesheet" type="text/css">
<link href="/assets/css/font-awesome.min.css" rel="stylesheet" type="text/css">
<link href="/assets/css/code.css" rel="stylesheet" type="text/css">
<link href="/assets/css/colorbox.css" rel="stylesheet" type="text/css">
<link href="/assets/css/highlight.css" rel="stylesheet" type="text/css">
<link href="/assets/css/cerulean.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="en" href="/rss.xml">
<link rel="canonical" href="https://samsonwang.me/index-5.html">
<link rel="icon" href="/favicon.ico" sizes="64x64">
<link rel="prev" href="/index-4.html" type="text/html">
<link rel="next" href="/index-6.html" type="text/html">
<!--[if lt IE 9]><script src="/assets/js/html5.js"></script><![endif]-->
</head>
<body class="preload">
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->
<nav id="top-nav" class="navbar navbar-expand-md fixed-top mb-4 navbar-dark bg-dark"><div class="container">   <!-- This keeps the margins nice -->
    <a class="navbar-brand" href="https://samsonwang.me/">

      <span id="blog-title">Hack Note</span>
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div class="collapse navbar-collapse" id="bs-navbar">
      <ul class="navbar-nav ml-auto">
<li class="nav-item">
<a href="/archive/" class="nav-link">Archives</a>
                </li>
<li class="nav-item">
<a href="/tags/" class="nav-link">Tags</a>
                </li>
<li class="nav-item">
<a href="/rss.xml" class="nav-link">RSS Feed</a>

        
      </li>
</ul>
<ul class="navbar-nav navbar-right"></ul>
</div>
<!-- /.navbar-collapse -->
  </div>
<!-- /.container -->
</nav><!-- End of Menubar --><div class="container" id="content" role="main">
  <div class="body-content">
    <!--Body content-->
    <div class="row">

      <div class="col-lg-9 col-md-9 col-sm-12 col-xs-12">
        
        


  



  


<div class="postindex">


  <article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/linux-command-examples-ipcs/" class="u-url">Linux常用命令行指令 - ipcs</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-04-25T21:37:51+08:00" itemprop="datePublished" title="2018-04-25 21:37">Apr 25 2018  (21:37)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/linux-command-examples-ipcs/#disqus_thread" data-disqus-identifier="cache/archives/2018/linux-command-examples-ipcs.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/ipc/" rel="tag">ipc</a></li>
        <li><a class="tag p-category" href="/tags/linux/" rel="tag">linux</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <p>
<code>IPC</code> 是 <code>inter process communication</code> 的缩写，这项技术能够让进程间相互通信。<br>
Q：每个进程都有自己的地址空间和独立的用户空间，那么进程间是如何通信的呢？<br>
A：内核，也就是操作系统的心脏，它能够访问整个操作系统的内存。我们可以要求内核分配一块用于进程间交互的空间。<br></p>

<div id="outline-container-org15762ea" class="outline-2">
<h2 id="org15762ea">几种进程间通信的方法</h2>
<div class="outline-text-2" id="text-org15762ea">
<p>
进程间通信的方法有很多，有些支持同机器上进程的信息交互，有些支持跨机器的进程交互。<br></p>
<ul class="org-ul">
<li>
<b>管道</b> ： pipes，管道提供了进程间交换信息的方法。<br>
</li>
<li>
<b>共享内存</b> ： shared memory，一个进程创建一块其他进程能够访问的内存空间，多个进程可以通过共享内存进行数据交换。<br>
</li>
<li>
<b>消息队列</b> ： message queue，消息队列是一个固定结构、有序的内存段，多个进程可以存放和取回数据。<br>
</li>
<li>
<b>信号量</b> ： semaphores，信号量提供了多进程访问同一资源的同步机制，信号量不负责传递数据，它协调对共享资源的访问。<br>
</li>
</ul>
</div>
</div>

<div id="outline-container-org24ade9f" class="outline-2">
<h2 id="org24ade9f">常用ipcs指令</h2>
<div class="outline-text-2" id="text-org24ade9f">
<p>
<b>列出所有的IPC设备</b><br></p>
<div class="highlight"><pre><span></span>ipcs -a
</pre></div>

<p>
<b>列出所有的消息队列</b><br></p>
<div class="highlight"><pre><span></span>ipcs -q
</pre></div>

<p>
<b>列出所有的信号量</b><br></p>
<div class="highlight"><pre><span></span>ipcs -s
</pre></div>

<p>
<b>列出所有的共享内存</b><br></p>
<div class="highlight"><pre><span></span>ipcs -m
</pre></div>

<p>
<b>获取与IPC设备信息</b><br></p>
<div class="highlight"><pre><span></span>ipcs -q -i msq_id
</pre></div>

<p>
<b>列出IPC设备的限制</b><br></p>
<div class="highlight"><pre><span></span>ipcs -l
</pre></div>

<p>
<b>列出IPC设备的创建者和拥有者</b><br></p>
<div class="highlight"><pre><span></span>ipcs -m -c
</pre></div>

<p>
<b>列出最近使用IPC设备的进程id</b><br></p>
<div class="highlight"><pre><span></span>ipcs -m -p
</pre></div>

<p>
<b>列出IPC设备的最后访问时间</b><br></p>
<div class="highlight"><pre><span></span>ipcs -s -t
</pre></div>

<p>
<b>列出IPC设备的当前使用状态</b><br></p>
<div class="highlight"><pre><span></span>ipcs -u
</pre></div>
</div>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/debug-with-gdb-on-multi-thread-programs/" class="u-url">使用gdb调试多线程程序</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-04-20T21:25:09+08:00" itemprop="datePublished" title="2018-04-20 21:25">Apr 20 2018  (21:25)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/debug-with-gdb-on-multi-thread-programs/#disqus_thread" data-disqus-identifier="cache/archives/2018/debug-with-gdb-on-multi-thread-programs.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/gdb/" rel="tag">gdb</a></li>
        <li><a class="tag p-category" href="/tags/linux/" rel="tag">linux</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <div id="outline-container-org7a1cb74" class="outline-2">
<h2 id="org7a1cb74">查看当前线程信息</h2>
<div class="outline-text-2" id="text-org7a1cb74">
<p>
<b>将进程中的各个线程信息显示出来</b><br></p>
<div class="highlight"><pre><span></span>(gdb) info threads
</pre></div>

<p>
<b>切换到指定进程</b><br></p>
<div class="highlight"><pre><span></span>(gdb) thread tid
</pre></div>

<p>
<b>向指定的线程发送自定的指令</b><br></p>
<div class="highlight"><pre><span></span>(gdb) thread apply tid/all args
</pre></div>
<p>
常用的指定是查看所有线程的调用堆栈 <code>thread apply all bt</code> ，这个指令与 <code>pstack</code> 命令有些相似。<br></p>

<p>
<b>gdb默认会自动捕捉新产生线程</b><br>
会在产生一个新的线程时会显示出LWP的字样提示用户，LWP = light weight process<br>
可以设置gdb是否提示线程相关的事件<br></p>
<div class="highlight"><pre><span></span>(gdb) set print thread-events on/off
(gdb) show print thread-events
</pre></div>
</div>
</div>

<div id="outline-container-org79783a0" class="outline-2">
<h2 id="org79783a0">为指定的线程设置断点</h2>
<div class="outline-text-2" id="text-org79783a0">
<p>
含有多线程的程序，可以为单独的线程设置断点<br></p>
<div class="highlight"><pre><span></span>(gdb) break linespec thread tid
</pre></div>

<p>
任何时候当你的程序在GDB模式下停止的时候，包括当前调试线程的所有线程都会停下来，不会对继续对当前进程造成更改。这时你可以在线程间进行切换，查看整个进程的执行状况。<br></p>
<blockquote>
<p>
Whenever your program stops under GDB for any reason, all threads of execution stop, not just the current thread. This allows you to examine the overall state of the program, including switching between threads, without worrying that things may change underfoot.<br></p>
</blockquote>
</div>
</div>

<div id="outline-container-org9a3da7c" class="outline-2">
<h2 id="org9a3da7c">防止gdb自动切换线程</h2>
<div class="outline-text-2" id="text-org9a3da7c">
<p>
在调试gdb程序时，在单步执行时，会出现线程间跳转切换，这样对跟踪代码执行状态十分不方便。<br>
可以通过设置 <code>scheduler-locking</code> 让gdb在所调试的线程中运行，防止线程的自动切换。<br></p>
<div class="highlight"><pre><span></span>(gdb) set scheduler-locking step
</pre></div>
<p>
可以执行以下命令查看当前 <code>scheduler-locking</code> 的设置<br></p>
<div class="highlight"><pre><span></span>(gdb) show scheduler-locking
</pre></div>
<p>
<code>scheduler-locking</code> 有三种模式<br></p>
<ol class="org-ol">
<li>
<code>off</code> 任何线程在任何时候都能执行<br>
</li>
<li>
<code>on</code> 只有当前线程能够执行<br>
</li>
<li>
<code>step</code> 为单步执行优化的模式，比较适合一般的调试<br>
</li>
</ol>
<blockquote>
<p>
Set the scheduler locking mode. If it is off, then there is no locking and any thread may run at any time. If on, then only the current thread may run when the inferior is resumed. The step mode optimizes for single-stepping. It stops other threads from "seizing the prompt" by preempting the current thread while you are stepping. Other threads will only rarely (or never) get a chance to run when you step. They are more likely to run when you `next' over a function call, and they are completely free to run when you use commands like `continue', `until', or `finish'. However, unless another thread hits a breakpoint during its timeslice, they will never steal the GDB prompt away from the thread that you are debugging.<br></p>
</blockquote>
</div>
</div>


<div id="outline-container-org1a9999b" class="outline-2">
<h2 id="org1a9999b">参考资料</h2>
<div class="outline-text-2" id="text-org1a9999b">
<ol class="org-ol">
<li>
<a href="https://ftp.gnu.org/old-gnu/Manuals/gdb/html_node/gdb_39.html">gnu manual 1</a><br>
</li>
<li>
<a href="https://ftp.gnu.org/old-gnu/Manuals/gdb/html_node/gdb_24.html">gun manual 2</a><br>
</li>
<li>
<a href="https://sourceware.org/gdb/onlinedocs/gdb/Threads.html">sourceware gdb onlinedocs</a><br>
</li>
<li>
<a href="http://www.drdobbs.com/cpp/multithreaded-debugging-techniques/199200938?pgno=1">drdobbs.com</a><br>
</li>
</ol>
</div>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/gdb-ignore-received-signal/" class="u-url">在gdb调试时忽略系统信号（signal）</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-04-19T16:00:47+08:00" itemprop="datePublished" title="2018-04-19 16:00">Apr 19 2018  (16:00)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/gdb-ignore-received-signal/#disqus_thread" data-disqus-identifier="cache/archives/2018/gdb-ignore-received-signal.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/gdb/" rel="tag">gdb</a></li>
        <li><a class="tag p-category" href="/tags/linux/" rel="tag">linux</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <p>
在gdb调试程序时，默认情况下gdb在收到信号时会中断程序的运行，并将收到的信号显示出来。这时，可以选择输入 <code>c</code> ( <code>continue</code> )让程序继续运行。如果程序会重复收到这信号，会非常影响调试效率。可以通过配置忽略指定的系统信号。<br>
查看当前系统信号的处理信息的指令<br></p>
<div class="highlight"><pre><span></span>(gdb) info signal
</pre></div>

<p>
以调试网络程序为例，进程会经常收到 <code>SIGPIPE</code> 消息，对于网络进程的 <code>SIGPIPE</code> 消息在程序中会由自身处理，可以使用以下指令让gdb不再提示 <code>SIGPIPE</code> 信号。<br></p>
<div class="highlight"><pre><span></span>(gdb) handle SIGPIPE nostop noprint
</pre></div>

<p>
参考资料： <a href="ftp://ftp.gnu.org/old-gnu/Manuals/gdb/html_node/gdb_38.html">gnu gdb manual</a><br></p>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/cpp11-range-based-for-loop/" class="u-url">C++11新特性：基于范围的for循环</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-04-18T09:45:42+08:00" itemprop="datePublished" title="2018-04-18 09:45">Apr 18 2018  (09:45)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/cpp11-range-based-for-loop/#disqus_thread" data-disqus-identifier="cache/archives/2018/cpp11-range-based-for-loop.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/cpp/" rel="tag">cpp</a></li>
        <li><a class="tag p-category" href="/tags/cpp11/" rel="tag">cpp11</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <p>
<b>在C++11中，介绍了一种新的for循环写法，基于范围的for循环。</b><br>
与旧的for循环类似，也是用来对遍历容器中的所有元素，新的写法更加简洁方便。可以使用auto自动适配容器中的内容。为了遍历容器时提高效率，在访问容器内部时可以声明为元素的引用，进而避免不必要的对象拷贝。示例代码如下（代码节选自 <a href="http://en.cppreference.com/w/cpp/language/range-for">cppreferance</a>）<br></p>
<div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
<span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">v</span><span class="p">)</span> <span class="c1">// access by const reference</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">v</span><span class="p">)</span> <span class="c1">// access by value, the type of i is int</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">n</span> <span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">})</span> <span class="c1">// the initializer may be a braced-init-list</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">a</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">n</span> <span class="p">:</span> <span class="n">a</span><span class="p">)</span> <span class="c1">// the initializer may be an array</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">n</span> <span class="p">:</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span><span class="p">;</span> <span class="c1">// the loop variable need not be used</span>
<span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
</pre></div>

<p>
<b>注意 <code>std::map</code> 的范围for循环遍历的写法</b><br><code>std::map</code> 中存放的是 <code>key-value pair</code> 键值对，所以在遍历的时候每次拿到的是一个 <code>pair</code> ，在访问其中的元素时，需要注意书写方法。示例代码如下。<br></p>
<div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">mapDemo</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">kvp</span> <span class="p">:</span> <span class="n">mapDemo</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">kvp</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">" - "</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">kvp</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/linux-command-examples-scp/" class="u-url">Linux常用命令行指令 - scp</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-04-17T16:08:06+08:00" itemprop="datePublished" title="2018-04-17 16:08">Apr 17 2018  (16:08)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/linux-command-examples-scp/#disqus_thread" data-disqus-identifier="cache/archives/2018/linux-command-examples-scp.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/linux/" rel="tag">linux</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <p>
<code>scp</code> 命令代表的是 secure copy，与 <code>cp</code> 命令的本地拷贝十分相似，主要区别就在于 <code>scp</code> 的路径可以是一个远程机器的路径。使用 <code>scp</code> 进行文件拷贝时，文件的传输时加密的。<br></p>
<div class="highlight"><pre><span></span>cp source_path dest_path
</pre></div>

<div id="outline-container-org4a2c693" class="outline-2">
<h2 id="org4a2c693">从远程机器向本地拷贝</h2>
<div class="outline-text-2" id="text-org4a2c693">
<p>
以下命令会把 <code>host</code> 主机上的 <code>src_path</code> 文件拷贝到本地 <code>dest_path</code> 目录中。<br></p>
<div class="highlight"><pre><span></span>scp user@host:src_path dest_path
</pre></div>
</div>
</div>

<div id="outline-container-orga0e4da4" class="outline-2">
<h2 id="orga0e4da4">从本地向远程机器拷贝</h2>
<div class="outline-text-2" id="text-orga0e4da4">
<p>
以下命令会把本地 <code>src_path</code> 的文件拷贝打 <code>host</code> 主机上的 <code>dest_path</code> 路径上。<br></p>
<div class="highlight"><pre><span></span>scp src_path user@host:dest_path
</pre></div>
</div>
</div>

<div id="outline-container-org9da03a3" class="outline-2">
<h2 id="org9da03a3">拷贝目录下的所有文件</h2>
<div class="outline-text-2" id="text-org9da03a3">
<p>
可以使用 <code>-r</code> 参数完成目录的递归拷贝， <code>r</code> 代表 <code>recursive</code> 递归。<br></p>
<div class="highlight"><pre><span></span>scp -r user@host:/src_path dest_path
</pre></div>
</div>
</div>

<div id="outline-container-org2c78f24" class="outline-2">
<h2 id="org2c78f24">在拷贝时限制带宽</h2>
<div class="outline-text-2" id="text-org2c78f24">
<p>
可以使用 <code>-l</code> 参数限制传输的带宽， <code>l</code> 代表 <code>limit</code> 限制，限制带宽的单位是 <code>kbps</code> 。<br>
命令会在将拷贝传输的速度限制为 100kbps。<br></p>
<div class="highlight"><pre><span></span>scp -l 100 src_path dest_path
</pre></div>
</div>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/cpp11-automatic-deduction-and-decltype/" class="u-url">C++11新特性：自动类型推导</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-04-16T08:44:40+08:00" itemprop="datePublished" title="2018-04-16 08:44">Apr 16 2018  (08:44)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/cpp11-automatic-deduction-and-decltype/#disqus_thread" data-disqus-identifier="cache/archives/2018/cpp11-automatic-deduction-and-decltype.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/cpp/" rel="tag">cpp</a></li>
        <li><a class="tag p-category" href="/tags/cpp11/" rel="tag">cpp11</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <div id="outline-container-orgf70797d" class="outline-2">
<h2 id="orgf70797d">关键字 <code>auto</code> 用于自动类型推导</h2>
<div class="outline-text-2" id="text-orgf70797d">
<div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>     <span class="c1">// int</span>
<span class="k">auto</span> <span class="n">c</span><span class="o">=</span><span class="sc">'a'</span><span class="p">;</span>   <span class="c1">// char</span>
<span class="k">auto</span> <span class="n">d</span><span class="o">=</span><span class="mf">0.5</span><span class="p">;</span>   <span class="c1">// double</span>
</pre></div>

<p>
自动类型推导主要用于声明比较复杂的变量，或者变量是在泛型编程（模板）中自动生成出来的。<br></p>
<div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vecNumbers</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">vecNumbers</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
<span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">vecNumbers</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
</pre></div>
</div>
</div>

<div id="outline-container-org43095d9" class="outline-2">
<h2 id="org43095d9">
<code>auto</code> 类型推导并不会指定 <code>const</code> 和 <code>volatile</code> 属性</h2>
<div class="outline-text-2" id="text-org43095d9">
<p>
如果需要限定声明的变量为 <code>const</code> 和 <code>volatile</code> 属性，需要额外提供相应的关键字限定。因为编译器并不能推断出声明的变量是否具有常值属性和易失属性。<br></p>
<div class="highlight"><pre><span></span><span class="k">volatile</span> <span class="k">auto</span> <span class="n">num</span><span class="o">=</span><span class="mi">5</span><span class="p">;</span>           <span class="c1">// volatile int</span>
<span class="k">auto</span> <span class="k">volatile</span> <span class="k">const</span> <span class="n">var</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>  <span class="c1">//const valatile bool</span>
<span class="k">auto</span> <span class="k">const</span> <span class="n">ch</span><span class="o">=</span><span class="sc">'a'</span><span class="p">;</span>             <span class="c1">// const char</span>
</pre></div>
</div>
</div>

<div id="outline-container-orgb639b9b" class="outline-2">
<h2 id="orgb639b9b">关键字 <code>decltype</code> 用于获取一个对量的类型</h2>
<div class="outline-text-2" id="text-orgb639b9b">
<p>
使用 <code>decltype</code> 存储一个对象或表达式的类型， <code>decltype</code> 可以看做是 <code>auto</code> 的补充。<br></p>
<div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vecNumbers</span><span class="p">;</span>
<span class="k">typedef</span> <span class="nf">decltype</span><span class="p">(</span><span class="n">vecNumbers</span><span class="p">.</span><span class="n">begin</span><span class="p">())</span> <span class="n">Iterator</span><span class="p">;</span>
<span class="n">Iterator</span> <span class="n">it2</span><span class="p">;</span>
</pre></div>
</div>
</div>

<div id="outline-container-org38a23a8" class="outline-2">
<h2 id="org38a23a8">函数返回值类型推导</h2>
<div class="outline-text-2" id="text-org38a23a8">
<p>
在C++11中可以使用 <code>auto</code> 和 <code>decltype</code> 完成函数返回类型的推导。<br>
旧的函数声明格式 <code>return_type func_name(param_type param, ...);</code><br>
新的函数声明格式示例如下，以下函数接收 <code>bool</code> 作为函数的参数，并返回 <code>bool</code> 类型的结果。<br></p>
<div class="highlight"><pre><span></span><span class="k">auto</span> <span class="nf">func_name</span><span class="p">(</span><span class="kt">bool</span> <span class="n">bParam</span><span class="p">)</span><span class="o">-&gt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">bParam</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">bParam</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>
函数返回值类型推导在模板泛型编程中非常有用，模板函数能够定义一个通用的返回类型，返回值类型会根据 <code>decltype</code> 自动推导。<br>
新的函数声明格式更易于维护，因为返回值并没有作为硬编码写入源文件中，但这样做可能会牺牲代码的可读性。<br></p>
<div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">get_end</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vecNumbers</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">get_end</span><span class="p">(</span><span class="n">vecNumbers</span><span class="p">);</span>      <span class="c1">// returns iterator</span>

<span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vecNumbers2</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">it2</span> <span class="o">=</span> <span class="n">get_enm</span><span class="p">(</span><span class="n">vecNumbers2</span><span class="p">);</span>    <span class="c1">// returns const_iterator</span>
</pre></div>
</div>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/fifo-pipe-unix-domain-socket/" class="u-url">Linux下的FIFO、pipe、unix domain socket漫谈</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-04-11T13:03:25+08:00" itemprop="datePublished" title="2018-04-11 13:03">Apr 11 2018  (13:03)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/fifo-pipe-unix-domain-socket/#disqus_thread" data-disqus-identifier="cache/archives/2018/fifo-pipe-unix-domain-socket.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/fifo/" rel="tag">fifo</a></li>
        <li><a class="tag p-category" href="/tags/ipc/" rel="tag">ipc</a></li>
        <li><a class="tag p-category" href="/tags/linux/" rel="tag">linux</a></li>
        <li><a class="tag p-category" href="/tags/pipe/" rel="tag">pipe</a></li>
        <li><a class="tag p-category" href="/tags/socket/" rel="tag">socket</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <div>
<p>
在做Linux开发时，经常会接触 <code>管道</code> 、 <code>AF_UNIX</code> 等相关词汇，为了弄清他们之间的关系，查阅了一些资料，将结果整理并记录下来。<br></p>

<p class="more"><a href="/posts/fifo-pipe-unix-domain-socket/">Read more…</a></p>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/debug-with-gdb-on-linux-2/" class="u-url">Linux下使用gdb的调试技巧（2）</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-04-03T22:51:39+08:00" itemprop="datePublished" title="2018-04-03 22:51">Apr 03 2018  (22:51)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/debug-with-gdb-on-linux-2/#disqus_thread" data-disqus-identifier="cache/archives/2018/debug-with-gdb-on-linux-2.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/gdb/" rel="tag">gdb</a></li>
        <li><a class="tag p-category" href="/tags/linux/" rel="tag">linux</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <div>
<p>
本文重点介绍在gdb模式下的常用命令。<br></p>

<p class="more"><a href="/posts/debug-with-gdb-on-linux-2/">Read more…</a></p>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/change-linux-timezone-with-cli/" class="u-url">使用命令行修改Linux系统的时区</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-04-03T21:32:42+08:00" itemprop="datePublished" title="2018-04-03 21:32">Apr 03 2018  (21:32)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/change-linux-timezone-with-cli/#disqus_thread" data-disqus-identifier="cache/archives/2018/change-linux-timezone-with-cli.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/linux/" rel="tag">linux</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <p>
<b>系统时区目录</b> 系统支持时区的配置文件存放在 <code>/usr/share/zoneinfo/</code> 目录下，可以进入到该目录下查看和搜索目标时区的相关配置文件。<br></p>

<p>
<b>时区配置文件</b> Linux系统的当前时区配置文件存放在 <code>/etc/localtime</code> , 可以将时区配置文件拷贝到该位置下，也可以建立一个软连接指向系统时区目录中的配置文件。<br></p>

<p>
<b>操作示例</b> 以将系统的时区改为中国时间为例，以下操作先将旧的时区配置文件删掉，然后建立新的时区配置文件的符号链接。<br></p>
<div class="highlight"><pre><span></span>rm /etc/localtime
ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
</pre></div>
<p>
完成以上操作后，可以执行 <code>date</code> 命令查看修改效果。<br></p>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/linux-command-examples-netstat/" class="u-url">Linux常用命令行指令 - netstat</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-03-28T22:55:16+08:00" itemprop="datePublished" title="2018-03-28 22:55">Mar 28 2018  (22:55)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/linux-command-examples-netstat/#disqus_thread" data-disqus-identifier="cache/archives/2018/linux-command-examples-netstat.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/linux/" rel="tag">linux</a></li>
        <li><a class="tag p-category" href="/tags/network/" rel="tag">network</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <p>
常见的选项有：<br>
-a (all)显示所有选项，netstat默认不显示LISTEN相关<br>
-t (tcp)仅显示tcp相关选项<br>
-u (udp)仅显示udp相关选项<br>
-n 拒绝显示别名，能显示数字的全部转化成数字。(重要)<br>
-l 仅列出有在 Listen (监听) 的服务状态<br>
-p 显示建立相关链接的程序名(macOS中表示协议 -p protocol)<br>
-r 显示路由信息，路由表<br>
-e 显示扩展信息，例如uid等<br>
-s 按各个协议进行统计 (重要)<br>
-c 每隔一个固定时间，执行该netstat命令。<br></p>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/linux-command-examples-tcpdump/" class="u-url">Linux常用命令行指令 - tcpdump</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-03-25T23:34:53+08:00" itemprop="datePublished" title="2018-03-25 23:34">Mar 25 2018  (23:34)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/linux-command-examples-tcpdump/#disqus_thread" data-disqus-identifier="cache/archives/2018/linux-command-examples-tcpdump.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/linux/" rel="tag">linux</a></li>
        <li><a class="tag p-category" href="/tags/network/" rel="tag">network</a></li>
        <li><a class="tag p-category" href="/tags/shell/" rel="tag">shell</a></li>
        <li><a class="tag p-category" href="/tags/tcpdump/" rel="tag">tcpdump</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <p>
tcpdump常用于网络抓包，能够将抓取的包保存下来，这样就能进一步深入分析。抓包保存的文件可以使用tcpdump进行查看，也可以借助第三方软件（如wireshark）进行辅助分析。<br></p>

<div id="outline-container-org77689dd" class="outline-2">
<h2 id="org77689dd">1. 抓取指定网络设备上的包</h2>
<div class="outline-text-2" id="text-org77689dd">
<p>
抓取网卡eth0上的包<br></p>
<div class="highlight"><pre><span></span>tcpdump -i eth0
</pre></div>
</div>
</div>
<div id="outline-container-org4d1d64b" class="outline-2">
<h2 id="org4d1d64b">2. 限制抓包的数量</h2>
<div class="outline-text-2" id="text-org4d1d64b">
<p>
只抓取5个包<br></p>
<div class="highlight"><pre><span></span>tcpdump -c 5 -i eth0
</pre></div>
</div>
</div>
<div id="outline-container-org5f0d63b" class="outline-2">
<h2 id="org5f0d63b">3. 将抓取的包以ASCII的方式打印出来</h2>
<div class="outline-text-2" id="text-org5f0d63b">
<div class="highlight"><pre><span></span>tcpdump -A -i eth0
</pre></div>
</div>
</div>
<div id="outline-container-org0c8b705" class="outline-2">
<h2 id="org0c8b705">4. 将抓取的包以十六进制的方式打印出来</h2>
<div class="outline-text-2" id="text-org0c8b705">
<div class="highlight"><pre><span></span>tcpdump -XX -i eth0
</pre></div>
</div>
</div>
<div id="outline-container-orgc905444" class="outline-2">
<h2 id="orgc905444">5. 对抓取到的包上打出更方便阅读的时间戳</h2>
<div class="outline-text-2" id="text-orgc905444">
<p>
增加 <code>-t</code> 参数能够将抓取到的包中的时间以方便阅读的形式打印出来，使用 <code>-tttt</code> 参数能够将包中的时间戳以更详细的方式打印出来。<br></p>
<div class="highlight"><pre><span></span>tcpdump -t -i eth0
tcpdump -tttt -i eth0
</pre></div>
</div>
</div>
<div id="outline-container-org41194b8" class="outline-2">
<h2 id="org41194b8">6. 将抓取的包写入到文件中</h2>
<div class="outline-text-2" id="text-org41194b8">
<div class="highlight"><pre><span></span>tcpdump -w netdump.pcap -i eth0
</pre></div>
</div>
</div>
<div id="outline-container-org03beb68" class="outline-2">
<h2 id="org03beb68">7. 读取抓到的包</h2>
<div class="outline-text-2" id="text-org03beb68">
<div class="highlight"><pre><span></span>tcpdump -r netdump.pcap
</pre></div>
</div>
</div>
<div id="outline-container-org537d00d" class="outline-2">
<h2 id="org537d00d">8. 在抓到的包中显示ip地址</h2>
<div class="outline-text-2" id="text-org537d00d">
<p>
增加 <code>-n</code> 参数不会解析主机名，增加 <code>-nn</code> 参数不会解析主机名和端口名<br></p>
<div class="highlight"><pre><span></span>tcpdump -n -i eth0
tcpdump -nn -i eth0
</pre></div>
</div>
</div>
<div id="outline-container-orgb4a1f77" class="outline-2">
<h2 id="orgb4a1f77">9. 以绝对值显示包的ISN号</h2>
<div class="outline-text-2" id="text-orgb4a1f77">
<div class="highlight"><pre><span></span>tcpdump -S -i eth0
</pre></div>
</div>
</div>
<div id="outline-container-orgd2e93da" class="outline-2">
<h2 id="orgd2e93da">10. 对抓取到的包显示更详细的信息</h2>
<div class="outline-text-2" id="text-orgd2e93da">
<p>
参数 <code>-v</code> 是verbose的缩写，以下命令表示对抓取到的包显示更详细的信息。<br></p>
<div class="highlight"><pre><span></span>tcpdump -v -i eth0
tcpdump -vv -i eth0
tcpdump -vvv -i eth0
</pre></div>
</div>
</div>
<div id="outline-container-org1a8ba85" class="outline-2">
<h2 id="org1a8ba85">11. 对抓到的包进行协议类型过滤</h2>
<div class="outline-text-2" id="text-org1a8ba85">
<p>
支持的协议类型有：fddi, tr, wlan, ip, ip6, arp, rarp, decnet, tcp, udp<br>
以下命令只会抓取网卡eth0上的arp包<br></p>
<div class="highlight"><pre><span></span>tcpdump -i eth0 arp
</pre></div>
</div>
</div>
<div id="outline-container-orga219030" class="outline-2">
<h2 id="orga219030">12. 在抓包时对包进行大小过滤</h2>
<div class="outline-text-2" id="text-orga219030">
<p>
下面的命令会分别抓取大于1024字节和小于1024字节的包<br></p>
<div class="highlight"><pre><span></span>tcpdump -i eth0 greater 1024
tcpdump -i eth0 less 1024
</pre></div>
</div>
</div>
<div id="outline-container-orga11b234" class="outline-2">
<h2 id="orga11b234">13. 抓取指定端口上的包</h2>
<div class="outline-text-2" id="text-orga11b234">
<div class="highlight"><pre><span></span>tcpdump -i eth0 port 22
</pre></div>
</div>
</div>
<div id="outline-container-org12e7a21" class="outline-2">
<h2 id="org12e7a21">14. 抓取发往指定目的和端口上包</h2>
<div class="outline-text-2" id="text-org12e7a21">
<p>
可以使用 <code>and</code> 和 <code>or</code> 对过滤条件进行组合以实现精确的抓包。<br></p>
<div class="highlight"><pre><span></span>tcpdump -w net_dump.pcap -i eth0 dst 10.181.140.216 and port 22
</pre></div>
</div>
</div>

<div id="outline-container-orgea1f89b" class="outline-2">
<h2 id="orgea1f89b">常用tcpdump命令示例</h2>
<div class="outline-text-2" id="text-orgea1f89b">
<div class="highlight"><pre><span></span>tcpdump –i any 'port 8888'
tcpdump –i any 'tcp port 8888'
tcpdump –i any 'tcp src port 8888'
tcpdump –i any 'tcp src port 8888 and udp dst port 9999'
tcpdump -i any 'src host 127.0.0.1 and tcp src port 12345' -XX -nn -vv
</pre></div>
</div>
</div>

<div id="outline-container-org40c9aee" class="outline-2">
<h2 id="org40c9aee">参考资料</h2>
<div class="outline-text-2" id="text-org40c9aee">
<ul class="org-ul">
<li>
<a href="https://danielmiessler.com/study/tcpdump/">danielmiessler.com tcpdump</a><br>
</li>
<li>
<a href="https://www.thegeekstuff.com/2010/08/tcpdump-command-examples/">thegeekstuff.com tcpdump</a><br>
</li>
</ul>
</div>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/linux-command-examples-nc/" class="u-url">Linux常用命令行指令 - nc</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-03-24T10:01:10+08:00" itemprop="datePublished" title="2018-03-24 10:01">Mar 24 2018  (10:01)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/linux-command-examples-nc/#disqus_thread" data-disqus-identifier="cache/archives/2018/linux-command-examples-nc.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/linux/" rel="tag">linux</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <p>
<code>nc</code> 命令是 <code>netcat</code> 的缩写，能够使用TCP或UDP协议读写网络连接中的数据，是一个方便可靠的调试工具。<br></p>

<div id="outline-container-org66c0ac2" class="outline-2">
<h2 id="org66c0ac2">1. 基本 <code>C/S</code> 模型</h2>
<div class="outline-text-2" id="text-org66c0ac2">
<p>
作为服务端建立监听<br></p>
<div class="highlight"><pre><span></span>nc -l 127.0.0.1 8060
</pre></div>
<p>
作为客户端连接端口<br></p>
<div class="highlight"><pre><span></span>nc 172.0.0.1 8060
</pre></div>
<p>
但是需要注意的是，该服务端只允许一个客户端连接进来。<br><code>nc</code> 会默认以TCP协议运行，可以增加 <code>-u</code> 参数转换为UDP协议。<br></p>
</div>
</div>

<div id="outline-container-org3eccb83" class="outline-2">
<h2 id="org3eccb83">2. 文件传输</h2>
<div class="outline-text-2" id="text-org3eccb83">
<p>
模拟客户端向服务端传输文件的示例代码如下，同理，也可以模拟服务端向客户端发送文件。<br></p>
<div class="highlight"><pre><span></span>nc -l 1234  &gt; filename.out
nc 127.0.0.1 1234 &lt; fielname.in
</pre></div>
</div>
</div>

<div id="outline-container-org40d358a" class="outline-2">
<h2 id="org40d358a">3. 连接远程系统</h2>
<div class="outline-text-2" id="text-org40d358a">
<p>
已连接http服务器为例，在作为客户端连接以后，可以向服务器发送 <code>GET /HTTP/1.1</code> 来获取网站的主页。<br>
示例代码如下<br></p>
<div class="highlight"><pre><span></span>print "GET /HTTP/1.0 \r\n"| nc host.example.com 80
</pre></div>
</div>
</div>

<div id="outline-container-org3805355" class="outline-2">
<h2 id="org3805355">4. 简易代理</h2>
<div class="outline-text-2" id="text-org3805355">
<p>
将nc命令嵌套使用，可以将一个端口中的数据转发到目的ip和端口。<br></p>
<div class="highlight"><pre><span></span>ncat -l 8080 | ncat 192.168.1.200 80
</pre></div>
<p>
通过上面的命令能够将本机8080端口的数据转发到192.168.1.200的80端口上，但是这样是单向的。可以建立 <code>fifo</code> 实现数据的双向传输。<br></p>
<div class="highlight"><pre><span></span>mkfifo ./fifo_temp
ncat -l 8080 0&lt;fifo_temp | ncat 192.168.1.200 80 1&gt;fifo_temp
</pre></div>
</div>
</div>

<div id="outline-container-org4f4847e" class="outline-2">
<h2 id="org4f4847e">5. 参考资料</h2>
<div class="outline-text-2" id="text-org4f4847e">
<ul class="org-ul">
<li>
<a href="https://www.linuxtechi.com/nc-ncat-command-examples-linux-systems/">linuxtech</a><br>
</li>
<li>
<a href="https://www.thegeekstuff.com/2012/04/nc-command-examples/?utm_source=feedburner">thegeekstuff</a><br>
</li>
<li>
<a href="https://www.computerhope.com/unix/nc.htm">computerhope</a><br>
</li>
</ul>
</div>
</div>
    </div>

  </article>
</div>



        
       <script>var disqus_shortname="samsonwang-me";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script>
</div>

      <div class="col-lg-3 col-md-3 col-sm-12 col-xs-12 sidebar">
       
<div class="sidebar-module sidebar-module-inset">
  <h4>About Me</h4>
  
        <div class="sidebar-aboutme">
        <p>Zeal for coding, C++ developer. Focus on linux server dev. I use EMACS, and I am learning python.</p>
        <p>View my code on <a href="https://github.com/samsonwang"> Github</a></p>
</div>
</div>

       
<div class="sidebar-module">
  <h4>Categories</h4>
  
        <ol class="list-unstyled sidebar-category">
<li>
<a href="/tags/category-cpp/">cpp</a>
        </li>
<li>
<a href="/tags/category-emacs/">emacs</a>
        </li>
<li>
<a href="/tags/category-linux/">linux</a>
        </li>
<li>
<a href="/tags/category-windows/">windows</a>
        </li>
</ol>
</div>

      </div>
<!--.sidebar-->
    </div>
<!--.row-->

    

        <nav class="postindexpager"><ul class="pager">
<li class="next">
                <a href="/index-4.html" rel="prev">Newer posts</a>
            </li>
            <li class="previous">
                <a href="/index-6.html" rel="next">Older posts</a>
            </li>
        </ul></nav><!--End of body content--><footer id="footer"><div class="text-center">
<p>Contents © 2017-2018 <a href="mailto:wangzhilv@gmail.com">Samson Wang</a>
 - Powered by <a href="https://getnikola.com/" rel="nofollow">Nikola</a>
 - Hosted on <a href="https://pages.github.com/" rel="nofollow">Github Pages</a>
 - 
<a rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/"><img alt="知识共享许可协议" style="padding-bottom:2px" src="https://i.creativecommons.org/l/by-nc/4.0/80x15.png"></a>
</p>
</div>

      
    </footer>
</div>
</div>

<div id="scroll-top" title="back to top">
  <div id="scroll-top-arrow"></div>
  <div id="scroll-top-stick"></div>
</div>


            <script src="/assets/js/jquery.min.js"></script><script src="/assets/js/jquery.colorbox-min.js"></script><script src="/assets/js/jquery.lazyload.min.js"></script><script src="/assets/js/popper.min.js"></script><script src="/assets/js/bootstrap.min.js"></script><script src="/assets/js/moment-with-locales.min.js"></script><script src="/assets/js/fancydates.js"></script><script src="/assets/js/cerulean.js"></script><!-- fancy dates --><script>
  moment.locale("en");
  fancydates(0, "YYYY-MM-DD HH:mm");
</script><!-- end fancy dates --><!-- Baidu Analytics --><script>
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?7ec47c52179b8ca4f9aee81282bd7b20";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>
</body>
</html>
