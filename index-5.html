<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#" lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="Personal handnote on software development">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Hack Note (old posts, page 5) | Hack Note</title>
<link href="https://cdn.staticfile.org/twitter-bootstrap/4.1.1/css/bootstrap.min.css" rel="stylesheet">
<link href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link href="/blog/assets/css/code.css" rel="stylesheet" type="text/css">
<link href="/blog/assets/css/colorbox.css" rel="stylesheet" type="text/css">
<link href="/blog/assets/css/highlight.css" rel="stylesheet" type="text/css">
<link href="/blog/assets/css/cerulean.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="en" href="/blog/rss.xml">
<link rel="canonical" href="https://samsonwang.github.io/blog/index-5.html">
<link rel="icon" href="/blog/favicon.ico" sizes="64x64">
<link rel="prev" href="/blog/index-4.html" type="text/html">
<link rel="next" href="/blog/index-6.html" type="text/html">
<!--[if lt IE 9]><script src="https://html5shim.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
</head>
<body class="preload">
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->
<nav id="top-nav" class="navbar navbar-expand-md fixed-top mb-4 navbar-dark bg-dark"><div class="container">   <!-- This keeps the margins nice -->
    <a class="navbar-brand" href="/blog/">

      <span id="blog-title">Hack Note</span>
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div class="collapse navbar-collapse" id="bs-navbar">
      <ul class="navbar-nav ml-auto">
<li class="nav-item">
<a href="/blog/archive/" class="nav-link">Archives</a>
                </li>
<li class="nav-item">
<a href="/blog/tags/" class="nav-link">Tags</a>
                </li>
<li class="nav-item">
<a href="/blog/rss.xml" class="nav-link">RSS Feed</a>

        
      </li>
</ul>
<ul class="navbar-nav navbar-right"></ul>
</div>
<!-- /.navbar-collapse -->
  </div>
<!-- /.container -->
</nav><!-- End of Menubar --><div class="container" id="content" role="main">
  <div class="body-content">
    <!--Body content-->
    <div class="row">

      <div class="col-lg-9 col-md-9 col-sm-12 col-xs-12">
        
        


  



  


<div class="postindex">

      
      
      

  <article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/blog/posts/static-member-initialization-and-private-member-function/" class="u-url">静态成员变量初始化相关问题</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-09-04T23:37:37+08:00" itemprop="datePublished" title="2018-09-04 23:37">Sep 04 2018</time>
</div>

        

        
    <div class="comment blur-1">
      
        
    <a href="/blog/posts/static-member-initialization-and-private-member-function/#disqus_thread" data-disqus-identifier="cache/archives/2018/static-member-initialization-and-private-member-function.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/blog/tags/cpp/" rel="tag">cpp</a></li>
        <li><a class="tag p-category" href="/blog/tags/syntax/" rel="tag">syntax</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">引言</h2>
<div class="outline-text-2" id="text-1">
<p>
这篇文章的起因是出于对于 <code>C++</code> 饿汉单例模式代码的一些疑问，查阅了一些资料。在仔细研究后，我发现在一些基础概念的理解还是存在偏差。<br>
下面请看这样的一段代码，能看出其中有那些不太“正常”的语句么。<br></p>

<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Singleton</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">static</span> <span class="n">Singleton</span><span class="o">*</span> <span class="n">getInstance</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">Singleton</span><span class="p">()</span> <span class="p">{}</span>
    <span class="k">static</span> <span class="n">Singleton</span><span class="o">*</span> <span class="n">instance</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Singleton</span><span class="o">*</span> <span class="n">Singleton</span><span class="o">::</span><span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="p">();</span>
<span class="n">Singleton</span><span class="o">*</span> <span class="n">Singleton</span><span class="o">::</span><span class="n">getInstance</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">instance</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">私有静态成员的初始化</h2>
<div class="outline-text-2" id="text-2">
<p>
上面的代码是饿汉单例模式的 <code>C++</code> 的实现，在没有查阅资料之前，我对其中私有静态成员变量的初始化存疑。主要有以下两点：<br></p>
<ul class="org-ul">
<li>为什么私有变量能够在类外被修改<br>
</li>
<li>为什么私有构造函数能够在类外被调用<br>
</li>
</ul>
<p>
在我之前的知识积累中， <b>私有的成员变量或成员函数是不能够在类外被访问的</b> 。那么为什么以上代码没有问题呢？<br></p>

<p>
在C++标准中找到了下面的一段话(可以在 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3690.pdf">C++11 standard</a> 的 9.4.2节 或  <a href="http://eel.is/c++draft/class.static.data#2">C++ standard working draft</a> 的 10.3.9.2节 中找到)<br></p>
<blockquote>
<p>
The initializer expression in the definition of a static data member is in the scope of its class.<br></p>
</blockquote>
<p>
这句话的意思是：静态成员变量的初始化是被看做为它自身的类域中的（ <del>翻译的可能不是很准</del> ）。这样就不难理解为什么私有的静态成员变量能够在其类外被初始化了，由其私有构造函数进行构造也能说的通了。<br></p>


<p>
<b>同样</b> ,在C++标准中给出了下面这样的示例代码：<br></p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">process</span> <span class="p">{</span>
  <span class="k">static</span> <span class="n">process</span><span class="o">*</span> <span class="n">run_chain</span><span class="p">;</span>
  <span class="k">static</span> <span class="n">process</span><span class="o">*</span> <span class="n">running</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">process</span><span class="o">*</span> <span class="n">process</span><span class="o">::</span><span class="n">running</span> <span class="o">=</span> <span class="n">get_main</span><span class="p">();</span>
<span class="n">process</span><span class="o">*</span> <span class="n">process</span><span class="o">::</span><span class="n">run_chain</span> <span class="o">=</span> <span class="n">running</span><span class="p">;</span>
</pre></div>

<p>
给出的说明如下：<br></p>
<blockquote>
<p>
The static data member <code>run_chain</code> of class process is defined in global scope; the notation <code>process​::​run_chain</code> specifies that the member <code>run_chain</code> is a member of class <code>process</code> and in the scope of class <code>process</code>. In the static data member definition, the initializer expression refers to the static data member running of class <code>process</code>.<br></p>
</blockquote>
<p>
静态成员 <code>run_chain</code> 定义在全局域；而 <code>process::run_chain</code> 则表示 <code>run_chain</code> 是 <code>process</code> 类的成员变量，从而处在 <code>process</code> 类的作用域中。<br></p>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">私有构造函数</h2>
<div class="outline-text-2" id="text-3">
<p>
在查阅资料时，我发现 Peter 的 <a href="https://stackoverflow.com/a/41361967">描述</a> 纠正了我对私有构造函数的一些看法。<br></p>
<blockquote>
<p>
The point of a <code>private</code> constructor is not preventing object construction. It is about controlling which code can access the constructor, and therefore limiting which code to create an object that is an instance of that class. A <code>private</code> constructor is accessible to all member functions ( <code>static</code> or otherwise) of the class, and to all declared <code>friend</code> s of the class (which may be individual functions, or other classes) - so any of those can create an instance of the class using a <code>private</code> constructor (assuming the constructor is defined).<br></p>
</blockquote>
<p>
私有构造函数的目的并不是禁止对象构造，其目的在于控制哪些代码能够调用这个构造函数，进而限制类对象的创建。私有的构造函数可以被该类的所有成员函数（静态或非静态的）调用，该类的友元类或友元方法也能访问该类的私有函数，所以在上述情况中都可以通过私有的构造函数实例化出类对象。<br></p>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">参考资料</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3690.pdf">ISO C++11 standard</a><br>
</li>
<li>
<a href="http://eel.is/c++draft/class.static.data#2">ISO C++ standard working draft</a><br>
</li>
<li>
<a href="https://stackoverflow.com/questions/38583989/access-to-private-static-function-during-static-member-initialization">stackoverflow.com - access to private static function…</a><br>
</li>
<li>
<a href="https://stackoverflow.com/questions/41361223/why-private-constructor-prevents-object-creation-c">stackoverflow.com - private constructor</a><br>
</li>
<li>
<a href="https://stackoverflow.com/questions/7857989/static-member-variable-when-declared-private">stackoverflow.com - static member variable when declared private</a><br>
</li>
<li>
<a href="https://en.cppreference.com/w/cpp/language/static#Static_data_members">cppreference.com - static data members</a><br>
</li>
</ul>
</div>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/blog/posts/non-blocking-socket-connect-tips/" class="u-url">客户端使用非阻塞socket进行connect的流程</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-08-31T17:04:19+08:00" itemprop="datePublished" title="2018-08-31 17:04">Aug 31 2018</time>
</div>

        

        
    <div class="comment blur-1">
      
        
    <a href="/blog/posts/non-blocking-socket-connect-tips/#disqus_thread" data-disqus-identifier="cache/archives/2018/non-blocking-socket-connect-tips.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/blog/tags/network/" rel="tag">network</a></li>
        <li><a class="tag p-category" href="/blog/tags/nio/" rel="tag">nio</a></li>
        <li><a class="tag p-category" href="/blog/tags/non-blocking/" rel="tag">non-blocking</a></li>
        <li><a class="tag p-category" href="/blog/tags/socket/" rel="tag">socket</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">问题</h2>
<div class="outline-text-2" id="text-1">
<p>
使用非阻塞（ <code>non-blocking</code> ） socket尝试与服务端建立连接（ <code>connect</code> ）时，由于是io非阻塞的，所以 <code>connect</code> 函数会立即返回，那么如何判断client与server连接成功了呢？<br></p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">解答</h2>
<div class="outline-text-2" id="text-2">
<p>
客户端建立连接的示例代码如下：<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">connect</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="p">...);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">errno</span> <span class="o">!=</span> <span class="n">EINPROGRESS</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// case1. error, fail somehow, close socket</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// case2. connection has succeeded immediately</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// case3. connection attempt is in progress</span>
<span class="p">}</span>
</pre></div>
<p>
由于是非阻塞模式，所以 <code>connect</code> 之后会直接返回，根据返回值 <code>res</code> 和 <code>errno</code> 能够判断建立连接的结果。<br></p>
<ul class="org-ul">
<li>case1，表示连接失败；<br>
</li>
<li>case2，表示连接建立成功；<br>
</li>
<li>case3，表示正在建立连接的过程中，在这个情况下，需要等待socket变成可写（writable）状态，可以使用 <code>select</code> 或 <code>epoll</code> 完成；<br>
</li>
</ul>
<p>
在 case3 情况下，socket可写后，执行下面的代码检查socket是否出现错误。<br></p>
<ul class="org-ul">
<li>case4和case5，表示socket出现了错误，将会关闭连接；<br>
</li>
<li>case6，表示连接建立成功，可以开始 <code>read</code> 和 <code>write</code> 了。<br>
</li>
</ul>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
<span class="kt">socklen_t</span> <span class="n">result_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">getsockopt</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">SO_ERROR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result_len</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// case4. error, fail somehow, close socket</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// case5. connection failed; error code is in 'result'</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// case6. socket is ready for read()/write()</span>
</pre></div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">参考资料</h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li>
<a href="https://stackoverflow.com/questions/10187347/async-connect-and-disconnect-with-epoll-linux/10194883#10194883">stackoverflow.com</a><br>
</li>
</ul>
</div>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/blog/posts/why-front-end-libraries/" class="u-url">为什么要使用各种前端框架</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-08-27T22:10:35+08:00" itemprop="datePublished" title="2018-08-27 22:10">Aug 27 2018</time>
</div>

        

        
    <div class="comment blur-1">
      
        
    <a href="/blog/posts/why-front-end-libraries/#disqus_thread" data-disqus-identifier="cache/archives/2018/why-front-end-libraries.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/blog/tags/css/" rel="tag">css</a></li>
        <li><a class="tag p-category" href="/blog/tags/front-end/" rel="tag">front-end</a></li>
        <li><a class="tag p-category" href="/blog/tags/html/" rel="tag">html</a></li>
        <li><a class="tag p-category" href="/blog/tags/javascript/" rel="tag">javascript</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">引言</h2>
<div class="outline-text-2" id="text-1">
<p>
在学习前端的过程中，我开始接触到许多开发框架或开发工具，这些工具让我开始眼花缭乱。使用常规的html/css/js就已经能够开发出这种网页了，所以我问自己，为什么要学习这些框架或工具，这些库是用来解决什么问题的。想明白这个问题，我学习的目的就更加明确，在遇到一些开发情景时，也能够快速准确地挑选出应该使用的框架。<br></p>

<p>
下面按照我目前的理解，对目前的主流的前端开发库进行一些分析和比较。由于我还是一个初学着，所以我的观点可能还不是很成熟。<br></p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">为什么要使用jQuery</h2>
<div class="outline-text-2" id="text-2">
<p>
jQuery是一个轻量级js库，它有如下特性：<br></p>
<ul class="org-ul">
<li>简化了HTML/DOM操作<br>
</li>
<li>CSS选择器<br>
</li>
<li>动画特效支持<br>
</li>
<li>解决跨浏览器的兼容行问题<br>
</li>
<li>完善的Ajax支持<br>
</li>
</ul>
<p>
在查阅资料的过程中，我还听到一些主张停用jQuery的声音。原因就在于随着前端开发生态不断的完善，现代浏览器原生API已经足够好用。<br></p>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">为什么要使用SASS</h2>
<div class="outline-text-2" id="text-3">
<p>
SASS是一种CSS预编译格式，它最终会编译成CSS。<br>
SASS提供了CSS语法的拓展，它支持变量，算数运算符，循环操作，函数操作，样式模板（mixin）等强大的特性。它能够让开发人员更方便地编写CSS。SASS支持 <code>import</code> 关键字，这样就能够很方便地对样式进行模块化设计。<br></p>

<p>
加一句题外话，在使用SASS时，需要考虑的另一个问题就是代码物理结构的安排（直白的说就是目录的划分，源文件的存放位置等），这也是所有代码开发中需要注意的问题。<br></p>

<p>
与SASS相似的工具还有LESS。<br></p>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">为什么要使用Bootstrap</h2>
<div class="outline-text-2" id="text-4">
<p>
Bootstrap是一个用于快速开发网页的前端框架。以我目前的理解来看，它更像是一个网页样式框架。<br></p>
<ul class="org-ul">
<li>丰富的基础样式和资源<br>
</li>
<li>响应式（responsive），良好的移动端支持<br>
</li>
<li>强大的网格（grid）系统<br>
</li>
<li>一致性，保证跨浏览器的样式一致<br>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">为什么要使用React</h2>
<div class="outline-text-2" id="text-5">
<p>
DOM操作对性能的影响很大，频繁的DOM操作会使网页渲染的速度变慢，React主要解决了这个问题。<br>
React.js允许在js中编写html，形成Virtual DOM，只在变化进行重新渲染。<br></p>

<p>
下面的一段文字摘自参考资料中的第5篇文章。<br></p>
<blockquote>
<ul class="org-ul">
<li>Am I building an app which has lots of DOM interactions, or is it a relatively simple app with relatively few interactions?<br>
</li>
<li>Does my app require a very high browser performance, that any user interactions must immediately be reflected in the UI? Is my data going to change over time, at a high rate?<br>
</li>
<li>Is one user interaction going to affect many other areas/components in the UI?<br>
</li>
<li>Is there a possibility that my app could grow big in the future, and so I would want to write extremely neat, modular front-end JavaScript that is easy to maintain? Would I want to use lots of native JavaScript or would I prefer using a lot of abstractions/methods provided in a framework?<br>
</li>
<li>Would I prefer a framework/library which does not have a high learning curve and which is pretty easy to get started with development?<br>
</li>
</ul>
</blockquote>

<p>
在使用React之前，问自己这样几个问题，就能够帮助你决定是否需要使用React。<br></p>
<ul class="org-ul">
<li>所开发的网页应用涉及到很多DOM操作么？<br>
</li>
<li>开发的网页应用需要很高的性能么，这意味着任何用于的操作都要立刻反应在界面上？我的数据变更会很频繁么？<br>
</li>
<li>我开发的应用会在未来逐渐变得复杂么，这样我就需要将前端的js代码模块化？我是否会使用许多原生js特性，是否虚幻使用框架提供的抽象方法<br>
</li>
<li>是否需要一个学习曲线比较平缓的框架，能够方便地上手进行开发？<br>
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">参考资料</h2>
<div class="outline-text-2" id="text-6">
<ol class="org-ol">
<li>
<a href="https://www.w3schools.com/jquery/jquery_intro.asp">w3schools jQuery intro</a><br>
</li>
<li>
<a href="https://github.com/nefe/You-Dont-Need-jQuery">github you don't need jQuery</a><br>
</li>
<li>
<a href="https://www.mugo.ca/Blog/7-benefits-of-using-SASS-over-conventional-CSS">7 benefits of SASS</a><br>
</li>
<li>
<a href="https://www.devsaran.com/blog/10-best-reasons-use-bootstrap-amazing-web-designs">10 best reasons to use bootstrap</a><br>
</li>
<li>
<a href="https://scotch.io/@anitashah/what-problems-does-reactjs-solve-when-must-you-select-reactjs">what problems does reactjs solve</a><br>
</li>
</ol>
</div>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/blog/posts/javascript-object-oriented-programming/" class="u-url">javscript中的OOP特性</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-08-26T10:31:37+08:00" itemprop="datePublished" title="2018-08-26 10:31">Aug 26 2018</time>
</div>

        

        
    <div class="comment blur-1">
      
        
    <a href="/blog/posts/javascript-object-oriented-programming/#disqus_thread" data-disqus-identifier="cache/archives/2018/javascript-object-oriented-programming.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/blog/tags/cpp/" rel="tag">cpp</a></li>
        <li><a class="tag p-category" href="/blog/tags/javascript/" rel="tag">javascript</a></li>
        <li><a class="tag p-category" href="/blog/tags/oop/" rel="tag">oop</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">
<span class="section-number-2">1</span> 引言</h2>
<div class="outline-text-2" id="text-1">
<p>
js也是具有OOP（object oriented programming）特性的，OOP在构建一些大型应用程序还是有一套成熟理论的。作为C++的使用者在学习js中的OOP特性的过程中，能够较快地理解其中的各种术语和概念，也能比较两种语言的异同，深化知识理解。通过js的OOP特性的学习也让我开始从语言层面考虑程序设计问题。<br>
本篇文章主要介绍了js中的一些OOP特性，并且比较了js与C++的语言特性。如果你能熟练掌握C++的OOP特性，本文能帮助你快速地对js中的OOP特性建立整体的认识。<br></p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">
<span class="section-number-2">2</span> 写给C++使用者的js中的OOP特性介绍</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">
<span class="section-number-3">2.1</span> 创建对象（object）</h3>
<div class="outline-text-3" id="text-2-1">
<p>
js中创建object的代码，示例如下：<br></p>
<div class="highlight"><pre><span></span>let duck = {
  name: "Aflac",
  numLegs: 2,
  sayName: function() {
    return "The name of this duck is " + this.name + ".";
  }
};
</pre></div>
<p>
js直接通过 <code>{}</code> 就可以创建出对象示例来，不需要对该对象（object）的类（class）进行声明。这点和C++不是很相同，C++需要先声明一个class再创建object。<br>
这个object有两个成员变量和一个成员函数，需要注意的是这两个成员变量都是公有（public）的，他们是可以直接用 <code>.</code> 符号访问的。<br>
js中也有 <code>this</code> 关键字，与C++相同， <code>this</code> 关键字用于表示当前实例。<br></p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">
<span class="section-number-3">2.2</span> 类（class）的声明</h3>
<div class="outline-text-3" id="text-2-2">
<p>
js中声明一个类的操作实际上就是声明一个构造函数。<br></p>
<div class="highlight"><pre><span></span>let Bird = function(name, color) {
  this.name = name;
  this.color = color;
  this.numLegs = 2;
}

let crow = new Bird("Alexis", "black");

crow instanceof Bird; // =&gt; true
</pre></div>
<p>
上面的代码声明了Bird类，在js中通常类的名字都是由首字母大写的单词表示的。类的构造函数也能接受参数用于对实例的初始化，这点与C++非常相似，使用 <code>new</code> 关键字就能够创建该类的实例。<br>
使用 <code>instanceof</code> 关键字用于检查对象是否属于某个类，也可通过验证 <code>constructor</code> 属性来判断一个对象是否属于一个类 <code>crow.constructor == Bird</code> 。<br></p>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">
<span class="section-number-3">2.3</span> 类的共有成员</h3>
<div class="outline-text-3" id="text-2-3">
<p>
js中通过 <code>prototype</code> 这一属性（把它叫做关键字好像还不太合适）能够实现C++中静态成员变量和静态成员函数的特性。<br></p>
<div class="highlight"><pre><span></span>Bird.prototype.numLegs = 2;
</pre></div>
<p>
上面的代码就给Bird类增加了一个静态成员变量。这个 <code>prototype</code> 可以是一个对象，这样类的共有成员就能方便地承载更多的属性了，示例代码如下。<br></p>
<div class="highlight"><pre><span></span>Bird.prototype = {
  constructor: Bird,
  numLegs: 2,
  eat: function() {
    console.log("nom nom nom");
  },
  describe: function() {
    console.log("My name is " + this.name);
  }
};
</pre></div>
<p>
需要注意的是需要设置好 <code>constructor</code> 属性，这样是为了保证代码逻辑的一致性。<br>
对象会获得类的 <code>prototype</code> 属性，可以通过 <code>isPrototypeof</code> 方法来验证。<br></p>
<div class="highlight"><pre><span></span>Bird.prototype.isPrototypeOf(duck);
</pre></div>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">
<span class="section-number-3">2.4</span> 类的私有成员</h3>
<div class="outline-text-3" id="text-2-4">
<p>
js与C++一样，也可以有私有成员变量，代码如下所示。 <code>hatchedEgg</code> 就相当与是Bird的私有成员变量，并且提供了修改这个成员变量的方法 <code>getHatchedEggCount</code> 。<br></p>
<div class="highlight"><pre><span></span>function Bird() {
  let hatchedEgg = 10; // private property

  this.getHatchedEggCount = function() {
    // publicly available method that a bird object can use
    return hatchedEgg;
  };
}
let ducky = new Bird();
ducky.getHatchedEggCount(); // returns 10
</pre></div>
<p>
这种形式在js中被称作闭包（closure），函数能够访问到与他处在同一个作用域（context）中的变量。<br></p>
</div>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">
<span class="section-number-3">2.5</span> 类的继承和派生</h3>
<div class="outline-text-3" id="text-2-5">
<p>
js中的派生主要通过 <code>prototype</code> 体现，下面的代码表示Bird派生自Object。同样，需要注意将 <code>constructor</code> 属性设置好。<br></p>
<div class="highlight"><pre><span></span>Bird.prototype = Object.create(Animal.prototype);
Bird.prototype.constructor = Bird;
</pre></div>
</div>
</div>

<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">
<span class="section-number-3">2.6</span> 类的覆盖</h3>
<div class="outline-text-3" id="text-2-6">
<p>
js中可以重写基类中的方法，代码如下所示，这点与C++中的 <code>override</code> 相同。<br></p>
<div class="highlight"><pre><span></span>function Animal() { }
Animal.prototype.eat = function() {
  return "nom nom nom";
};
function Bird() { }

// Inherit all methods from Animal
Bird.prototype = Object.create(Animal.prototype);

// Bird.eat() overrides Animal.eat()
Bird.prototype.eat = function() {
  return "peck peck peck";
};

Bird.prototype.fly = function() {
  console.log("I'm flying!");
};
</pre></div>
<p>
通样也在派生之后也可以通过修改派生类的 <code>prototype</code> 以达到特化派生类的作用，上面的 <code>fly</code> 方法就是在Bird完成派生之后新增的方法。现在Bird有两个方法，它们分别是 <code>eat</code> 和 <code>fly</code> 。<br></p>
</div>
</div>
</div>


<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">
<span class="section-number-2">3</span> 参考资料</h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li>
<a href="https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/object-oriented-programming/">FCC javascript oop tutorial</a><br>
</li>
</ul>
</div>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/blog/posts/regexp-cheetsheet/" class="u-url">正则表达式备忘</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-08-23T11:55:36+08:00" itemprop="datePublished" title="2018-08-23 11:55">Aug 23 2018</time>
</div>

        

        
    <div class="comment blur-1">
      
        
    <a href="/blog/posts/regexp-cheetsheet/#disqus_thread" data-disqus-identifier="cache/archives/2018/regexp-cheetsheet.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/blog/tags/grep/" rel="tag">grep</a></li>
        <li><a class="tag p-category" href="/blog/tags/js/" rel="tag">js</a></li>
        <li><a class="tag p-category" href="/blog/tags/lisp/" rel="tag">lisp</a></li>
        <li><a class="tag p-category" href="/blog/tags/python/" rel="tag">python</a></li>
        <li><a class="tag p-category" href="/blog/tags/regexp/" rel="tag">regexp</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">引言</h2>
<div class="outline-text-2" id="text-1">
<p>
近在FreeCodeCamp(FCC)学习前端的课程，其中有一节就是讲的 <code>regexp</code> ，也就是正则表达式，之前我零星地了解过一些正则表达式的相关知识，不足以对正则表达式得出一个完整的认识。FCC的教程循序渐进，由简到繁，在教学中结合练习，非常适合初学者的学习过程。如何你的英文能够达到阅读技术类文献的水平，又正好想学习一下正则表达式，我推荐你试一下FCC的正则表达式教程，花3~4个小时就能够对正则表达式有个完整的理解。<br></p>

<p>
本篇文章主要是对学习过程中的知识点进行总结，方便以后进行查阅。<br></p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">要点总结（js版）</h2>
<div class="outline-text-2" id="text-2">
<p>
FCC的教程使用javascript作为开发语言，本节所有的代码都是js代码。<br></p>

<p>
js中内置了正则表达式模块，下面是正则表达式在js中的使用示例<br></p>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">myString</span> <span class="o">=</span> <span class="s2">"Hello World"</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">myRegex</span> <span class="o">=</span> <span class="sr">/Hello/</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">myRegex</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">myString</span><span class="p">);</span>
</pre></div>

<p>
使用 <code>|</code> 进行or匹配<br></p>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">regex2</span> <span class="o">=</span> <span class="sr">/cat|bird/</span><span class="p">;</span>
</pre></div>


<p>
使用 <code>i</code> 标识符在匹配时忽略大小写<br></p>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">regex3</span> <span class="o">=</span> <span class="sr">/case/i</span><span class="p">;</span>
</pre></div>


<p>
使用正则表达式进行字符串过滤，使用 <code>match</code> 方法<br></p>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">extractStr</span> <span class="o">=</span> <span class="s2">"Extract the word 'coding' from this string."</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">codingRegex</span> <span class="o">=</span> <span class="sr">/coding/</span><span class="p">;</span> <span class="c1">// Change this line</span>
<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">extractStr</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="nx">codingRegex</span><span class="p">);</span> <span class="c1">// Change this line</span>
</pre></div>


<p>
使用 <code>g</code> 进行返回满足规则的多次结果， <code>g</code> 为global的缩写<br></p>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">twinkleStar</span> <span class="o">=</span> <span class="s2">"Twinkle, twinkle, little star"</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">starRegex</span> <span class="o">=</span> <span class="sr">/twinkle/gi</span><span class="p">;</span> <span class="c1">// Change this line</span>
<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">twinkleStar</span><span class="p">;</span> <span class="c1">// Change this line</span>
</pre></div>


<p>
使用 <code>.</code> 匹配所有的字符，使用 <code>[]</code> 匹配指定的字符<br></p>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">quoteSample</span> <span class="o">=</span> <span class="s2">"Beware of bugs in the above code; I have only proved it correct, not tried it."</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">vowelRegex</span> <span class="o">=</span> <span class="sr">/[aeiou]/gi</span><span class="p">;</span> <span class="c1">// Change this line</span>
<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">quoteSample</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="nx">vowelRegex</span><span class="p">);</span> <span class="c1">// Change this line</span>
</pre></div>

<p>
在 <code>[]</code> 中可以使用 <code>-</code> 代表一个范围<br></p>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">quoteSample2</span> <span class="o">=</span> <span class="s2">"The quick brown fox jumps over the lazy dog."</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">alphabetRegex</span> <span class="o">=</span> <span class="sr">/[a-z]/gi</span><span class="p">;</span> <span class="c1">// Change this line</span>
<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">quoteSample2</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="nx">alphabetRegex</span><span class="p">);</span> <span class="c1">// Change this line</span>
</pre></div>


<p>
这个范围还可以是多个，并且允许包含数字<br></p>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">quoteSample3</span> <span class="o">=</span> <span class="s2">"Blueberry 3.141592653s are delicious."</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">myRegex</span> <span class="o">=</span> <span class="sr">/[h-s2-6]/gi</span><span class="p">;</span> <span class="c1">// Change this line</span>
<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">quoteSample3</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="nx">myRegex</span><span class="p">);</span> <span class="c1">// Change this line</span>
</pre></div>


<p>
使用 <code>^</code> 符号能够匹配不包含某些字符<br></p>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">quoteSample4</span> <span class="o">=</span> <span class="s2">"3 blind mice."</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">myRegex2</span> <span class="o">=</span> <span class="sr">/[^0-9aeiou]/gi</span><span class="p">;</span> <span class="c1">// Change this line</span>
<span class="kd">let</span>  <span class="nx">result</span> <span class="o">=</span> <span class="nx">quoteSample4</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="nx">myRegex2</span><span class="p">);</span> <span class="c1">// Change this line</span>
</pre></div>


<p>
使用 <code>+</code> 对出现连续出现的字符进行匹配<br></p>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">difficultSpelling</span> <span class="o">=</span> <span class="s2">"Mississippi"</span><span class="p">;</span>
<span class="kd">let</span>  <span class="nx">myRegex3</span> <span class="o">=</span> <span class="sr">/s+/g</span><span class="p">;</span> <span class="c1">// Change this line</span>
<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">difficultSpelling</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="nx">myRegex3</span><span class="p">);</span>
</pre></div>


<p>
使用 <code>*</code> 星号匹配可能没有出现的次数（出现次数为 0~n 次）<br></p>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">chewieQuote</span> <span class="o">=</span> <span class="s2">"Aaaaaaaaaaaaaaaarrrgh!"</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">chewieRegex</span> <span class="o">=</span> <span class="sr">/Aa*/</span><span class="p">;</span> <span class="c1">// Change this line</span>
<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">chewieQuote</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="nx">chewieRegex</span><span class="p">);</span>
</pre></div>


<p>
使用 <code>?</code> 进行较短匹配 （lazy match, 与greedy match 对应）<br></p>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">text</span> <span class="o">=</span> <span class="s2">"&lt;h1&gt;Winter is coming&lt;/h1&gt;"</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">myRegex</span> <span class="o">=</span> <span class="sr">/&lt;.*?&gt;/</span><span class="p">;</span> <span class="c1">// Change this line</span>
<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">text</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="nx">myRegex</span><span class="p">);</span>
</pre></div>


<p>
使用 <code>^</code> 对出现在字符串开始位置进行匹配<br>
注意上边也用到这个符号表示取反，是在 <code>[]</code> 中表示取反<br></p>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">rickyAndCal</span> <span class="o">=</span> <span class="s2">"Cal and Ricky both like racing."</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">calRegex</span> <span class="o">=</span> <span class="sr">/^Cal/</span><span class="p">;</span> <span class="c1">// Change this line</span>
<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">calRegex</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">rickyAndCal</span><span class="p">);</span>
</pre></div>


<p>
使用 <code>$</code> 对出现在字符串结束位置进行匹配<br></p>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">caboose</span> <span class="o">=</span> <span class="s2">"The last car on a train is the caboose"</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">lastRegex</span> <span class="o">=</span> <span class="sr">/caboose$/</span><span class="p">;</span> <span class="c1">// Change this line</span>
<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">lastRegex</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">caboose</span><span class="p">);</span>
</pre></div>


<p>
使用 <code>\w</code> 代替 <code>[A-Za-z0-9_]</code> ，包含所有的数字、字母和下划线<br></p>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">quoteSample</span> <span class="o">=</span> <span class="s2">"The five boxing wizards jump quickly."</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">alphabetRegexV2</span> <span class="o">=</span> <span class="sr">/\w/g</span><span class="p">;</span> <span class="c1">// Change this line</span>
<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">quoteSample</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="nx">alphabetRegexV2</span><span class="p">).</span><span class="nx">length</span><span class="p">;</span>
</pre></div>


<p>
使用 <code>\W</code> 代替 <code>[^A-Za-z0-9_]</code> ，相当于上边的逆向匹配<br></p>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">quoteSample</span> <span class="o">=</span> <span class="s2">"The five boxing wizards jump quickly."</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">nonAlphabetRegex</span> <span class="o">=</span> <span class="sr">/\W/g</span><span class="p">;</span> <span class="c1">// Change this line</span>
<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">quoteSample</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="nx">nonAlphabetRegex</span><span class="p">).</span><span class="nx">length</span><span class="p">;</span>
</pre></div>


<p>
使用 <code>\d</code> 代替 <code>[0-9]</code> ，所有数字匹配<br></p>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">numString</span> <span class="o">=</span> <span class="s2">"Your sandwich will be $5.00"</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">numRegex</span> <span class="o">=</span> <span class="sr">/\d/g</span><span class="p">;</span> <span class="c1">// Change this line</span>
<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">numString</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="nx">numRegex</span><span class="p">).</span><span class="nx">length</span><span class="p">;</span>
</pre></div>


<p>
使用 <code>\D</code> 代替 <code>[^0-9]</code> ，所有非数字匹配<br></p>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">numString</span> <span class="o">=</span> <span class="s2">"Your sandwich will be $5.00"</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">noNumRegex</span> <span class="o">=</span> <span class="sr">/\D/g</span><span class="p">;</span> <span class="c1">// Change this line</span>
<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">numString</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="nx">noNumRegex</span><span class="p">).</span><span class="nx">length</span><span class="p">;</span>
</pre></div>


<p>
使用 <code>\s</code> 代替 <code>[ \r\t\f\n\v]</code> ，与空格和换行相关<br></p>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">sample</span> <span class="o">=</span> <span class="s2">"Whitespace is important in separating words"</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">countWhiteSpace</span> <span class="o">=</span> <span class="sr">/\s/g</span><span class="p">;</span> <span class="c1">// Change this line</span>
<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">sample</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="nx">countWhiteSpace</span><span class="p">);</span>
</pre></div>


<p>
使用 <code>\S=，代替 =[^ \r\t\f\n\v]</code> ，不包含空格和换行<br></p>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">sample</span> <span class="o">=</span> <span class="s2">"Whitespace is important in separating words"</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">countNonWhiteSpace</span> <span class="o">=</span> <span class="sr">/\S/g</span><span class="p">;</span> <span class="c1">// Change this line</span>
<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">sample</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="nx">countNonWhiteSpace</span><span class="p">);</span>
</pre></div>


<p>
使用 <code>{min, max}</code> 对字符出现的次数进行限定<br>
回想起使用 <code>+</code> 限制次数为 <code>{0,}</code> ，使用 <code>-</code> 限制次数为 <code>{1,}</code><br></p>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">ohStr</span> <span class="o">=</span> <span class="s2">"Ohhh no"</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">ohRegex</span> <span class="o">=</span> <span class="sr">/Oh{3,6} no/</span><span class="p">;</span> <span class="c1">// Change this line</span>
<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">ohRegex</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">ohStr</span><span class="p">);</span>
</pre></div>


<p>
仅限制出现次数的下限 <code>{min,}</code><br></p>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">haStr</span> <span class="o">=</span> <span class="s2">"Hazzzzah"</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">haRegex</span> <span class="o">=</span> <span class="sr">/Haz{4,}ah/</span><span class="p">;</span> <span class="c1">// Change this line</span>
<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">haRegex</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">haStr</span><span class="p">);</span>
</pre></div>


<p>
指定出现的次数 <code>{count}</code><br></p>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">timStr</span> <span class="o">=</span> <span class="s2">"Timmmmber"</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">timRegex</span> <span class="o">=</span> <span class="sr">/Tim{4}ber/</span><span class="p">;</span> <span class="c1">// Change this line</span>
<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">timRegex</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">timStr</span><span class="p">);</span>
</pre></div>


<p>
使用 <code>?</code> 匹配可能出现的字母<br>
问号用于声明lazy match，如何判断是lazy match还是匹配可能出现的东西呢<br></p>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">favWord</span> <span class="o">=</span> <span class="s2">"favorite"</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">favRegex</span> <span class="o">=</span> <span class="sr">/favou?rite/</span><span class="p">;</span> <span class="c1">// Change this line</span>
<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">favRegex</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">favWord</span><span class="p">);</span>
</pre></div>



<p>
lookahead 的概念， <code>(?=...)</code> 与 <code>(?!...)</code><br></p>

<p>
下面的正则表达式用于检查密码，由3~6个字母和至少1个数字组成<br></p>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">password</span> <span class="o">=</span> <span class="s2">"abc123"</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">checkPass</span> <span class="o">=</span> <span class="sr">/(?=\w{3,6})(?=\D*\d)/</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">checkPass</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">password</span><span class="p">);</span> <span class="c1">// Returns true</span>
</pre></div>

<p>
下面的正则表达式用于检查密码，有5个以上的字符和至少2个数字组成<br></p>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">sampleWord</span> <span class="o">=</span> <span class="s2">"astronaut"</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">pwRegex</span> <span class="o">=</span> <span class="sr">/(?=\w{5,})(?=\D*\d{2,})/</span><span class="p">;</span> <span class="c1">// Change this line</span>
<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">pwRegex</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">sampleWord</span><span class="p">);</span>
</pre></div>


<p>
截取字符串中的重复部分，使用括号 () 对内容进行补充，是用 \1 表示第一个捕捉到的字符<br></p>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">repeatNum</span> <span class="o">=</span> <span class="s2">"42 42 42"</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">reRegex</span> <span class="o">=</span> <span class="sr">/^(\d*)\s\1\s\1$/</span><span class="p">;</span> <span class="c1">// Change this line</span>
<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">reRegex</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">repeatNum</span><span class="p">);</span>
</pre></div>


<p>
通过截取字符串，可以对截取的字符串进行修改或替换操作，需要使用 <code>replace</code> 方法<br></p>
<div class="highlight"><pre><span></span><span class="s2">"Code Camp"</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/(\w+)\s(\w+)/</span><span class="p">,</span> <span class="s1">'$2 $1'</span><span class="p">);</span> <span class="c1">// Returns "Camp Code"</span>
</pre></div>

<p>
下面的正则表达式就是用于将 <code>good</code> 替换为 <code>okey-dokey</code><br></p>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">huhText</span> <span class="o">=</span> <span class="s2">"This sandwich is good."</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">fixRegex</span> <span class="o">=</span> <span class="sr">/good/</span><span class="p">;</span> <span class="c1">// Change this line</span>
<span class="kd">let</span> <span class="nx">replaceText</span> <span class="o">=</span> <span class="s2">"okey-dokey"</span><span class="p">;</span> <span class="c1">// Change this line</span>
<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">huhText</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="nx">fixRegex</span><span class="p">,</span> <span class="nx">replaceText</span><span class="p">);</span>
</pre></div>

<p>
使用正则表达式实现类似 <code>.trim()</code> 的功能<br></p>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">hello</span> <span class="o">=</span> <span class="s2">"   Hello, World!  "</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">wsRegex</span> <span class="o">=</span> <span class="sr">/^\s+|\s+$/g</span><span class="p">;</span> <span class="c1">// Change this line</span>
<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">hello</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="nx">wsRegex</span><span class="p">,</span> <span class="s1">''</span><span class="p">);</span> <span class="c1">// Change this line</span>
</pre></div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">elisp和python中的正则表达式</h2>
<div class="outline-text-2" id="text-3">
<p>
在emacs中内置了 <code>string-match</code> 函数进行正则表达式匹配，其函数原型为 <code>(string-match REGEXP STRING &amp;optional START)</code> ，下面就是在emacs中使用regexp的示例。<br></p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">setq</span> <span class="nv">str-regexp</span> <span class="s">"\.[h|cpp]$"</span><span class="p">)</span>
<span class="p">(</span><span class="nf">setq</span> <span class="nv">str-sample-1</span> <span class="s">"sample1.h"</span><span class="p">)</span>
<span class="p">(</span><span class="nf">string-match</span> <span class="nv">str-regexp</span> <span class="nv">str-sample-1</span><span class="p">)</span>
</pre></div>

<p>
python中内置了 <code>re</code> 模块用于正则表达式匹配，下面就是在python中的regexp示例。<br></p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>
<span class="n">pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">"Cookie"</span>
<span class="n">sequence</span> <span class="o">=</span> <span class="s2">"Cookie"</span>
<span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">sequence</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"Match!"</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"Not a match!"</span><span class="p">)</span>
</pre></div>
</div>
</div>


<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">参考资料</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li>
<a href="https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/regular-expressions">FCC regular-expression tutorial</a><br>
</li>
<li>
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Simple-Match-Data.html">emacs string-match manual</a><br>
</li>
<li>
<a href="https://docs.python.org/3/library/re.html">python re module</a><br>
</li>
</ul>
</div>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/blog/posts/map-reduce/" class="u-url">MapReduce模型</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-08-20T10:09:10+08:00" itemprop="datePublished" title="2018-08-20 10:09">Aug 20 2018</time>
</div>

        

        
    <div class="comment blur-1">
      
        
    <a href="/blog/posts/map-reduce/#disqus_thread" data-disqus-identifier="cache/archives/2018/map-reduce.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/blog/tags/big-data/" rel="tag">big data</a></li>
        <li><a class="tag p-category" href="/blog/tags/distributed-system/" rel="tag">distributed system</a></li>
        <li><a class="tag p-category" href="/blog/tags/hadoop/" rel="tag">hadoop</a></li>
        <li><a class="tag p-category" href="/blog/tags/mapreduce/" rel="tag">mapreduce</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">序言</h2>
<div class="outline-text-2" id="text-1">
<p>
对于mapreduce的兴趣起源于我最近在学习javascript时遇到了map和reduce函数。使用这两个函数进行数据处理时，总感觉思路有一点奇特，理解起来需要绕一个弯子。之前在学python时，也看到过这两个函数，但是当时没有在意，现在我觉得我有必要对这两个函数做一个深入的研究了。<br></p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">什么是MapReduce</h2>
<div class="outline-text-2" id="text-2">
<p>
MapReduce的深层概念远比两个函数来得复杂，它是一个编程模型，主要用于解决大数据处理问题。使用这种模式编写的程序是可并行的（parallelized）并适用于大型计算机集群。运行时由系统自动对输入数据进行分割、协调多机器间的计算任务、进行异常处理、管理机器间的内部通信。这样，没有并行计算和分布式系统相关经验的开发人员也能够借助大型分布式系统进行数据处理了。<br></p>

<p>
百度百科中给出的定义比较全面，而且很准确。<br></p>
<blockquote>
<p>
MapReduce是面向大数据并行处理的计算模型、框架和平台，它隐含了以下三层含义：<br>
1）MapReduce是一个基于集群的高性能并行计算平台（Cluster Infrastructure）。它允许用市场上普通的商用服务器构成一个包含数十、数百至数千个节点的分布和并行计算集群。<br>
2）MapReduce是一个并行计算与运行软件框架（Software Framework）。它提供了一个庞大但设计精良的并行计算软件框架，能自动完成计算任务的并行化处理，自动划分计算数据和计算任务，在集群节点上自动分配和执行任务以及收集计算结果，将数据分布存储、数据通信、容错处理等并行计算涉及到的很多系统底层的复杂细节交由系统负责处理，大大减少了软件开发人员的负担。<br>
3）MapReduce是一个并行程序设计模型与方法（Programming Model &amp; Methodology）。它借助于函数式程序设计语言Lisp的设计思想，提供了一种简便的并行程序设计方法，用Map和Reduce两个函数编程实现基本的并行计算任务，提供了抽象的操作和并行编程接口，以简单方便地完成大规模数据的编程和计算处理。<br></p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">map和reduce</h2>
<div class="outline-text-2" id="text-3">
<p>
<b>从编程语言的角度上来说</b><br>
map操作会接收到两个参数，一个列表和一个变换过程，其功能是将这个变换过程映射到每一个列表成员上，从而得到一个新的列表。<br>
reduce操作也会接收到两个参数，一个列表和一个变换过程，其功能是将这个变换过程从前向后作用在列表成员上，最终得到一个列表中条目。<br></p>

<p>
<b>从分布式系统的角度上来说</b> (以下内容摘自百度百科)<br></p>
<blockquote>
<p>
简单说来，一个映射函数就是对一些独立元素组成的概念上的列表（例如，一个测试成绩的列表）的每一个元素进行指定的操作（比如前面的例子里，有人发现所有学生的成绩都被高估了一分，它可以定义一个“减一”的映射函数，用来修正这个错误。）。事实上，每个元素都是被独立操作的，而原始列表没有被更改，因为这里创建了一个新的列表来保存新的答案。这就是说，Map操作是可以高度并行的，这对高性能要求的应用以及并行计算领域的需求非常有用。<br>
而化简操作指的是对一个列表的元素进行适当的合并（继续看前面的例子，如果有人想知道班级的平均分该怎么做？它可以定义一个化简函数，通过让列表中的元素跟自己的相邻的元素相加的方式把列表减半，如此递归运算直到列表只剩下一个元素，然后用这个元素除以人数，就得到了平均分。）。虽然他不如映射函数那么并行，但是因为化简总是有一个简单的答案，大规模的运算相对独立，所以化简函数在高度并行环境下也很有用。<br></p>
</blockquote>

<p>
我之前在学习语言层面的map和reduce时，很难理解其用途，结合分布式计算的背景知识，就能够较形象地理解map和reduce操作的过程和作用。<br></p>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">并行计算与大数据</h2>
<div class="outline-text-2" id="text-4">
<p>
mapreduce模型给并行计算带来了革命性的影响，它是目前为止最成功、最广为接受和最易于使用的大数据并行处理技术。<br></p>

<p>
mapreduce最初由google提出，并开发出了如下产品<br></p>
<ul class="org-ul">
<li>Google File System（大规模分散文件系统）<br>
</li>
<li>MapReduce （大规模分散FrameWork）<br>
</li>
<li>BigTable（大规模分散数据库）<br>
</li>
<li>Chubby（分散锁服务）<br>
</li>
</ul>
<p>
随后就有其对应的开源实现，也就是Hadoop。Hadoop是Apache软件基金会发起的一个项目，它是一种分布式数据和计算的框架，它包含许如下子项目。<br></p>
<ul class="org-ul">
<li>HDFS，hadoop distributed file system，是Google File System的开源实现<br>
</li>
<li>MapReduce，是Google MapReduce的开源实现<br>
</li>
<li>HBASE，类似Google BigTable的分布式NoSQL数据库<br>
</li>
<li>Zookeeper，分布式锁服务，类似Google Chubby<br>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">参考资料</h2>
<div class="outline-text-2" id="text-5">
<ul class="org-ul">
<li>
<a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf">google mapreduce paper</a><br>
</li>
<li>
<a href="https://baike.baidu.com/item/MapReduce/133425">百度百科 mapreduce</a><br>
</li>
<li>
<a href="https://hadoop.apache.org/">Hadoop主页</a><br>
</li>
</ul>
</div>
</div>
    </div>

  </article>
</div>



        
       <script>var disqus_shortname="samsonwang-me";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script>
</div>

      <div class="col-lg-3 col-md-3 col-sm-12 col-xs-12 sidebar">
       
<div class="sidebar-module sidebar-module-inset">
  <h4>About Me</h4>
  
        <div class="sidebar-aboutme">
        <p>Zeal for coding, C++ developer. Focused on Linux server develop. I use EMACS on a daily basis.</p>
        </div>
</div>

       
<div class="sidebar-module sidebar-module-inset">
  <h4>Categories</h4>
  
        <ol class="list-unstyled sidebar-category">
<li>
<a href="/blog/tags/category-cpp/">cpp</a>
        </li>
<li>
<a href="/blog/tags/category-emacs/">emacs</a>
        </li>
<li>
<a href="/blog/tags/category-linux/">linux</a>
        </li>
<li>
<a href="/blog/tags/category-windows/">windows</a>
        </li>
</ol>
</div>

      </div>
<!--.sidebar-->
    </div>
<!--.row-->

    

    <nav class="postindexpager"><ul class="pager">
<li class="left">
             <a href="/blog/index-6.html" rel="next">Older posts</a>
          </li>
          <li class="right">
            <a href="/blog/index-4.html" rel="prev">Newer posts</a>
          </li>
      </ul></nav><!--End of body content--><footer id="footer"><div class="text-center">
<p>Contents © 2017-2019 <a href="mailto:wangzhilv@gmail.com">Samson Wang</a>
 - Powered by <a href="https://getnikola.com/" rel="nofollow">Nikola</a>
 - Hosted on <a href="https://pages.github.com/" rel="nofollow">Github Pages</a>
 - 
<a rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/"><img alt="知识共享许可协议" style="padding-bottom:2px" src="https://i.creativecommons.org/l/by-nc/4.0/80x15.png"></a>
</p>
</div>

      
    </footer>
</div>
</div>

<div id="scroll-top" title="back to top">
  <div id="scroll-top-arrow"></div>
  <div id="scroll-top-stick"></div>
</div>


            <script src="https://cdn.staticfile.org/jquery/3.3.1/jquery.min.js"></script><script src="https://cdn.staticfile.org/jquery.colorbox/1.6.4/jquery.colorbox-min.js"></script><script src="https://cdn.staticfile.org/jquery_lazyload/1.9.7/jquery.lazyload.min.js"></script><script src="https://cdn.staticfile.org/popper.js/1.14.3/umd/popper.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.1.1/js/bootstrap.min.js"></script><script src="/blog/assets/js/moment-with-locales.min.js"></script><script src="/blog/assets/js/fancydates.js"></script><script src="/blog/assets/js/cerulean.js"></script><!-- fancy dates --><script>
  moment.locale("en");
  fancydates(0, "YYYY-MM-DD HH:mm");
</script><!-- end fancy dates -->
</body>
</html>
