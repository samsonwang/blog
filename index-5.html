<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#" lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="Personal handnote on software development">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Hack Note (old posts, page 5) | Hack Note</title>
<link href="/assets/css/bootstrap.min.css" rel="stylesheet" type="text/css">
<link href="/assets/css/font-awesome.min.css" rel="stylesheet" type="text/css">
<link href="/assets/css/code.css" rel="stylesheet" type="text/css">
<link href="/assets/css/colorbox.css" rel="stylesheet" type="text/css">
<link href="/assets/css/highlight.css" rel="stylesheet" type="text/css">
<link href="/assets/css/cerulean.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="en" href="/rss.xml">
<link rel="canonical" href="https://samsonwang.me/index-5.html">
<link rel="icon" href="/favicon.ico" sizes="64x64">
<link rel="prev" href="/index-4.html" type="text/html">
<link rel="next" href="/index-6.html" type="text/html">
<!--[if lt IE 9]><script src="/assets/js/html5.js"></script><![endif]-->
</head>
<body class="preload">
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->
<nav id="top-nav" class="navbar navbar-expand-md fixed-top mb-4 navbar-dark bg-dark"><div class="container">   <!-- This keeps the margins nice -->
    <a class="navbar-brand" href="https://samsonwang.me/">

      <span id="blog-title">Hack Note</span>
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div class="collapse navbar-collapse" id="bs-navbar">
      <ul class="navbar-nav mr-auto">
<li class="nav-item">
<a href="/archive/" class="nav-link">Archives</a>
                </li>
<li class="nav-item">
<a href="/tags/" class="nav-link">Tags</a>
                </li>
<li class="nav-item">
<a href="/listings/" class="nav-link">Listings</a>
                </li>
<li class="nav-item">
<a href="/galleries/" class="nav-link">Galleries</a>
                </li>
<li class="nav-item">
<a href="/rss.xml" class="nav-link">RSS Feed</a>

        
      </li>
</ul>
<ul class="navbar-nav navbar-right"></ul>
</div>
<!-- /.navbar-collapse -->
  </div>
<!-- /.container -->
</nav><!-- End of Menubar --><div class="container" id="content" role="main">
  <div class="body-content">
    <!--Body content-->
    <div class="row">

      <div class="col-lg-9 col-md-9 col-sm-12 col-xs-12">
        
        


  



  


<div class="postindex">
  <article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/linux-command-examples-scp/" class="u-url">Linux常用命令行指令 - scp</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-04-17T16:08:06+08:00" itemprop="datePublished" title="2018-04-17 16:08">Apr 17 2018  (16:08)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/linux-command-examples-scp/#disqus_thread" data-disqus-identifier="cache/posts/linux-command-examples-scp.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/linux/" rel="tag">linux</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <p>
<code>scp</code> 命令代表的是 secure copy，与 <code>cp</code> 命令的本地拷贝十分相似，主要区别就在于 <code>scp</code> 的路径可以是一个远程机器的路径。使用 <code>scp</code> 进行文件拷贝时，文件的传输时加密的。<br></p>
<div class="highlight"><pre><span></span>cp source_path dest_path
</pre></div>

<div id="outline-container-org42cecdc" class="outline-2">
<h2 id="org42cecdc">从远程机器向本地拷贝</h2>
<div class="outline-text-2" id="text-org42cecdc">
<p>
以下命令会把 <code>host</code> 主机上的 <code>src_path</code> 文件拷贝到本地 <code>dest_path</code> 目录中。<br></p>
<div class="highlight"><pre><span></span>scp user@host:src_path dest_path
</pre></div>
</div>
</div>

<div id="outline-container-org4563a9b" class="outline-2">
<h2 id="org4563a9b">从本地向远程机器拷贝</h2>
<div class="outline-text-2" id="text-org4563a9b">
<p>
以下命令会把本地 <code>src_path</code> 的文件拷贝打 <code>host</code> 主机上的 <code>dest_path</code> 路径上。<br></p>
<div class="highlight"><pre><span></span>scp src_path user@host:dest_path
</pre></div>
</div>
</div>

<div id="outline-container-org94db429" class="outline-2">
<h2 id="org94db429">拷贝目录下的所有文件</h2>
<div class="outline-text-2" id="text-org94db429">
<p>
可以使用 <code>-r</code> 参数完成目录的递归拷贝， <code>r</code> 代表 <code>recursive</code> 递归。<br></p>
<div class="highlight"><pre><span></span>scp -r user@host:/src_path dest_path
</pre></div>
</div>
</div>

<div id="outline-container-org6f101ab" class="outline-2">
<h2 id="org6f101ab">在拷贝时限制带宽</h2>
<div class="outline-text-2" id="text-org6f101ab">
<p>
可以使用 <code>-l</code> 参数限制传输的带宽， <code>l</code> 代表 <code>limit</code> 限制，限制带宽的单位是 <code>kbps</code> 。<br>
命令会在将拷贝传输的速度限制为 100kbps。<br></p>
<div class="highlight"><pre><span></span>scp -l 100 src_path dest_path
</pre></div>
</div>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/cpp11-automatic-deduction-and-decltype/" class="u-url">C++11新特性：自动类型推导</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-04-16T08:44:40+08:00" itemprop="datePublished" title="2018-04-16 08:44">Apr 16 2018  (08:44)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/cpp11-automatic-deduction-and-decltype/#disqus_thread" data-disqus-identifier="cache/posts/cpp11-automatic-deduction-and-decltype.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/cpp/" rel="tag">cpp</a></li>
        <li><a class="tag p-category" href="/tags/cpp11/" rel="tag">cpp11</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <div id="outline-container-orga3e368f" class="outline-2">
<h2 id="orga3e368f">关键字 <code>auto</code> 用于自动类型推导</h2>
<div class="outline-text-2" id="text-orga3e368f">
<div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>     <span class="c1">// int</span>
<span class="k">auto</span> <span class="n">c</span><span class="o">=</span><span class="sc">'a'</span><span class="p">;</span>   <span class="c1">// char</span>
<span class="k">auto</span> <span class="n">d</span><span class="o">=</span><span class="mf">0.5</span><span class="p">;</span>   <span class="c1">// double</span>
</pre></div>

<p>
自动类型推导主要用于声明比较复杂的变量，或者变量是在泛型编程（模板）中自动生成出来的。<br></p>
<div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vecNumbers</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">vecNumbers</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
<span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">vecNumbers</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
</pre></div>
</div>
</div>

<div id="outline-container-orgef4ea1d" class="outline-2">
<h2 id="orgef4ea1d">
<code>auto</code> 类型推导并不会指定 <code>const</code> 和 <code>volatile</code> 属性</h2>
<div class="outline-text-2" id="text-orgef4ea1d">
<p>
如果需要限定声明的变量为 <code>const</code> 和 <code>volatile</code> 属性，需要额外提供相应的关键字限定。因为编译器并不能推断出声明的变量是否具有常值属性和易失属性。<br></p>
<div class="highlight"><pre><span></span><span class="k">volatile</span> <span class="k">auto</span> <span class="n">num</span><span class="o">=</span><span class="mi">5</span><span class="p">;</span>           <span class="c1">// volatile int</span>
<span class="k">auto</span> <span class="k">volatile</span> <span class="k">const</span> <span class="n">var</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>  <span class="c1">//const valatile bool</span>
<span class="k">auto</span> <span class="k">const</span> <span class="n">ch</span><span class="o">=</span><span class="sc">'a'</span><span class="p">;</span>             <span class="c1">// const char</span>
</pre></div>
</div>
</div>

<div id="outline-container-org2eab8cf" class="outline-2">
<h2 id="org2eab8cf">关键字 <code>decltype</code> 用于获取一个对量的类型</h2>
<div class="outline-text-2" id="text-org2eab8cf">
<p>
使用 <code>decltype</code> 存储一个对象或表达式的类型， <code>decltype</code> 可以看做是 <code>auto</code> 的补充。<br></p>
<div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vecNumbers</span><span class="p">;</span>
<span class="k">typedef</span> <span class="nf">decltype</span><span class="p">(</span><span class="n">vecNumbers</span><span class="p">.</span><span class="n">begin</span><span class="p">())</span> <span class="n">Iterator</span><span class="p">;</span>
<span class="n">Iterator</span> <span class="n">it2</span><span class="p">;</span>
</pre></div>
</div>
</div>

<div id="outline-container-org15ff8ca" class="outline-2">
<h2 id="org15ff8ca">函数返回值类型推导</h2>
<div class="outline-text-2" id="text-org15ff8ca">
<p>
在C++11中可以使用 <code>auto</code> 和 <code>decltype</code> 完成函数返回类型的推导。<br>
旧的函数声明格式 <code>return_type func_name(param_type param, ...);</code><br>
新的函数声明格式示例如下，以下函数接收 <code>bool</code> 作为函数的参数，并返回 <code>bool</code> 类型的结果。<br></p>
<div class="highlight"><pre><span></span><span class="k">auto</span> <span class="nf">func_name</span><span class="p">(</span><span class="kt">bool</span> <span class="n">bParam</span><span class="p">)</span><span class="o">-&gt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">bParam</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">bParam</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>
函数返回值类型推导在模板泛型编程中非常有用，模板函数能够定义一个通用的返回类型，返回值类型会根据 <code>decltype</code> 自动推导。<br>
新的函数声明格式更易于维护，因为返回值并没有作为硬编码写入源文件中，但这样做可能会牺牲代码的可读性。<br></p>
<div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">get_end</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vecNumbers</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">get_end</span><span class="p">(</span><span class="n">vecNumbers</span><span class="p">);</span>      <span class="c1">// returns iterator</span>

<span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vecNumbers2</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">it2</span> <span class="o">=</span> <span class="n">get_enm</span><span class="p">(</span><span class="n">vecNumbers2</span><span class="p">);</span>    <span class="c1">// returns const_iterator</span>
</pre></div>
</div>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/fifo-pipe-unix-domain-socket/" class="u-url">Linux下的FIFO、pipe、unix domain socket漫谈</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-04-11T13:03:25+08:00" itemprop="datePublished" title="2018-04-11 13:03">Apr 11 2018  (13:03)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/fifo-pipe-unix-domain-socket/#disqus_thread" data-disqus-identifier="cache/posts/fifo-pipe-unix-domain-socket.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/fifo/" rel="tag">fifo</a></li>
        <li><a class="tag p-category" href="/tags/ipc/" rel="tag">ipc</a></li>
        <li><a class="tag p-category" href="/tags/linux/" rel="tag">linux</a></li>
        <li><a class="tag p-category" href="/tags/pipe/" rel="tag">pipe</a></li>
        <li><a class="tag p-category" href="/tags/socket/" rel="tag">socket</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <p>
在做Linux开发时，经常会接触 <code>管道</code> 、 <code>AF_UNIX</code> 等相关词汇，为了弄清他们之间的关系，查阅了一些资料，将结果整理并记录下来。<br></p>

<div id="outline-container-org2a30657" class="outline-2">
<h2 id="org2a30657">1. <code>FIFO</code> 与 <code>pipe</code> 的比较</h2>
<div class="outline-text-2" id="text-org2a30657">
<p>
FIFO可以通过 <code>mkfifo fifo_file</code> 在本地创建一个文件用来表示一个管道，数据的交换是在操作系统内核完成的，所以在文件中没有内容。<br>
FIFO可以看做是一个带有名字的管道，我们在命令行中使用的管道是匿名管道。<br></p>

<blockquote>
<p>
A FIFO special file (a named pipe) is similar to a pipe, except that it is accessed as part of the file system. It can be opened by multiple processes for reading or writing. When processes are exchanging data via the FIFO, the kernel passes all data internally without writing it to the file system. Thus, the FIFO special file has no contents on the file system; the file system entry merely serves as a reference point so that processes can access the pipe using a name in the file system.<br></p>
</blockquote>
<p>
以上内容截取自Linux的帮助文档（ <code>man fifo</code> ）<br></p>
</div>
</div>

<div id="outline-container-org5b40819" class="outline-2">
<h2 id="org5b40819">2. <code>FIFO</code> 与 <code>unix domain socket</code> 的比较</h2>
<div class="outline-text-2" id="text-org5b40819">
<p>
FIFO与unix domain socket在他们的实现方式上有相似之处，但是他们是完全不同的两个概念。<br>
FIFO是更底层的进程间通信方式，允许一端写入数据，另外一端读取数据；unix domain socket与 <code>TCP/IP</code> 的套接字很相似。<br>
socket是双工的，支持多个进程同时访问。进程可以一个socket上同时允许多个客户端进程接入。在每次有新的 <code>connect</code> 或 <code>accept</code> 时， 操作系统内核会分配一个新的文件描述符，通信数据包会送达正确的进程。<br>
FIFO并不支持以上特性。需要两个FIFO才能完成双工通信。对于每个客户端都需要一对FIFO才能完成通信交互。<br></p>

<blockquote>
<p>
UNIX domain sockets and FIFO may share some part of their implementation but they are conceptually very different. FIFO functions at a very low level. One process writes bytes into the pipe and another one reads from it. A UNIX domain socket has the same behaviour as a TCP/IP socket.<br></p>

<p>
A socket is bidirectional and can be used by a lot of processes simultaneously. A process can accept many connections on the same socket and attend several clients simultaneously. The kernel delivers a new file descriptor each time connect(2) or accept(2) is called on the socket. The packets will always go to the right process.<br>
On a FIFO, this would be impossible. For bidirectional comunication, you need two FIFOs, and you need a pair of FIFOs for each of your clients. There is no way of writing or reading in a selective way, because they are a much more primitive way to communicate.<br></p>

<p>
Anonymous pipes and FIFOs are very similar. The difference is that anonymous pipes don't exist as files on the filesystem so no process can open(2) it. They are used by processes that share them by another method. If a process opens a FIFOs and then performs, for example, a fork(2), its child will inherit its file descriptors and, among them, the pipe.<br></p>

<p>
The UNIX domain sockets, anonymous pipes and FIFOs are similar in the fact they use shared memory segments. The details of implementation may vary from one system to another but the idea is always the same: attach the same portion of memory in two distinct processes memory mapping to have them sharing data<br>
(edit: that would one obvious way to implement it but that is not how it is actually done in Linux, which simply uses the kernel memory for the buffers, see answer by @tjb63 below).<br>
The kernel then handles the system calls and abstracts the mechanism.<br></p>
</blockquote>
<p>
以上内容截取自 <a href="https://unix.stackexchange.com/questions/75904/are-fifo-pipe-unix-domain-socket-the-same-thing-in-linux-kernel">unix stackexchange</a><br></p>
</div>
</div>

<div id="outline-container-org15063fb" class="outline-2">
<h2 id="org15063fb">3. <code>unix-domain-socket</code> 与 <code>ip socket</code> 的比较</h2>
<div class="outline-text-2" id="text-org15063fb">
<p>
unix domain socket是一种进程间通信方式，支持跑在同一个机器上的两个进程的双向数据交互。<br>
ip socket是一种网络通信方式，能够让两个进程通过网络完成数据交互。<br>
unix domain socket是针对于文件系统限制访问权限，而ip socket只能在过滤包的级别完成访问控制。<br>
unix domain socket比ip socket的效率更高，因为省去了校验检查、路由等操作步骤。<br></p>

<p>
以下内容摘抄自 freebsd list:<br></p>
<blockquote>
<p>
There are a few differences that might be of interest, in addition to the already pointed out difference that if you start out using IP sockets, you don't have to migrate to them later when you want inter-machine connectivity:<br></p>

<ul class="org-ul">
<li>UNIX domain sockets use the file system as the address name space.  This means you can use UNIX file permissions to control access to communicate with them.  I.e., you can limit what other processes can connect to the daemon – maybe one user can, but the web server can't, or the like. With IP sockets, the ability to connect to your daemon is exposed off the current system, so additional steps may have to be taken for security.  On the other hand, you get network transparency.  With UNIX domain sockets, you can actually retrieve the credential of the process that created the remote socket, and use that for access control also, which can be quite convenient on multi-user systems.<br>
</li>

<li>IP sockets over localhost are basically looped back network on-the-wire IP. There is intentionally "no special knowledge" of the fact that the connection is to the same system, so no effort is made to bypass the normal IP stack mechanisms for performance reasons. For example, transmission over TCP will always involve two context switches to get to the remote socket, as you have to switch through the netisr, which occurs following the "loopback" of the packet through the synthetic loopback interface. Likewise, you get all the overhead of ACKs, TCP flow control, encapsulation/decapsulation, etc. Routing will be performed in order to decide if the packets go to the localhost. Large sends will have to be broken down into MTU-size datagrams, which also adds overhead for large writes.  It's really TCP, it just goes over a loopback interface by virtue of a special address, or discovering that the address requested is served locally rather than over an ethernet (etc).<br>
</li>

<li>UNIX domain sockets have explicit knowledge that they're executing on the same system. They avoid the extra context switch through the netisr, and a sending thread will write the stream or datagrams directly into the receiving socket buffer. No checksums are calculated, no headers are inserted, no routing is performed, etc. Because they have access to the remote socket buffer, they can also directly provide feedback to the sender when it is filling, or more importantly, emptying, rather than having the added overhead of explicit acknowledgement and window changes. The one piece of functionality that UNIX domain sockets don't provide that TCP does is out-of-band data. In practice, this is an issue for almost noone.<br>
</li>
</ul>
<p>
In general, the argument for implementing over TCP is that it gives you location independence and immediate portability – you can move the client or the daemon, update an address, and it will "just work".  The sockets layer provides a reasonable abstraction of communications services, so it's not hard to write an application so that the connection/binding portion knows about TCP and UNIX domain sockets, and all the rest just uses the socket it's given.  So if you're looking for performance locally, I think UNIX domain sockets probably best meet your need.  Many people will code to TCP anyway because performance is often less critical, and the network portability benefit is substantial.<br></p>

<p>
Right now, the UNIX domain socket code is covered by a subsystem lock; I have a version that used more fine-grain locking, but have not yet evaluated the performance impact of those changes.  I've you're running in an SMP environment with four processors, it could be that those changes might positively impact performance, so if you'd like the patches, let me know.  Right now they're on my schedule to start testing, but not on the path for inclusion in FreeBSD 5.4.  The primary benefit of greater granularity would be if you had many pairs of threads/processes communicating across processors using UNIX domain sockets, and as a result there was substantial contention on the UNIX domain socket subsystem lock. The patches don't increase the cost of normal send/receive operations, but due add extra mutex operations in the listen/accept/connect/bind paths.<br></p>

<p>
Robert N M Watson<br></p>
</blockquote>

<p>
参考资料如下：<br></p>
<ul class="org-ul">
<li>
<a href="https://unix.stackexchange.com/questions/236983/differences-between-unix-domain-sockets-and-network-sockets?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa">unix stackexchange</a><br>
</li>
<li>
<a href="https://lists.freebsd.org/pipermail/freebsd-performance/2005-February/001143.html">lists freebsd</a><br>
</li>
</ul>
</div>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/debug-with-gdb-on-linux-2/" class="u-url">Linux下使用gdb的调试技巧（2）</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-04-03T22:51:39+08:00" itemprop="datePublished" title="2018-04-03 22:51">Apr 03 2018  (22:51)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/debug-with-gdb-on-linux-2/#disqus_thread" data-disqus-identifier="cache/posts/debug-with-gdb-on-linux-2.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/gdb/" rel="tag">gdb</a></li>
        <li><a class="tag p-category" href="/tags/linux/" rel="tag">linux</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <p>
相关文章：<a href="https://samsonwang.me/posts/debug-with-gdb-on-linux/">Linux下使用gdb的调试技巧（1）</a><br></p>

<p>
本文重点介绍在gdb模式下的常用命令。<br></p>

<p>
查看帮助信息<br></p>
<div class="highlight"><pre><span></span>(gdb) help all
</pre></div>

<p>
查看线程信息<br></p>
<div class="highlight"><pre><span></span>(gdb) info thread
</pre></div>

<p>
切换到某一线程<br></p>
<div class="highlight"><pre><span></span>(gdb) thread 2
</pre></div>

<p>
查看调用堆栈信息<br></p>
<div class="highlight"><pre><span></span>(gdb) bt
</pre></div>

<p>
查看某个调用栈<br></p>
<div class="highlight"><pre><span></span>(gdb) frame 3
</pre></div>

<p>
增加断点<br>
断点格式：<br></p>
<ul class="org-ul">
<li>函数名<br>
</li>
<li>文件名：行号<br>
</li>
<li>当前调试文件的行号<br>
</li>
</ul>
<div class="highlight"><pre><span></span>(gdb) breakpoint xxx
</pre></div>

<p>
删除断点<br></p>
<div class="highlight"><pre><span></span>(gdb) delete xxx
</pre></div>

<p>
启用/禁用断点<br></p>
<div class="highlight"><pre><span></span>(gdb) disable/enable xxx
</pre></div>

<p>
查看断点信息<br></p>
<div class="highlight"><pre><span></span>(gdb) info break
</pre></div>

<p>
临时断点，临时断点的使用方法与普通断点相同<br></p>
<div class="highlight"><pre><span></span>(gdb) tb xxx
</pre></div>

<p>
在gdb模式下，回车会执行上一次输入的命令<br></p>

<p>
运行到指定行<br></p>
<div class="highlight"><pre><span></span>until 81
</pre></div>

<p>
在gdb中打印长字符串<br></p>
<div class="highlight"><pre><span></span>(gdb) set print element 0
</pre></div>

<p>
在gdb中强制在一个线程内调试运行<br></p>
<div class="highlight"><pre><span></span>set scheduler-locking step
</pre></div>

<p>
在gdb中向程序发送信号<br></p>
<div class="highlight"><pre><span></span>(gdb) signal
</pre></div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/change-linux-timezone-with-cli/" class="u-url">使用命令行修改Linux系统的时区</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-04-03T21:32:42+08:00" itemprop="datePublished" title="2018-04-03 21:32">Apr 03 2018  (21:32)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/change-linux-timezone-with-cli/#disqus_thread" data-disqus-identifier="cache/posts/change-linux-timezone-with-cli.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/linux/" rel="tag">linux</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <p>
<b>系统时区目录</b> 系统支持时区的配置文件存放在 <code>/usr/share/zoneinfo/</code> 目录下，可以进入到该目录下查看和搜索目标时区的相关配置文件。<br></p>

<p>
<b>时区配置文件</b> Linux系统的当前时区配置文件存放在 <code>/etc/localtime</code> , 可以将时区配置文件拷贝到该位置下，也可以建立一个软连接指向系统时区目录中的配置文件。<br></p>

<p>
<b>操作示例</b> 以将系统的时区改为中国时间为例，以下操作先将旧的时区配置文件删掉，然后建立新的时区配置文件的符号链接。<br></p>
<div class="highlight"><pre><span></span>rm /etc/localtime
ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
</pre></div>
<p>
完成以上操作后，可以执行 <code>date</code> 命令查看修改效果。<br></p>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/linux-command-examples-netstat/" class="u-url">Linux常用命令行指令 - netstat</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-03-28T22:55:16+08:00" itemprop="datePublished" title="2018-03-28 22:55">Mar 28 2018  (22:55)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/linux-command-examples-netstat/#disqus_thread" data-disqus-identifier="cache/posts/linux-command-examples-netstat.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/linux/" rel="tag">linux</a></li>
        <li><a class="tag p-category" href="/tags/network/" rel="tag">network</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <p>
常见的选项有：<br>
-a (all)显示所有选项，netstat默认不显示LISTEN相关<br>
-t (tcp)仅显示tcp相关选项<br>
-u (udp)仅显示udp相关选项<br>
-n 拒绝显示别名，能显示数字的全部转化成数字。(重要)<br>
-l 仅列出有在 Listen (监听) 的服务状态<br>
-p 显示建立相关链接的程序名(macOS中表示协议 -p protocol)<br>
-r 显示路由信息，路由表<br>
-e 显示扩展信息，例如uid等<br>
-s 按各个协议进行统计 (重要)<br>
-c 每隔一个固定时间，执行该netstat命令。<br></p>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/linux-command-examples-tcpdump/" class="u-url">Linux常用命令行指令 - tcpdump</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-03-25T23:34:53+08:00" itemprop="datePublished" title="2018-03-25 23:34">Mar 25 2018  (23:34)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/linux-command-examples-tcpdump/#disqus_thread" data-disqus-identifier="cache/posts/linux-command-examples-tcpdump.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/linux/" rel="tag">linux</a></li>
        <li><a class="tag p-category" href="/tags/network/" rel="tag">network</a></li>
        <li><a class="tag p-category" href="/tags/shell/" rel="tag">shell</a></li>
        <li><a class="tag p-category" href="/tags/tcpdump/" rel="tag">tcpdump</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <p>
tcpdump常用于网络抓包，能够将抓取的包保存下来，这样就能进一步深入分析。抓包保存的文件可以使用tcpdump进行查看，也可以借助第三方软件（如wireshark）进行辅助分析。<br></p>

<div id="outline-container-org53be467" class="outline-2">
<h2 id="org53be467">1. 抓取指定网络设备上的包</h2>
<div class="outline-text-2" id="text-org53be467">
<p>
抓取网卡eth0上的包<br></p>
<div class="highlight"><pre><span></span>tcpdump -i eth0
</pre></div>
</div>
</div>
<div id="outline-container-org3f2f51a" class="outline-2">
<h2 id="org3f2f51a">2. 限制抓包的数量</h2>
<div class="outline-text-2" id="text-org3f2f51a">
<p>
只抓取5个包<br></p>
<div class="highlight"><pre><span></span>tcpdump -c 5 -i eth0
</pre></div>
</div>
</div>
<div id="outline-container-orgf3042b7" class="outline-2">
<h2 id="orgf3042b7">3. 将抓取的包以ASCII的方式打印出来</h2>
<div class="outline-text-2" id="text-orgf3042b7">
<div class="highlight"><pre><span></span>tcpdump -A -i eth0
</pre></div>
</div>
</div>
<div id="outline-container-orgb609b3d" class="outline-2">
<h2 id="orgb609b3d">4. 将抓取的包以十六进制的方式打印出来</h2>
<div class="outline-text-2" id="text-orgb609b3d">
<div class="highlight"><pre><span></span>tcpdump -XX -i eth0
</pre></div>
</div>
</div>
<div id="outline-container-orge2a02b4" class="outline-2">
<h2 id="orge2a02b4">5. 对抓取到的包上打出更方便阅读的时间戳</h2>
<div class="outline-text-2" id="text-orge2a02b4">
<p>
增加 <code>-t</code> 参数能够将抓取到的包中的时间以方便阅读的形式打印出来，使用 <code>-tttt</code> 参数能够将包中的时间戳以更详细的方式打印出来。<br></p>
<div class="highlight"><pre><span></span>tcpdump -t -i eth0
tcpdump -tttt -i eth0
</pre></div>
</div>
</div>
<div id="outline-container-orgb2a4ca2" class="outline-2">
<h2 id="orgb2a4ca2">6. 将抓取的包写入到文件中</h2>
<div class="outline-text-2" id="text-orgb2a4ca2">
<div class="highlight"><pre><span></span>tcpdump -w netdump.pcap -i eth0
</pre></div>
</div>
</div>
<div id="outline-container-orgaedf28a" class="outline-2">
<h2 id="orgaedf28a">7. 读取抓到的包</h2>
<div class="outline-text-2" id="text-orgaedf28a">
<div class="highlight"><pre><span></span>tcpdump -r netdump.pcap
</pre></div>
</div>
</div>
<div id="outline-container-orgd04e8d1" class="outline-2">
<h2 id="orgd04e8d1">8. 在抓到的包中显示ip地址</h2>
<div class="outline-text-2" id="text-orgd04e8d1">
<p>
增加 <code>-n</code> 参数不会解析主机名，增加 <code>-nn</code> 参数不会解析主机名和端口名<br></p>
<div class="highlight"><pre><span></span>tcpdump -n -i eth0
tcpdump -nn -i eth0
</pre></div>
</div>
</div>
<div id="outline-container-org9594b3a" class="outline-2">
<h2 id="org9594b3a">9. 以绝对值显示包的ISN号</h2>
<div class="outline-text-2" id="text-org9594b3a">
<div class="highlight"><pre><span></span>tcpdump -S -i eth0
</pre></div>
</div>
</div>
<div id="outline-container-org718e3e5" class="outline-2">
<h2 id="org718e3e5">10. 对抓取到的包显示更详细的信息</h2>
<div class="outline-text-2" id="text-org718e3e5">
<p>
参数 <code>-v</code> 是verbose的缩写，以下命令表示对抓取到的包显示更详细的信息。<br></p>
<div class="highlight"><pre><span></span>tcpdump -v -i eth0
tcpdump -vv -i eth0
tcpdump -vvv -i eth0
</pre></div>
</div>
</div>
<div id="outline-container-orgc736ab5" class="outline-2">
<h2 id="orgc736ab5">11. 对抓到的包进行协议类型过滤</h2>
<div class="outline-text-2" id="text-orgc736ab5">
<p>
支持的协议类型有：fddi, tr, wlan, ip, ip6, arp, rarp, decnet, tcp, udp<br>
以下命令只会抓取网卡eth0上的arp包<br></p>
<div class="highlight"><pre><span></span>tcpdump -i eth0 arp
</pre></div>
</div>
</div>
<div id="outline-container-org0860201" class="outline-2">
<h2 id="org0860201">12. 在抓包时对包进行大小过滤</h2>
<div class="outline-text-2" id="text-org0860201">
<p>
下面的命令会分别抓取大于1024字节和小于1024字节的包<br></p>
<div class="highlight"><pre><span></span>tcpdump -i eth0 greater 1024
tcpdump -i eth0 less 1024
</pre></div>
</div>
</div>
<div id="outline-container-org7432c83" class="outline-2">
<h2 id="org7432c83">13. 抓取指定端口上的包</h2>
<div class="outline-text-2" id="text-org7432c83">
<div class="highlight"><pre><span></span>tcpdump -i eth0 port 22
</pre></div>
</div>
</div>
<div id="outline-container-orgca49a1e" class="outline-2">
<h2 id="orgca49a1e">14. 抓取发往指定目的和端口上包</h2>
<div class="outline-text-2" id="text-orgca49a1e">
<p>
可以使用 <code>and</code> 和 <code>or</code> 对过滤条件进行组合以实现精确的抓包。<br></p>
<div class="highlight"><pre><span></span>tcpdump -w net_dump.pcap -i eth0 dst 10.181.140.216 and port 22
</pre></div>
</div>
</div>

<div id="outline-container-orga2f5117" class="outline-2">
<h2 id="orga2f5117">常用tcpdump命令示例</h2>
<div class="outline-text-2" id="text-orga2f5117">
<div class="highlight"><pre><span></span>tcpdump –i any 'port 8888'
tcpdump –i any 'tcp port 8888'
tcpdump –i any 'tcp src port 8888'
tcpdump –i any 'tcp src port 8888 and udp dst port 9999'
tcpdump -i any 'src host 127.0.0.1 and tcp src port 12345' -XX -nn -vv
</pre></div>
</div>
</div>

<div id="outline-container-orgcd513a7" class="outline-2">
<h2 id="orgcd513a7">参考资料</h2>
<div class="outline-text-2" id="text-orgcd513a7">
<ul class="org-ul">
<li>
<a href="https://danielmiessler.com/study/tcpdump/">danielmiessler.com tcpdump</a><br>
</li>
<li>
<a href="https://www.thegeekstuff.com/2010/08/tcpdump-command-examples/">thegeekstuff.com tcpdump</a><br>
</li>
</ul>
</div>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/linux-command-examples-nc/" class="u-url">Linux常用命令行指令 - nc</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-03-24T10:01:10+08:00" itemprop="datePublished" title="2018-03-24 10:01">Mar 24 2018  (10:01)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/linux-command-examples-nc/#disqus_thread" data-disqus-identifier="cache/posts/linux-command-examples-nc.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/linux/" rel="tag">linux</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <p>
<code>nc</code> 命令是 <code>netcat</code> 的缩写，能够使用TCP或UDP协议读写网络连接中的数据，是一个方便可靠的调试工具。<br></p>

<div id="outline-container-org8e6114b" class="outline-2">
<h2 id="org8e6114b">1. 基本 <code>C/S</code> 模型</h2>
<div class="outline-text-2" id="text-org8e6114b">
<p>
作为服务端建立监听<br></p>
<div class="highlight"><pre><span></span>nc -l 127.0.0.1 8060
</pre></div>
<p>
作为客户端连接端口<br></p>
<div class="highlight"><pre><span></span>nc 172.0.0.1 8060
</pre></div>
<p>
但是需要注意的是，该服务端只允许一个客户端连接进来。<br><code>nc</code> 会默认以TCP协议运行，可以增加 <code>-u</code> 参数转换为UDP协议。<br></p>
</div>
</div>

<div id="outline-container-org8a7c9ba" class="outline-2">
<h2 id="org8a7c9ba">2. 文件传输</h2>
<div class="outline-text-2" id="text-org8a7c9ba">
<p>
模拟客户端向服务端传输文件的示例代码如下，同理，也可以模拟服务端向客户端发送文件。<br></p>
<div class="highlight"><pre><span></span>nc -l 1234  &gt; filename.out
nc 127.0.0.1 1234 &lt; fielname.in
</pre></div>
</div>
</div>

<div id="outline-container-org9cd34a7" class="outline-2">
<h2 id="org9cd34a7">3. 连接远程系统</h2>
<div class="outline-text-2" id="text-org9cd34a7">
<p>
已连接http服务器为例，在作为客户端连接以后，可以向服务器发送 <code>GET /HTTP/1.1</code> 来获取网站的主页。<br>
示例代码如下<br></p>
<div class="highlight"><pre><span></span>print "GET /HTTP/1.0 \r\n"| nc host.example.com 80
</pre></div>
</div>
</div>

<div id="outline-container-org3520160" class="outline-2">
<h2 id="org3520160">4. 简易代理</h2>
<div class="outline-text-2" id="text-org3520160">
<p>
将nc命令嵌套使用，可以将一个端口中的数据转发到目的ip和端口。<br></p>
<div class="highlight"><pre><span></span>ncat -l 8080 | ncat 192.168.1.200 80
</pre></div>
<p>
通过上面的命令能够将本机8080端口的数据转发到192.168.1.200的80端口上，但是这样是单向的。可以建立 <code>fifo</code> 实现数据的双向传输。<br></p>
<div class="highlight"><pre><span></span>mkfifo ./fifo_temp
ncat -l 8080 0&lt;fifo_temp | ncat 192.168.1.200 80 1&gt;fifo_temp
</pre></div>
</div>
</div>

<div id="outline-container-org4f99823" class="outline-2">
<h2 id="org4f99823">5. 参考资料</h2>
<div class="outline-text-2" id="text-org4f99823">
<ul class="org-ul">
<li>
<a href="https://www.linuxtechi.com/nc-ncat-command-examples-linux-systems/">linuxtech</a><br>
</li>
<li>
<a href="https://www.thegeekstuff.com/2012/04/nc-command-examples/?utm_source=feedburner">thegeekstuff</a><br>
</li>
<li>
<a href="https://www.computerhope.com/unix/nc.htm">computerhope</a><br>
</li>
</ul>
</div>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/linux-command-examples-lsof/" class="u-url">Linux常用命令行指令 - lsof</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-03-21T20:28:34+08:00" itemprop="datePublished" title="2018-03-21 20:28">Mar 21 2018  (20:28)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/linux-command-examples-lsof/#disqus_thread" data-disqus-identifier="cache/posts/linux-command-examples-lsof.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/linux/" rel="tag">linux</a></li>
        <li><a class="tag p-category" href="/tags/shell/" rel="tag">shell</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <p>
lsof是list open files的简称，用于列出系统中所有打开的文件。由于在linux系统下，所有 对象都是文件，所以这个指令十分有用。<br></p>

<p>
下面就给出了几种常见的用法，需要注意的是有些指令需要root权限执行。<br></p>

<div id="outline-container-orgbf36bd1" class="outline-2">
<h2 id="orgbf36bd1">1. 查看打开指定文件的进程</h2>
<div class="outline-text-2" id="text-orgbf36bd1">
<div class="highlight"><pre><span></span>lsof /var/syslog.log
</pre></div>
</div>
</div>

<div id="outline-container-orgeea05c5" class="outline-2">
<h2 id="orgeea05c5">2. 查看指定目录下打开的文件</h2>
<div class="outline-text-2" id="text-orgeea05c5">
<div class="highlight"><pre><span></span>lsof +D /home/
</pre></div>
</div>
</div>

<div id="outline-container-org40b3de4" class="outline-2">
<h2 id="org40b3de4">3. 查看以指定进程名所有打开的文件</h2>
<div class="outline-text-2" id="text-org40b3de4">
<p>
使用 <code>-c</code> 命令能够查看指定进程名使用的文件，允许在一个命令行指令中使用多个 <code>-c</code> 参数。<br></p>
<div class="highlight"><pre><span></span>lsof -c procname
</pre></div>
</div>
</div>

<div id="outline-container-org0ca87d9" class="outline-2">
<h2 id="org0ca87d9">4. 查看使用指定挂载点的进程</h2>
<div class="outline-text-2" id="text-org0ca87d9">
<p>
在停止挂载某个目录时，系统会告诉我们“设备资源繁忙”，所以我们需要找出使用挂载点的程序，终止这些进程，解除目录的占用状态。<br></p>
<div class="highlight"><pre><span></span>lsof /home
</pre></div>
<p>
或<br></p>
<div class="highlight"><pre><span></span>lsof +D /home/
</pre></div>
</div>
</div>

<div id="outline-container-orgba695d3" class="outline-2">
<h2 id="orgba695d3">5. 查看指定用户打开的文件</h2>
<div class="outline-text-2" id="text-orgba695d3">
<div class="highlight"><pre><span></span>lsof -u username
</pre></div>
<p>
另外还可以进行反向过滤，在输出中不显示指定用户的文件，语法如下。<br></p>
<div class="highlight"><pre><span></span>lsof -u ^username
</pre></div>
</div>
</div>

<div id="outline-container-org6d81dac" class="outline-2">
<h2 id="org6d81dac">6. 查看指定进程打开的文件</h2>
<div class="outline-text-2" id="text-org6d81dac">
<div class="highlight"><pre><span></span>lsof -p pid
</pre></div>
</div>
</div>

<div id="outline-container-org09bd5b3" class="outline-2">
<h2 id="org09bd5b3">7. 终止属于某个用户的所有进程</h2>
<div class="outline-text-2" id="text-org09bd5b3">
<div class="highlight"><pre><span></span>kill `lsof -t -u username`
</pre></div>
<p>
相似的，可以使用 <code>-t</code> 参数打印使用某个文件的进程id。<br></p>
<div class="highlight"><pre><span></span>lsof -t /var/log
</pre></div>
</div>
</div>

<div id="outline-container-org8037add" class="outline-2">
<h2 id="org8037add">8. 让结果同时满足多个选项</h2>
<div class="outline-text-2" id="text-org8037add">
<p>
默认情况下，多个参数是以或（or）进行操作的，可以使用 <code>-a</code> 选项让结果同时满足多个参数。<br></p>
<div class="highlight"><pre><span></span>lsof -a -u username -c procname
</pre></div>
</div>
</div>

<div id="outline-container-org1cef185" class="outline-2">
<h2 id="org1cef185">9. 让命令重复执行</h2>
<div class="outline-text-2" id="text-org1cef185">
<p>
可以使用 <code>-r</code> 参数让命令重复执行。以下命令会每隔5s执行一次，每次的执行结果会用 “====” 分割开。<br></p>
<div class="highlight"><pre><span></span>lsof -u username -c procname -a -r5
</pre></div>
</div>
</div>

<div id="outline-container-org27ae85a" class="outline-2">
<h2 id="org27ae85a">10. 列出所有的网络连接</h2>
<div class="outline-text-2" id="text-org27ae85a">
<div class="highlight"><pre><span></span>lsof -i
</pre></div>
<p>
让结果中的ip地址和端口号显示数字而不是英文别名<br></p>
<div class="highlight"><pre><span></span>lsof -i -Pn
</pre></div>
<p>
显示所有的 <code>AF_UNIX</code> socket<br></p>
<div class="highlight"><pre><span></span>lsof -U
</pre></div>
</div>
</div>

<div id="outline-container-orgc66a775" class="outline-2">
<h2 id="orgc66a775">11. 列出指定进程使用的网络连接</h2>
<div class="outline-text-2" id="text-orgc66a775">
<div class="highlight"><pre><span></span>lsof -i -a -p pid
</pre></div>
</div>
</div>

<div id="outline-container-org485c795" class="outline-2">
<h2 id="org485c795">12. 查看指定端口上的监听</h2>
<div class="outline-text-2" id="text-org485c795">
<div class="highlight"><pre><span></span>lsof -i :portid
</pre></div>
</div>
</div>

<div id="outline-container-org72b8e44" class="outline-2">
<h2 id="org72b8e44">13. 列出所有tcp和udp连接</h2>
<div class="outline-text-2" id="text-org72b8e44">
<div class="highlight"><pre><span></span>lsof -i tcp; lsof -i udp
</pre></div>
</div>
</div>

<div id="outline-container-org79d9787" class="outline-2">
<h2 id="org79d9787">14. 列出所有的网络文件系统</h2>
<div class="outline-text-2" id="text-org79d9787">
<p>
网络文件系统（network file system）<br></p>
<div class="highlight"><pre><span></span>lsof -N -u username
</pre></div>
</div>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/differences-among-overload-override-and-hide/" class="u-url">重载、覆盖和隐藏的区别</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-03-19T21:51:03+08:00" itemprop="datePublished" title="2018-03-19 21:51">Mar 19 2018  (21:51)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/differences-among-overload-override-and-hide/#disqus_thread" data-disqus-identifier="cache/posts/differences-among-overload-override-and-hide.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/cpp/" rel="tag">cpp</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <p>
<b>重载（overload）</b> ：就是函数或者方法有相同的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。<br>
多个重载函数在调用的时候根据函数的参数来区别不同的函数。<br>
关键点：函数名相同，参数表不同<br></p>

<p>
<b>覆盖（override）</b> ：是指在派生类中重新对基类中的虚函数重新实现，即函数名和参数都一样，只是函数的实现体不一样。<br>
关键词：派生类中，虚函数，函数名和参数表完全相同<br></p>

<p>
<b>隐藏（hide）</b> ：派生类中的函数把基类中相同名字的函数屏蔽掉了。<br>
隐藏一词可以这么理解:在调用一个类的成员函数的时候,编译器会沿着类的继承链逐级的向上查找函数的定义,如果找到了那么就停止查找了,所以如果一个派生类和一个基类都有同一个同名(暂且不论参数是否相同)的函数,而编译器最终选择了在派生类中的函数,那么我们就说这个派生类的成员函数"隐藏"了基类的成员函数,也就是说它阻止了编译器继续向上查找函数的定义.<br></p>


<p>
关于这三种情况的示例代码如下<br></p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream.h&gt;</span><span class="cp"></span>
<span class="k">class</span> <span class="nc">Base</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Base::f(float) "</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">g</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Base::g(float) "</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">h</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Base::h(float) "</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Derived::f(float) "</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">g</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Derived::g(int) "</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">h</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Derived::h(float) "</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>

<p>
从以上代码能够看出：<br>
（1）函数Derived::f(float)覆盖了Base::f(float)。<br>
（2）函数Derived::g(int)隐藏了Base::g(float)，而不是重载。<br>
（3）函数Derived::h(float)隐藏了Base::h(float)，而不是覆盖。<br></p>

<p>
考虑代码在运行时的结果：<br></p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">Derived</span>  <span class="n">d</span><span class="p">;</span>
  <span class="n">Base</span> <span class="o">*</span><span class="n">pb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">;</span>
  <span class="n">Derived</span> <span class="o">*</span><span class="n">pd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">;</span>

  <span class="c1">// Good : behavior depends solely on type of the object</span>
  <span class="n">pb</span><span class="o">-&gt;</span><span class="n">f</span><span class="p">(</span><span class="mf">3.14f</span><span class="p">);</span> <span class="c1">// Derived::f(float) 3.14</span>
  <span class="n">pd</span><span class="o">-&gt;</span><span class="n">f</span><span class="p">(</span><span class="mf">3.14f</span><span class="p">);</span> <span class="c1">// Derived::f(float) 3.14</span>

  <span class="c1">// Bad : behavior depends on type of the pointer</span>
  <span class="n">pb</span><span class="o">-&gt;</span><span class="n">g</span><span class="p">(</span><span class="mf">3.14f</span><span class="p">);</span> <span class="c1">// Base::g(float) 3.14</span>
  <span class="n">pd</span><span class="o">-&gt;</span><span class="n">g</span><span class="p">(</span><span class="mf">3.14f</span><span class="p">);</span> <span class="c1">// Derived::g(int) 3        (surprise!)</span>

  <span class="c1">// Bad : behavior depends on type of the pointer</span>
  <span class="n">pb</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">(</span><span class="mf">3.14f</span><span class="p">);</span> <span class="c1">// Base::h(float) 3.14      (surprise!)</span>
  <span class="n">pd</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">(</span><span class="mf">3.14f</span><span class="p">);</span> <span class="c1">// Derived::h(float) 3.14</span>
<span class="p">}</span>
</pre></div>

<p>
在第一种调用中，函数的行为取决于指针所指向的对象。在第二第三种调用中，函数的行为取决于指针的类型。所以说，隐藏破坏了面向对象编程中多态这一特性，会使得开发人员产生混乱。<br></p>


<p>
<b>函数接口设计注意要点</b><br>
在设计基类的函数接口时，不要出现既是虚函数，又对该虚函数进行了重载的情况。这样会对派生类的多态函数实现造成不便。<br>
示例代码如下<br></p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Base</span>
<span class="p">{</span>
  <span class="k">virtual</span> <span class="n">foo</span><span class="p">();</span>
  <span class="k">virtual</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span>
<span class="p">{</span>
  <span class="k">virtual</span> <span class="n">foo</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
<p>
从以上代码能够看出：<br></p>
<ol class="org-ol">
<li>
<code>Derived::foo()</code> 与 <code>Base::foo()</code> 构成了多态关系<br>
</li>
<li>
<code>Derived::foo()</code> 隐藏了 <code>Base::foo(int)</code><br>
</li>
</ol>
<p>
所以，如果派生类希望实现 <code>foo()</code> 函数的多态，也就必须实现 <code>foo(int)</code> 的多态，否则就会出现隐藏。<br>
如果在现有代码中已经发生了上述 <code>Base</code> 的情况，在不改变原有代码的情况下，可以使用在派生类中使用这样的语法 <code>using Base::foo;</code> ，这会将基类中所有的名为 <code>foo</code> 的函数引入到派生类中来。<br></p>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/qt-chinese-encoding/" class="u-url">关于Qt中使用中文编码的一些问题</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-02-28T09:34:08+08:00" itemprop="datePublished" title="2018-02-28 09:34">Feb 28 2018  (09:34)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/qt-chinese-encoding/#disqus_thread" data-disqus-identifier="cache/posts/qt-chinese-encoding.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/qt/" rel="tag">qt</a></li>
        <li><a class="tag p-category" href="/tags/visual-studio/" rel="tag">visual studio</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <p>
Qt库作为一个开源库，并且支持多语言。在开发时需要考虑字符编码问题。<br>
我现在的使用Qt开发环境为VS2012+Qt5.1.1，所以一下所讨论的也是基于这个版本而言的。目前Qt5已经将 <code>tr()</code> 删掉了。<br></p>

<p>
<b>在windows下使用Qt库进行开发</b><br>
有两种主流开发环境:<br></p>
<ol class="org-ol">
<li>使用Qt Creator作为开发环境<br>
</li>
<li>使用Visual Studio + Visual Assist + Qt Visual Studio Addon作为开发环境<br>
</li>
</ol>
<p>
目前我使用的就是第二种开发环境，鉴于在Windows平台下没有哪个开发环境能与Visual Studio相媲美。<br></p>

<p>
<b>使用VS开发Qt程序时需要注意源文件的编码格式</b><br>
Qt5官方推荐的源文件编码格式为UTF-8，QString内部的编码格式就是UTF-8，使用QtCreator创建的源文件的编码格式也是UTF-8 without BOM。<br>
但是VS在中文操作系统上，如果不进行特殊的设置，默认创建的含有中文的源文件编码格式为gb3212。这样的原始字符串就是gb2312格式的，在使用时需要进行特殊转换，这样显示在界面上才不会乱码。<br>
推荐使用一下两种方法解决gb2312编码问题：<br></p>
<ul class="org-ul">
<li>
<code>QString::fromLocale8Bit()</code> 会将gb2312编码的字符串转换为UTF-8格式以便存放在QString中。<br>
</li>
<li>
<code>QStringLiteral()</code> 是一个宏定义，会在编译期将字符串实例化，对静态字符串使用这个字符串也是一个提高效率的方法(因为减少了运行时的内存申请开销)。<br>
</li>
</ul>
<p>
<b>在VS中使用utf-8 with BOM的源文件格式</b><br>
如果使用了utf-8 with BOM的源文件格式，VS会将其中的字符串转换为gb2312编码的中文，这样是为了兼容旧版本的编译器。<br>
可以使用编译选项让VS编译器不进行这项转换，这样就可以直接使用字符串 <code>char*</code> 初始化QString了。<br></p>
<ul class="org-ul">
<li>微软在VS2010中提供了 <code>#pragma execution_character_set("utf-8")</code> 这样的编译选项，能够防止编译器进行文件编码转换，保证字符串保留utf-8格式。<br>
</li>
<li>VS2012 并不支持以上编译选项，VS2012将这个特性取消了<br>
</li>
<li>VS2015 可以使用 <code>/utf-8</code> 让编译器能够识别 utf-8 without BOM格式的文件，并保留utf-8的字符串编码。<br>
</li>
</ul>
<p>
<b>C++11的编码格式支持</b><br>
对于支持C++11标准的编译器，可以采用如下的写法产生utf-8格式的字符串。<br></p>
<div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">szMsg</span> <span class="o">=</span> <span class="sa">u8</span><span class="s">"字符串"</span><span class="p">;</span>
</pre></div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/use-git-with-socks5-proxy/" class="u-url">为git设置socks5代理</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-02-08T09:26:07+08:00" itemprop="datePublished" title="2018-02-08 09:26">Feb 08 2018  (09:26)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/use-git-with-socks5-proxy/#disqus_thread" data-disqus-identifier="cache/posts/use-git-with-socks5-proxy.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/git/" rel="tag">git</a></li>
        <li><a class="tag p-category" href="/tags/vpn/" rel="tag">vpn</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <p>
在某些时候，为了绕过网络封锁，在使用git时需要借助代理完成相关网络操作。<br></p>

<p>
<b>一个可用的vpn代理是先决条件</b><br>
关于架设vpn的就不在此讨论了。<br></p>

<p>
<b>将repo的链接由ssh改为为https</b> （已经是https的repo跳过此步骤）<br>
只有https（http）的repo是支持代理的，所以如果现有的repo是使用ssh方式clone到本地的，需要修改其为https方式。<br>
需要修改 <code>repo_name/.git/config</code> 中的url配置，将其中的 <code>git格式</code> 改为 <code>https格式</code> 。<br>
以github为例，需要将 <code>git@github.com:user_name/repo_name.git</code> 改为 <code>https://github.com/user_name/repo_name.git</code><br>
可以使用 <code>sed</code> 指令完成替换。<br></p>
<div class="highlight"><pre><span></span>sed -i 's/git@github.com:/git:\/\/github.com\//' ./.git/config
</pre></div>

<p>
<b>设置git使用代理</b><br>
将git配置为使用socks5代理。<br></p>
<div class="highlight"><pre><span></span>git config --global http.proxy 'socks5://127.0.0.1:1080'
git config --global https.proxy 'socks5://127.0.0.1:1080'
</pre></div>

<p>
<b>将登录信息保存下来</b><br>
使用https时，在推送时会要求验证用户名和密码，考虑将验证信息缓存下来。<br></p>
<div class="highlight"><pre><span></span>git config --global credential.helper cache
</pre></div>
<p>
也可以考虑将用户名和密码永久保存为硬盘文件， <b>注意</b> 使用这种配置会将密码保存在 ~ <code>/.git-cretidentials</code> 文件中，仅推荐在个人电脑中将配置文件保存下来。<br></p>
<div class="highlight"><pre><span></span>git config --global credential.helper store
</pre></div>

<p>
<b>参考资料</b><br><a href="https://stackoverflow.com/questions/5343068/is-there-a-way-to-skip-password-typing-when-using-https-on-github">stackoverflow question</a><br></p>
    </div>

  </article>
</div>



        
       <script>var disqus_shortname="samsonwang-me";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script>
</div>

      <div class="col-lg-3 col-md-3 col-sm-12 col-xs-12 sidebar">
       
<div class="sidebar-module sidebar-module-inset">
  <h4>About Me</h4>
  
        <div class="sidebar-aboutme">
        <p>Zeal for coding, C++ developer. Focus on linux server dev. I use EMACS, and I am learning python.</p>
        <p>View my code on <a href="https://github.com/samsonwang"> Github</a></p>
</div>
</div>

       
<div class="sidebar-module">
  <h4>Categories</h4>
  
        <ol class="list-unstyled sidebar-category">
<li>
<a href="/tags/category-cpp/">cpp</a>
        </li>
<li>
<a href="/tags/category-emacs/">emacs</a>
        </li>
<li>
<a href="/tags/category-linux/">linux</a>
        </li>
<li>
<a href="/tags/category-windows/">windows</a>
        </li>
</ol>
</div>

      </div>
<!--.sidebar-->
    </div>
<!--.row-->

    

        <nav class="postindexpager"><ul class="pager">
<li class="next">
                <a href="/index-4.html" rel="prev">Newer posts</a>
            </li>
            <li class="previous">
                <a href="/index-6.html" rel="next">Older posts</a>
            </li>
        </ul></nav><!--End of body content--><footer id="footer"><div class="text-center">
<p>Contents © 2017-2018 <a href="mailto:wangzhilv@gmail.com">Samson Wang</a>
 - Powered by <a href="https://getnikola.com/" rel="nofollow">Nikola</a>
 - Hosted on <a href="https://pages.github.com/" rel="nofollow">Github Pages</a>
 - 
<a rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/"><img alt="知识共享许可协议" style="padding-bottom:2px" src="https://i.creativecommons.org/l/by-nc/4.0/80x15.png"></a>
</p>
</div>

      
    </footer>
</div>
</div>

<div id="scroll-top" title="back to top">
  <div id="scroll-top-arrow"></div>
  <div id="scroll-top-stick"></div>
</div>


            <script src="/assets/js/jquery.min.js"></script><script src="/assets/js/jquery.colorbox-min.js"></script><script src="/assets/js/jquery.lazyload.min.js"></script><script src="/assets/js/popper.min.js"></script><script src="/assets/js/bootstrap.min.js"></script><script src="/assets/js/moment-with-locales.min.js"></script><script src="/assets/js/fancydates.js"></script><script src="/assets/js/cerulean.js"></script><!-- fancy dates --><script>
  moment.locale("en");
  fancydates(0, "YYYY-MM-DD HH:mm");
</script><!-- end fancy dates --><!-- Baidu Analytics --><script>
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?7ec47c52179b8ca4f9aee81282bd7b20";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>
</body>
</html>
