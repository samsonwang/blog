<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Hack Note (Posts by Samson Wang)</title><link>http://samsonwang.me/</link><description></description><atom:link href="http://samsonwang.me/authors/samson-wang.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2017 &lt;a href="mailto:zl.wang@foxmail.com"&gt;Samson Wang&lt;/a&gt; </copyright><lastBuildDate>Wed, 25 Oct 2017 10:22:39 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>linux下使用gdb的调试技巧</title><link>http://samsonwang.me/posts/2017/debug-with-gdb-on-linux/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;代码编译阶段&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
在调试 &lt;code&gt;C/C++&lt;/code&gt; 代码时，在编译阶段使用 &lt;code&gt;gcc/g++ -g&lt;/code&gt; 命令编译，将调试信息生成在目标文件中。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2" class="outline-2"&gt;
&lt;h2 id="sec-2"&gt;开启gdb模式&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;直接进入gdb模式 &lt;code&gt;gdb&lt;/code&gt; 
&lt;/li&gt;
&lt;li&gt;使用gdb模式开启一个新的进程 &lt;code&gt;gdb &amp;lt;appname&amp;gt;&lt;/code&gt;
&lt;/li&gt;
&lt;li&gt;使用指定的程序来调试core文件 &lt;code&gt;gdb &amp;lt;appname&amp;gt; &amp;lt;corename&amp;gt;&lt;/code&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2-1" class="outline-3"&gt;
&lt;h3 id="sec-2-1"&gt;gdb模式中常用命令&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-1"&gt;
&lt;p&gt;
以下指令为
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;bt&lt;/code&gt; backtrace
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i r&lt;/code&gt; info registers 查看寄存器
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i proc m&lt;/code&gt; memory mappings
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b&lt;/code&gt; breakpoint
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;r&lt;/code&gt; run
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;c&lt;/code&gt; continue
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s&lt;/code&gt; step in
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;info&lt;/code&gt; info指令之后可以接
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2-2" class="outline-3"&gt;
&lt;h3 id="sec-2-2"&gt;调试一个正在运行中的进程&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-2"&gt;
&lt;p&gt;
如果一个正在运行中的程序与我们的预想不一样，我们可以使用gdb查看程序的运行状态（debug a running process）
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;方法1：使用 &lt;code&gt;gdb -p &amp;lt;pid&amp;gt;&lt;/code&gt; 命令来以attach的方式启动调试该进程id的进程
&lt;/li&gt;
&lt;li&gt;方法2：进入 &lt;code&gt;gdb&lt;/code&gt; 模式，使用 &lt;code&gt;attach &amp;lt;pid&amp;gt;&lt;/code&gt; 命令调试某个进程
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2-3" class="outline-3"&gt;
&lt;h3 id="sec-2-3"&gt;设置源文件的目录&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-3"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;files&lt;/code&gt; 命令
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;directory&lt;/code&gt; 命令
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-3" class="outline-2"&gt;
&lt;h2 id="sec-3"&gt;core 文件相关设置&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
core文件是程序异常崩溃以后产生的，会将程序异常时的执行状态以快照的形式保存下来。
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-3-1" class="outline-3"&gt;
&lt;h3 id="sec-3-1"&gt;查看core文件的设置&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-3-1"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;limit -c&lt;/code&gt;
  用于查看当前系统生成core文件的大小限制，如果设置为0，则表示不生成core文件
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cat /proc/sys/kernel/core_pattern&lt;/code&gt;
  用于查看当前系统生成core文件的命名样式
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-3-2" class="outline-3"&gt;
&lt;h3 id="sec-3-2"&gt;更改core文件的设置&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-3-2"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;limit -c unlimited&lt;/code&gt; 不限制生成core文件的大小
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;echo "core.%e.%p" &amp;gt; /proc/sys/kernel/core_pattern&lt;/code&gt; 修改core文件命名规则
core文件会默认生成在用户 &lt;code&gt;HOME&lt;/code&gt; 路径中
&lt;/li&gt;
&lt;li&gt;使core相关配置重启后仍然有效
把下面这句话添加到 &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; 中，能够使该设置在系统重启后仍然生效
&lt;/li&gt;
&lt;/ul&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# core dump pattern
kernel.core_pattern=core.%p.%e.%s  
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>gdb</category><category>linux</category><guid>http://samsonwang.me/posts/2017/debug-with-gdb-on-linux/</guid><pubDate>Tue, 24 Oct 2017 00:58:25 GMT</pubDate></item><item><title>终于，博客开通了</title><link>http://samsonwang.me/posts/2017/blog-open-up/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;1 前言&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
Samson的博客开通了。
&lt;/p&gt;

&lt;p&gt;
作为码农，一直想要有个博客作为学习与积累的记录。
&lt;/p&gt;

&lt;p&gt;
在尝试过多种主流博客套路之后，终于选定了使用 emacs + org-mode + nikola + github pages 组合的技术方案。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-sec-2" class="outline-2"&gt;
&lt;h2 id="sec-2"&gt;2 个人博客的需求整理&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
在开通博客的想法产生之后，我认真整理了自己的需求点，详细如下：
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;使用纯文本格式作为内容载体，使用网页作为内容展示
&lt;/li&gt;
&lt;li&gt;自定义程度要高，要能够根据自身的需求进行修改
&lt;/li&gt;
&lt;li&gt;标签功能，能够分类所记录的知识技能
&lt;/li&gt;
&lt;li&gt;在博文的内容中能够插入语法高亮的代码段
&lt;/li&gt;
&lt;li&gt;编写博客使用的工具尽可能最大化利用现有工具链（emacs, org-mode）
&lt;/li&gt;
&lt;li&gt;要能够在方便多平台下（Windows/Linux/macOS）的调试
&lt;/li&gt;
&lt;li&gt;源代码托管在Github平台上
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-3" class="outline-2"&gt;
&lt;h2 id="sec-3"&gt;3 折腾过的方案&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
生命在于折腾，我挑选了一些目前常见的博客方案进行了尝试和比较。
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-3-1" class="outline-3"&gt;
&lt;h3 id="sec-3-1"&gt;3.1 Markdown + Jekyll&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-3-1"&gt;
&lt;p&gt;
这种方案是GitHub Pages所推荐的方案，也是我最先接触到的方案。
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;与GitHub的深度集成，如果直接fork一个配置好的工程，你甚至都不用在自己电脑上安装Jekyll，在每次完成内容编写之后，将更改commit提交至GitHub，GitHub Pages会自动将内容转化为静态网页。
&lt;/li&gt;
&lt;li&gt;这种方案需要我放弃已经使用了很久的org-mode笔记记录方式，使用markdown作为内容的载体。
&lt;/li&gt;
&lt;li&gt;官方文档中描述Jekyll在windows目前并没有很好的原生支持。
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-3-2" class="outline-3"&gt;
&lt;h3 id="sec-3-2"&gt;3.2 org-mode + Jekyll&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-3-2"&gt;
&lt;p&gt;
我还是想使用emacs+orgmode做为内容产出的方式。
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;使用org-mode导出html功能，能够使用使用org-mode格式书写博客。
&lt;/li&gt;
&lt;li&gt;增加了导出为html的这道流程，也着实是一个痛点，如果能够直接将org-mode作为内容过的源文件就太好了
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-3-3" class="outline-3"&gt;
&lt;h3 id="sec-3-3"&gt;3.3 org-mode + org-publish / org-mode + o-blog&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-3-3"&gt;
&lt;p&gt;
后来我开始尝试寻找仅使用emacs就能完成内容编辑与网页生成的方案。
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;这种简洁的方案无疑是最符合我的预期的。
&lt;/li&gt;
&lt;li&gt;这种方案的优点是完全使用现有工具链（emacs）就能够完成博客的发布，减少了学习其他工具的成本。
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-3-3-1" class="outline-4"&gt;
&lt;h4 id="sec-3-3-1"&gt;3.3.1 org-publish&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-3-3-1"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;能够直接将org文件导出为html文件，也可以通过css进行样式上的美化。
&lt;/li&gt;
&lt;li&gt;生成的网页还是太复古了，而且没有tag功能，以后进行内容查找也不会很方便。
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-3-3-2" class="outline-4"&gt;
&lt;h4 id="sec-3-3-2"&gt;3.3.2 o-blog&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-3-3-2"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;o-blog的作者已经有很长一段时间没有维护这个项目了，如果使用o-blog可能意味着需要对o-blog的代码进行一些优化。我需要学习一些lisp相关的知识和web前端相关的知识，这些与我目前的学习内容计划还是有一些出入的，会打破我现有的计划。
&lt;/li&gt;
&lt;li&gt;o-blog-v2.6 版本上增加了一些新功能，但是会导致ominibar在打开过程中出现显示问题，对于强迫症的我来说肯定是不能忍的。
&lt;/li&gt;
&lt;li&gt;o-blog-v1 从网页上来看，还是没有什么让我不满意的地方的。o-blog-v2的那些新特性（目前知道的是搜索框），我目前还不是特别需要。所以，总体上来说o-blog-v1对于我也是一个不错的选择，如果投入精力去hack一下 lisp 和 web-front-end 相关技术，o-blog-v1可玩的地方还是很多的。
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;



&lt;div id="outline-container-sec-4" class="outline-2"&gt;
&lt;h2 id="sec-4"&gt;4 最终选用的方案&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;p&gt;
emacs + org-mode + nikola + github pages 这是我最终的方案。
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;emacs 是我一直在打磨的利器，使用emacs一年以来，自己的 &lt;a href="https://github.com/samsonwang/emacs.d"&gt;.emacs.d&lt;/a&gt; 配置也逐渐稳定下来，我相信emacs的潜力还是很大的，是一个可玩度非常高的玩具。
&lt;/li&gt;
&lt;li&gt;org-mode 作为emacs上的masterpiece，用它来记笔记写文档简直就是一种享受。
&lt;/li&gt;
&lt;li&gt;nikola 支持org-mode格式，这是最重要的； 另外，实现语言是Python，我近期有学习python的计划，有可能会读一读相关源码。
&lt;/li&gt;
&lt;li&gt;github pages 作为程序员必备技能，能够直接托管静态网页，也没有流量限制，真可谓是省时、省力、省心又经济。
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>nikola</category><category>org-mode</category><guid>http://samsonwang.me/posts/2017/blog-open-up/</guid><pubDate>Mon, 23 Oct 2017 13:58:25 GMT</pubDate></item></channel></rss>