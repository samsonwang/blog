<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns#" lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta http-equiv="x-ua-compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Hack Note (old posts, page 17) | Hack Note</title>
<meta name="description" content="Personal handnote on software development">
<meta name="theme-color" content="#04519b">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" href="/rss.xml">
<link href="/assets/css/minima.min.css" rel="stylesheet" type="text/css">
<link rel="canonical" href="https://blog.wangzhl.com/index-17.html">
<link rel="icon" href="/favicon.ico" sizes="64x64">
<link rel="prev" href="/index-16.html" type="text/html">
<link rel="next" href="/index-18.html" type="text/html">
</head>
<body>
  <header class="site-header nav-custom"><div class="wrapper">
      <a class="site-title" rel="author" href="/">Hack Note</a>
      <nav class="site-nav"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger">
          <span class="menu-icon">
            <svg viewbox="0 0 18 15" width="18px" height="15px"><use href="/assets/svg/theme.svg#menu-icon"></use></svg></span>
        </label>
        <div class="trigger">
          
            <a class="page-link" href="/">Home</a>
            <a class="page-link" href="/archive/">Archive</a>
            <a class="page-link" href="/tags/">Tags</a>
            <a class="page-link" href="/about/">About</a>

        </div>
      </nav>
</div>
  </header><main class="page-content" aria-label="Content"><div class="wrapper">

    

    


  



  


<div class="home">
  <ul class="post-list">
<li>
    <span class="post-meta">Jul 30, 2018</span>
    <h3>
      <a class="post-link" href="/posts/navigation-and-selection-effectively-in-emacs/">提高emacs中浏览和选择操作效率的技巧</a>
    </h3>

    <div id="outline-container-orgf09d6be" class="outline-2">
<h2 id="orgf09d6be">
<span class="section-number-2">1</span> 引言</h2>
<div class="outline-text-2" id="text-1">
<p>
Gaurab Paul的 <a href="https://lorefnon.tech/2018/07/14/getting-productive-with-selection-and-navigation-in-emacs/">一篇博文</a> 给了我很大的启发，他详细地介绍了emacs中的相关概念，并提供了许多充满想象力的小技巧。作为emacs的入门级选手确实学到了很多，也拓宽了自己的思路。<br></p>

<p>
我最初的开发环境是Visual Studio，这一类比较大型的IDE集成了许多功能，但同时也会束缚住使用者的想法。通过这篇文章我感受到的由普通操作指令能组合成的新编辑方式。<br></p>

<p>
如果英文水平允许的话，非常推荐阅读一下原版的博文，原文中有更加丰富形象的图片示例，无论是跟我一样刚刚入门emacs的新手，还是经验丰富的老兵，都能够从中获得启发。下面，我结合自己的理解和收获谈谈emacs中操作的体会。<br></p>
</div>
</div>


<div id="outline-container-orgf033486" class="outline-2">
<h2 id="orgf033486">
<span class="section-number-2">2</span> <code>point</code> 、 <code>mark</code> 和 <code>region</code> 的概念</h2>
<div class="outline-text-2" id="text-2">
<p>
我之前进行代码段复制的操作是十分基础的，用 <code>C-@</code> 模拟鼠标按下，方向键模拟鼠标拖动，在鼠标拖动的过程中就形成了一个选区，然后用 <code>M-w</code> 对这个选区进行复制操作，用 <code>C-y</code> 粘贴被复制的内容。<br></p>

<p>
以上操作带出了几个非常重要的概念 。在emacs中，鼠标光标所在位置被称作 <code>point</code> ；组合键 <code>C-@</code> 执行的是 <code>set-mark-command</code> 命令，就是将 <code>point</code> 所在位置标记为 <code>mark</code> ；通过移动光标，也就是移动 <code>point</code> 后，在 <code>point</code> 与 <code>mark</code> 之间就形成了 <code>region</code> 。<br></p>
</div>
</div>


<div id="outline-container-org86a4149" class="outline-2">
<h2 id="org86a4149">
<span class="section-number-2">3</span> <code>region</code> 操作技巧</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org7fae4a6" class="outline-3">
<h3 id="org7fae4a6">
<span class="section-number-3">3.1</span> 调整 <code>region</code> 的大小</h3>
<div class="outline-text-3" id="text-3-1">
<p>
下面就来介绍一个非常重要的命令 <code>exchange-point-and-mark</code> ，这个命令默认被绑定在组合键 <code>C-x C-x</code> 上，从字面意思上很容易理解这条指令的作用，就是交换 <code>mark</code> 和 <code>point</code> 的位置。这样做的意义在于能够方便地切换 <code>region</code> 的可动边界，这样能够使 <code>region</code> 方便地分别从两端调整大小。<br>
下面的示例是截取自Paul的博文，需要注意的是，他习惯于使用 <code>C-SPC</code> 调用 <code>set-mark-command</code> 。<br></p>

<div class="highlight"><pre><span></span>Lorem ipsum dolor sit amet
      ^ Cursor


      Point
      |
      Mark
      |
Lorem ipsum dolor sit amet
      ^ C-spc


      Mark          Point
      | ----region--|
      |             |
Lorem ipsum dolor sit amet
	 move       ^
	 forward -&gt;


      Mark          Point
      | ----region--|
      |             |
Lorem ipsum dolor sit amet
		    ^
		    C-x C-x


      Point         Mark
      | ----region--|
      |             |
Lorem ipsum dolor sit amet

Point and mark interchanged
</pre></div>
</div>
</div>

<div id="outline-container-org5c62119" class="outline-3">
<h3 id="org5c62119">
<span class="section-number-3">3.2</span> 使用 <code>region</code> 进行重复性输入</h3>
<div class="outline-text-3" id="text-3-2">
<p>
对于 <code>region</code> 相关的操作，通常是对已经存在的代码段进行编辑的，如果我们在输入之前就知道有许多字段是需要重复输入的，那么就可以在输入之前设置好 <code>mark</code> ，对输入后形成的 <code>region</code> 完成复制。这个技巧在特定情况能够很大地提升输入效率，但是我个人认为，想要在实战中完成这个操作，还需要保证非常清晰的思路。可以通过下面的示例感受这种操作带来的方便(示例截取自Paul的博文)。<br></p>

<p>
<img src="/assets/images/spinner.svg" data-src="/images/post-navigation-and-selection-effectively-in-emacs-1.gif" alt="nil"><br></p>

<p>
下面给出了详细的操作解析<br></p>

<div class="highlight"><pre><span></span>class
      ^ C-spc =&gt; Activate mark

class Foo
	  ^ M-w =&gt; Foo has now been killed (copied)

class Foo extends React.Component&lt;
				  ^ C-spc =&gt; Activate mark

class Foo extends React.Component&lt;
				  ^ C-y =&gt; Yank (paste) Foo

class Foo extends React.Component&lt;FooProps
					  ^ M-w =&gt; FooProps has now been killed (copied)

class Foo extends React.Component&lt;FooProps&gt;

// Later
interface
	   ^ C-y =&gt; Yank FooProps

interface FooProps {}
</pre></div>
</div>
</div>

<div id="outline-container-org91a39c6" class="outline-3">
<h3 id="org91a39c6">
<span class="section-number-3">3.3</span> 框选一个矩形的 <code>region</code>
</h3>
<div class="outline-text-3" id="text-3-3">
<p>
使用 <code>rectangle-mark-mode</code> 命令，默认快捷键 <code>C-x-SPC</code> ，能够框选出一个矩形的 <code>region</code> 。对于矩形 <code>region</code> ，Paul给出的示例是复制 <code>dired</code> 中的多个文件名称，貌似其他合适的使用场景不太多。<br></p>

<p>
<img src="/assets/images/spinner.svg" data-src="/images/post-navigation-and-selection-effectively-in-emacs-2.gif" alt="nil"><br></p>
</div>
</div>
</div>


<div id="outline-container-org1d09a65" class="outline-2">
<h2 id="org1d09a65">
<span class="section-number-2">4</span> 其他插件支持</h2>
<div class="outline-text-2" id="text-4">
<p>
有些插件拓展能够实现光标的快速定位，如 <a href="https://github.com/ShingoFukuyama/helm-swoop">helm-swoop</a> 和 <a href="https://github.com/abo-abo/avy">avy</a> 。<br></p>
</div>

<div id="outline-container-org023b8f8" class="outline-3">
<h3 id="org023b8f8">
<span class="section-number-3">4.1</span> helm swoop</h3>
<div class="outline-text-3" id="text-4-1">
<p>
从我个人的使用体验来看 <a href="https://github.com/ShingoFukuyama/helm-swoop">helm-swoop</a> 和helm occur的功能十分相似，它们都提供了方便的关键词跳转功能。<br></p>

<p>
下面的图片来自helm swoop的 <a href="https://github.com/ShingoFukuyama/helm-swoop">主页</a><br></p>

<p>
<img src="/assets/images/spinner.svg" data-src="/images/post-navigation-and-selection-effectively-in-emacs-3.gif" alt="nil"><br></p>
</div>
</div>

<div id="outline-container-org301c5c4" class="outline-3">
<h3 id="org301c5c4">
<span class="section-number-3">4.2</span> avy</h3>
<div class="outline-text-3" id="text-4-2">
<p>
<a href="https://github.com/abo-abo/avy">avy</a> 的思路非常独特，这样的跳转和定位让我想起了Chrome浏览器中的Vimium插件，他允许我们使用更少的按键就能跳转到当前buffer中的任意位置，略微遗憾的是它只支持拉丁字母，不过在编写代码的大多数情况下是够用的。<br></p>

<p>
下面的图片来自Paul的博文<br></p>

<p>
<img src="/assets/images/spinner.svg" data-src="/images/post-navigation-and-selection-effectively-in-emacs-4.gif" alt="nil"><br></p>
</div>
</div>
</div>


<div id="outline-container-orgb756e9b" class="outline-2">
<h2 id="orgb756e9b">
<span class="section-number-2">5</span> 参考资料</h2>
<div class="outline-text-2" id="text-5">
<ul class="org-ul">
<li>
<a href="https://lorefnon.tech/2018/07/14/getting-productive-with-selection-and-navigation-in-emacs/">lorefnon.tech</a><br>
</li>
<li>
<a href="https://github.com/ShingoFukuyama/helm-swoop">helm-swoop</a><br>
</li>
<li>
<a href="https://github.com/abo-abo/avy">avy</a><br>
</li>
</ul>
</div>
</div>

  </li>


  <li>
    <span class="post-meta">Jul 26, 2018</span>
    <h3>
      <a class="post-link" href="/posts/shell-output-redirections/">shell的输出重定向</a>
    </h3>

    <div id="outline-container-orgac6e67e" class="outline-2">
<h2 id="orgac6e67e">引言</h2>
<div class="outline-text-2" id="text-orgac6e67e">
<p>
在linux中借助shell等命令行工具能够很方便地与操作系统交互，可以在shell中将命令或程序的输入结果重定向到特定地方，很方便地实现一些功能。这个技巧十分实用，使用输出重定向能够极大地简化我们的日常操作。<br></p>
</div>
</div>

<div id="outline-container-orga3d4132" class="outline-2">
<h2 id="orga3d4132">使用尖括号完成重定向</h2>
<div class="outline-text-2" id="text-orga3d4132">
<p>
示例如下，运行下面的命令能够把 <code>ls</code> 命令的运行结果写入到 <code>ls-output.txt</code> 中。使用 <code>&gt;</code> 会把程序运行时本该输出到 <code>stdout</code> 的内容重定向到指定名称的文件中。<br></p>
<div class="highlight"><pre><span></span>ls . &gt; ls-output.txt
</pre></div>
<p>
可以在 <code>&gt;</code> 左面写上数字和 <code>&amp;</code> ，用以标识在重定向时的特殊用法。下面会给出一些特殊用法的实例。<br></p>
</div>

<div id="outline-container-org8b44b94" class="outline-3">
<h3 id="org8b44b94">重定向 <code>stdout</code> 到指定文件中</h3>
<div class="outline-text-3" id="text-org8b44b94">
<div class="highlight"><pre><span></span>ls . <span class="m">1</span>&gt; ls-output.txt
</pre></div>
</div>
</div>

<div id="outline-container-orged7b0ac" class="outline-3">
<h3 id="orged7b0ac">重定向 <code>stderr</code> 到指定文件中</h3>
<div class="outline-text-3" id="text-orged7b0ac">
<div class="highlight"><pre><span></span>ls . <span class="m">2</span>&gt; ls-error.txt
</pre></div>
</div>
</div>

<div id="outline-container-org39d38fd" class="outline-3">
<h3 id="org39d38fd">将 <code>stdout</code> 和 <code>stdout</code> 合并再重定向到指定文件中</h3>
<div class="outline-text-3" id="text-org39d38fd">
<div class="highlight"><pre><span></span>ls . <span class="m">2</span>&gt;<span class="p">&amp;</span><span class="m">1</span> ls-output-and-error.txt
</pre></div>
<p>
以下命令具有相同的效果<br></p>
<div class="highlight"><pre><span></span>ls . <span class="p">&amp;</span>&gt; ls-output-and-error.txt
</pre></div>
</div>
</div>

<div id="outline-container-org84d86ba" class="outline-3">
<h3 id="org84d86ba">将程序的输出丢掉</h3>
<div class="outline-text-3" id="text-org84d86ba">
<p>
可以将输出重定向到一个特殊的文件 <code>/dev/null</code> ，所有写入到这个文件的内容都会被丢弃掉。<br></p>
<div class="highlight"><pre><span></span>program &gt; /dev/null
</pre></div>
</div>
</div>

<div id="outline-container-org44ea086" class="outline-3">
<h3 id="org44ea086">将输出追加到指定文件尾部</h3>
<div class="outline-text-3" id="text-org44ea086">
<p>
使用一个尖括号（ <code>&gt;</code> ）能够将输出重定向到文件中，在写入文件时会覆盖掉其中的内容。如果想保留文件中的原始内容，则可以用两个尖括号（ <code>&gt;&gt;</code> ），这样就能将输出追加到文件的尾部。示例代码如下：<br></p>
<div class="highlight"><pre><span></span><span class="nb">echo</span> <span class="nb">test</span> &gt;&gt; file-output.txt
</pre></div>
</div>
</div>
</div>

<div id="outline-container-org3f4d682" class="outline-2">
<h2 id="org3f4d682">使用管道完成重定向</h2>
<div class="outline-text-2" id="text-org3f4d682">
<p>
使用管道符号 <code>|</code> 能够将一个程序的输出重定向到另一个程序的输入中去。下面的命令会将 <code>ls</code> 的输出（ <code>stdout</code> ）重定向到 <code>grep</code> 的输入（ <code>stdin</code> ）中去。管道命令在linux中是最常见的用法。<br></p>
<div class="highlight"><pre><span></span>ls <span class="p">|</span> grep &lt;pattern&gt;
</pre></div>
</div>
</div>

  </li>


  <li>
    <span class="post-meta">Jul 23, 2018</span>
    <h3>
      <a class="post-link" href="/posts/notes-on-libshmcache/">libshmcache源码阅读笔记</a>
    </h3>

    <div id="outline-container-org037500f" class="outline-2">
<h2 id="org037500f">引言</h2>
<div class="outline-text-2" id="text-org037500f">
<p>
由于在工作中需要开发一套内存缓存服务，使用了共享内存作为多进程间的数据共享。为了提高共享内存缓存服务的性能，我找了一个类似的较为成熟的开源项目 <a href="https://github.com/happyfish100/libshmcache">libshmcache</a> ，通过研究源码学习其中的优点并改进自己的模块。<br></p>

<p>
libshmcache与redis相似的是都使用内存进行数据缓存；与redis不同的是，redis使用的进程自己申请的动态内存，而libshmcache使用的是共享内存。使用共享内存就意味着libshmcache主要的应用场景是同一台主机上的数据缓存。<br></p>

<p>
我花了一周时间阅读了比较感兴趣的部分代码，收获不少，现就以下几个方面总结一下自己的心得：<br></p>
<ul class="org-ul">
<li>纯C语言开发的代码风格<br>
</li>
<li>hash table的原理和实现<br>
</li>
<li>gcc原子化操作接口<br>
</li>
<li>有锁写和无锁读的实现细节<br>
</li>
<li>共享内存的两套函数接口(POSIX和SystemV)<br>
</li>
</ul>
</div>
</div>


<div id="outline-container-org3640d35" class="outline-2">
<h2 id="org3640d35">纯C语言开发时的代码风格</h2>
<div class="outline-text-2" id="text-org3640d35">
<p>
我在工作中使用比较多的开发语言是C++，对于C语言编写的这样规模的项目，还是第一次仔细深入地研究。C语言使用 <code>struct</code> 作为大多数自定义数据结构的关键字，相对于C++能够使用成员函数能够对类进行功能拓展，C语言比较常用的是将这个对象作为输入参数传到函数中。<br></p>

<p>
纵观所有项目代码，我感受比较深的就是使用结构体中嵌套匿名结构体，这样做能够增强数据结构的层次感，示例代码如下：<br></p>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">shmcache_context</span> <span class="p">{</span>
    <span class="kt">pid_t</span> <span class="n">pid</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">lock_fd</span><span class="p">;</span>    <span class="c1">//for file lock</span>
    <span class="kt">int</span> <span class="n">detect_deadlock_clocks</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">shmcache_config</span> <span class="n">config</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">shm_memory_info</span> <span class="o">*</span><span class="n">memory</span><span class="p">;</span>
    <span class="k">struct</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">shmcache_segment_info</span> <span class="n">hashtable</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
	    <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	    <span class="k">struct</span> <span class="n">shmcache_segment_info</span> <span class="o">*</span><span class="n">items</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">values</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">segments</span><span class="p">;</span>

    <span class="k">struct</span> <span class="n">shmcache_value_allocator_context</span> <span class="n">value_allocator</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">shmcache_list</span> <span class="n">list</span><span class="p">;</span>   <span class="c1">//for value recycle</span>
    <span class="kt">bool</span> <span class="n">create_segment</span><span class="p">;</span>  <span class="c1">//if check segment size                                  </span>
<span class="p">};</span>
</pre></div>
<p>
注意 <code>shmcache_context</code> 中的匿名结构体 <code>segments</code> 和 <code>values</code> ，这样的写法体现了相互包含关系，也使后续的操作该数据结构的语句更加容易理解。<br></p>

<p>
另外对于联合体和位域这两种技术也是我在之前开发中使用比较少的，通过阅读源码能够让我对其有了更深刻的理解。示例代码如下：<br></p>
<div class="highlight"><pre><span></span><span class="k">union</span> <span class="n">shm_hentry_offset</span> <span class="p">{</span>
    <span class="kt">int64_t</span> <span class="n">offset</span><span class="p">;</span>
    <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="nl">index</span> <span class="p">:</span><span class="mi">16</span><span class="p">;</span>
	<span class="kt">int64_t</span> <span class="nl">offset</span> <span class="p">:</span><span class="mi">48</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">segment</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
<p>
这段代码使用了联合体赋予了 <code>shm_hentry_offset</code> 两种访问方式，又使用了位域将 <code>int64_t</code> 分割为两段。<br></p>
</div>
</div>


<div id="outline-container-orgc444558" class="outline-2">
<h2 id="orgc444558">hash table的原理和实现</h2>
<div class="outline-text-2" id="text-orgc444558">
<p>
libshmcache内部使用的是hash table做内部缓存的数据结构，这使查找的时间复杂度是O(1)。<br>
之前看过一些介绍hash table的资料，对hash table的工作原理是有过一个基础的了解的，这次通过阅读源码，能够了解到hash table在代码实现上更加细节的内容。<br>
对于hash计算中出现的hash值冲突，即在hash计算时出现了两个不同的key在经过hash计算后得到的bucket相同，libshmcache采用的解决方案是使用linked list来存放这些相同bucket对应的value。<br></p>
</div>
</div>


<div id="outline-container-orgafff106" class="outline-2">
<h2 id="orgafff106">gcc原子化操作接口</h2>
<div class="outline-text-2" id="text-orgafff106">
<p>
使用原子化操作接口能够解决一些并发读写问题，原子化操作相对于互斥锁执行更快。原子化操作也是一种无锁编程的方式。<br></p>
</div>
</div>


<div id="outline-container-org12bb5dc" class="outline-2">
<h2 id="org12bb5dc">有锁写和无锁读的实现</h2>
<div class="outline-text-2" id="text-org12bb5dc">
<p>
在libshmcache中，写操作通过 <code>pthread_mutex_t</code> 进行同步，而读操作是无锁的。<br>
对于写操作来说，需要对hash table进行操作，这肯定是需要同步的。<br>
将 <code>pthread_mutex_t</code> 保存在共享内存中，不同的进程通过映射共享内存就能获得同一个互斥量，通过这个互斥量就能完成进程间同步。<br></p>
</div>
</div>


<div id="outline-container-org46841a5" class="outline-2">
<h2 id="org46841a5">共享内存的两套函数接口(POSIX和SystemV)</h2>
<div class="outline-text-2" id="text-org46841a5">
<p>
在linux上使用共享内存时有两套接口 <code>mmap</code> 和 <code>shmget</code> 。 <code>mmap</code> 是 <code>POSIX</code> 标准的接口，而 <code>shmget</code> 是 <code>System V</code> 标准的接口，两者都能够实现进程间共享内存，但他们在使用上还是有些区别的。对于 <code>mmap</code> 来说，需要在硬盘上创建一个文件，再将该文件映射到内存中。对于 <code>shmget</code> 来说，需要指定一个key，不同的进程通过相同的key就能映射到同一片内存。<br></p>
</div>
</div>

  </li>


  <li>
    <span class="post-meta">Jul 11, 2018</span>
    <h3>
      <a class="post-link" href="/posts/cpp-bit-field/">C/C++中的位域</a>
    </h3>

    <div id="outline-container-org31c7123" class="outline-2">
<h2 id="org31c7123">什么是位域</h2>
<div class="outline-text-2" id="text-org31c7123">
<p>
<a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E6%AE%B5">维基百科</a> 给出了以下解释<br></p>
<blockquote>
<p>
位域（或称“位段”，bit field）为一种数据结构，可以把数据以位的形式紧凑的储存，并允许程序员对此结构的位进行操作。<br></p>
</blockquote>

<p>
<a href="https://en.cppreference.com/w/cpp/language/bit_field">cppreference</a> 给出了以下定义<br></p>
<blockquote>
<p>
Declares a class data member with explicit size, in bits. Adjacent bit field members may be packed to share and straddle the individual bytes.<br></p>
</blockquote>

<p>
这种数据结构的好处：<br></p>
<ul class="org-ul">
<li>可以使数据单元节省储存空间，当程序需要成千上万个数据单元时，这种方法就显得尤为重要。<br>
</li>
<li>位段可以很方便的访问一个整数值的部分内容从而可以简化程序源代码。<br>
</li>
</ul>
<p>
而位域这种数据结构的缺点在于，其内存分配与内存对齐的实现方式依赖于具体的机器和系统，在不同的平台可能有不同的结果，这导致了位域在本质上是不可移植的。<br></p>
</div>
</div>


<div id="outline-container-org5b59064" class="outline-2">
<h2 id="org5b59064">位域的语法</h2>
<div class="outline-text-2" id="text-org5b59064">
<p>
下面就是位域的语法格式。<br></p>
<div class="highlight"><pre><span></span><span class="n">identifier</span><span class="p">(</span><span class="n">optional</span><span class="p">)</span> <span class="n">attr</span><span class="p">(</span><span class="n">optional</span><span class="p">)</span> <span class="o">:</span> <span class="n">size</span>
</pre></div>

<p>
<b>注意</b> ：<br></p>
<ul class="org-ul">
<li>
<code>size</code> 的大小不能超过 <code>identifier</code> 所包含最大比特位个数。<br>
</li>
<li>
<code>identifier</code> 为空时表示对应的 <code>size</code> 个数的比特位不使用<br>
</li>
<li>
<code>size</code> 为0时表示根据前类型强制补齐<br>
</li>
</ul>
<p>
以下为代码示例。<br></p>

<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">S1</span> <span class="p">{</span>
    <span class="c1">// will usually occupy 2 bytes:</span>
    <span class="c1">// 3 bits: value of b1</span>
    <span class="c1">// 2 bits: unused</span>
    <span class="c1">// 6 bits: value of b2</span>
    <span class="c1">// 2 bits: value of b3</span>
    <span class="c1">// 3 bits: unused</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nl">b1</span> <span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nl">b2</span> <span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="nl">b3</span> <span class="p">:</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">S2</span> <span class="p">{</span>
    <span class="c1">// will usually occupy 2 bytes:</span>
    <span class="c1">// 3 bits: value of b1</span>
    <span class="c1">// 5 bits: unused</span>
    <span class="c1">// 6 bits: value of b2</span>
    <span class="c1">// 2 bits: value of b3</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nl">b1</span> <span class="p">:</span> <span class="mi">3</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">:</span><span class="mi">0</span><span class="p">;</span> <span class="c1">// start a new byte</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nl">b2</span> <span class="p">:</span> <span class="mi">6</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nl">b3</span> <span class="p">:</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>


<div id="outline-container-org3081131" class="outline-3">
<h3 id="org3081131">在 <code>size</code> 取0时如何理解</h3>
<div class="outline-text-3" id="text-org3081131">
<p>
对于 <code>size</code> 取0时的各种情况进行了尝试，详细用例如下。思路是使用联合体能比较方便地将内存分布表示出来。<br>
如下所示，定义了如下几种情况。<br></p>

<p>
<b>case1</b><br></p>
<div class="highlight"><pre><span></span><span class="k">union</span> <span class="n">un1</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n1</span><span class="p">;</span>
    <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="nl">nn1</span> <span class="p">:</span> <span class="mi">4</span><span class="p">;</span>
	<span class="kt">int</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="nl">nn2</span> <span class="p">:</span> <span class="mi">16</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">st</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>

<p>
对联合体中的结构体位段进行赋值，并将联合体中的内容打印出来。<br></p>
<div class="highlight"><pre><span></span><span class="k">union</span> <span class="n">un1</span> <span class="n">u1</span><span class="p">;</span>
<span class="n">u1</span><span class="p">.</span><span class="n">st</span><span class="p">.</span><span class="n">nn1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">u1</span><span class="p">.</span><span class="n">st</span><span class="p">.</span><span class="n">nn2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"union u1.n1=0x%08x sizeof(un1)=%zu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">u1</span><span class="p">.</span><span class="n">n1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">un1</span><span class="p">));</span>
</pre></div>

<p>
输出结果为<br></p>
<div class="highlight"><pre><span></span><span class="k">union</span> <span class="n">un1</span><span class="p">.</span><span class="n">n1</span><span class="o">=</span><span class="mh">0x00000001</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">un1</span><span class="p">)</span><span class="o">=</span><span class="mi">8</span>
</pre></div>

<p>
<b>case2</b><br></p>
<div class="highlight"><pre><span></span><span class="k">union</span> <span class="n">un1</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n1</span><span class="p">;</span>
    <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="nl">nn1</span> <span class="p">:</span> <span class="mi">4</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="nl">nn2</span> <span class="p">:</span> <span class="mi">16</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">st</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>

<p>
输出结果为<br></p>
<div class="highlight"><pre><span></span><span class="k">union</span> <span class="n">un1</span><span class="p">.</span><span class="n">n1</span><span class="o">=</span><span class="mh">0x00000101</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">un1</span><span class="p">)</span><span class="o">=</span><span class="mi">4</span>
</pre></div>

<p>
<b>case3</b><br></p>
<div class="highlight"><pre><span></span><span class="k">union</span> <span class="n">un1</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n1</span><span class="p">;</span>
    <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="nl">nn1</span> <span class="p">:</span> <span class="mi">4</span><span class="p">;</span>
	<span class="kt">short</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="nl">nn2</span> <span class="p">:</span> <span class="mi">16</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">st</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>

<p>
输出结果为<br></p>
<div class="highlight"><pre><span></span><span class="k">union</span> <span class="n">un1</span><span class="p">.</span><span class="n">n1</span><span class="o">=</span><span class="mh">0x00010001</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">un1</span><span class="p">)</span><span class="o">=</span><span class="mi">4</span>
</pre></div>


<p>
<b>case4</b><br></p>
<div class="highlight"><pre><span></span><span class="k">union</span> <span class="n">un1</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n1</span><span class="p">;</span>
    <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="nl">nn1</span> <span class="p">:</span> <span class="mi">8</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="nl">nn2</span> <span class="p">:</span> <span class="mi">16</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">st</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>

<p>
输出结果为<br></p>
<div class="highlight"><pre><span></span><span class="k">union</span> <span class="n">un1</span><span class="p">.</span><span class="n">n1</span><span class="o">=</span><span class="mh">0x00000101</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">un1</span><span class="p">)</span><span class="o">=</span><span class="mi">4</span>
</pre></div>
</div>
</div>


<div id="outline-container-org3f14438" class="outline-3">
<h3 id="org3f14438">
<code>struct</code> 与 <code>class</code> 关键字</h3>
<div class="outline-text-3" id="text-org3f14438">
<p>
多数例子都是以 <code>struct</code> 作为位域的组织标识，在C++中能否使用 <code>class</code> 作为位域的标识符呢？<br>
经过测试，是可以使用 <code>class</code> 关键字的，但是需要注意 <code>class</code> 的默认访问控制属性为 <code>private</code> 。<br></p>
</div>
</div>
</div>


<div id="outline-container-orgdd1efc5" class="outline-2">
<h2 id="orgdd1efc5">位域的常见应用场景</h2>
<div class="outline-text-2" id="text-orgdd1efc5">
<p>
为什么要使用位域？位域适合那些情况？<br></p>

<p>
位域的主要使用目的是节省对象的内存使用。在存放一些比较小的数据时，使用位域能够使字节中的每个比特位合理地利用起来，避免内存浪费。<br></p>

<p>
比较典型的应用是描述硬件寄存器。如果有32个一组的寄存器，每个寄存器代表一个比特位，就可以使用位域表示这组寄存器。<br></p>
</div>
</div>


<div id="outline-container-org11ff3a1" class="outline-2">
<h2 id="org11ff3a1">C++中的位操作接口</h2>
<div class="outline-text-2" id="text-org11ff3a1">
<p>
C++中也提供了一套位操作的接口 <code>std::bitset</code> ，这套接口提供了指定比特位数据的操作接口。<br></p>
</div>
</div>


<div id="outline-container-orgbccf267" class="outline-2">
<h2 id="orgbccf267">参考资料</h2>
<div class="outline-text-2" id="text-orgbccf267">
<ul class="org-ul">
<li>
<a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E6%AE%B5">wikipedia - bit field</a><br>
</li>
<li>
<a href="https://en.cppreference.com/w/cpp/language/bit_field">cppreference - bit field</a><br>
</li>
<li>
<a href="https://msdn.microsoft.com/zh-cn/library/ewwyfdbe.aspx">microsoft msdn - C++ bit fileds</a><br>
</li>
<li>
<a href="https://stackoverflow.com/questions/24933242/when-to-use-bit-fields-in-c">stackoverflow - how to use bit field</a><br>
</li>
<li>
<a href="https://en.cppreference.com/w/cpp/utility/bitset">cppreference - <code>std::bitset</code></a><br>
</li>
</ul>
<p>
（全文完）<br></p>
</div>
</div>

  </li>


  <li>
    <span class="post-meta">Jul 02, 2018</span>
    <h3>
      <a class="post-link" href="/posts/gcc-built-in-functions-for-atomic-memory-access/">GCC的内存原子化操作函数接口</a>
    </h3>

    <div id="outline-container-org1713029" class="outline-2">
<h2 id="org1713029">
<span class="section-number-2">1</span> 原子化操作</h2>
<div class="outline-text-2" id="text-1">
<p>
在并发编程中，一个操作或一组操作是原子操作、可线性化操作、不可分操作或不可中断操作（atomic, linearizable, indivisible, uniterruptible），表示该操作执行时不可被中断的。操作的原子性能够保证操作在执行时免受中断、信号、并发进程线程的影响。另外，原子操作大多只有两种结果，要么成功并改变系统中对应的状态，要么没有相关效果。<br></p>

</div>
</div>

  </li>


  <li>
    <span class="post-meta">Jun 29, 2018</span>
    <h3>
      <a class="post-link" href="/posts/gdb-display-contents-of-memory-address/">在gdb中查看指定内存地址的内容</a>
    </h3>

    <p>
调试 C/C++ 程序时，需要打印指定内存地址的内容。我最近调试程序中的序列化模块时，需要将类对象按照指定的格式转化为二进制流，为了验证转化结果，在调试时就需要将指定内存地址中的内容打印出来。<br></p>



  </li>

</ul>
</div>




    

  <ul class="index-pager hidden-print">
<li class="previous">
      <a href="/index-16.html" rel="prev">&lt; Newer posts</a>
    </li>
    <li class="next">
      <a href="/index-18.html" rel="next">Older posts &gt;</a>
    </li>
  </ul>
</div>
  </main><footer class="site-footer h-card"><div class="wrapper">
      <div class="footer-col-wrapper">

        <div class="footer-col">
          <p class="site-desc">Personal handnote on software development</p>
        </div>

        <div class="footer-col">
          <div class="p-name">Samson Wang</div>
          <div class="copyright">Copyright 2021, all rights reserved.</div>
          <div class="social-links">
            <ul class="social-media-list">
<li><a rel="me" href="/rss.xml">
                <svg class="svg-icon grey"><use href="/assets/svg/social-icons.svg#rss"></use></svg></a></li>
              <li><a rel="nofollow" href="https://github.com/samsonwang">
                <svg class="svg-icon grey"><use href="/assets/svg/social-icons.svg#github"></use></svg></a></li>
              <li><a rel="nofollow" href="https://twitter.com/samsonwangcn">
                <svg class="svg-icon grey"><use href="/assets/svg/social-icons.svg#twitter"></use></svg></a></li>
              <li><a rel="nofollow" href="https://facebook.com/samsonwangcn">
                 <svg class="svg-icon grey"><use href="/assets/svg/social-icons.svg#facebook"></use></svg></a></li>
            </ul>
</div>

        </div>

      </div>

    </div>

  </footer><div id="scroll-top" title="back to top">
  <div id="scroll-top-arrow"></div>
  <div id="scroll-top-stick"></div>
</div>


      <script src="/assets/js/lazyload.min.js"></script><script src="/assets/js/minima.min.js"></script><!-- google adsense --><script data-ad-client="ca-pub-6303134192857919" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- Google Analytics - Global site tag (gtag.js) --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-108507797-1"></script><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-108507797-1');
</script><!-- baidu tongji --><script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?1dcffb5494ab56e69005c957d7320ad1";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>
</body>
</html>
