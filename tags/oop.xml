<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="/assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Hack Note (Posts about oop)</title><link>https://samsonwang.me/</link><description></description><atom:link href="https://samsonwang.me/tags/oop.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2017-2018 &lt;a href="mailto:wangzhilv@gmail.com"&gt;Samson Wang&lt;/a&gt; 
&lt;a rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/"&gt;&lt;img alt="知识共享许可协议" style="padding-bottom:2px" src="https://i.creativecommons.org/l/by-nc/4.0/80x15.png" /&gt;&lt;/a&gt;
</copyright><lastBuildDate>Thu, 27 Sep 2018 06:36:29 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>javscript中的OOP特性</title><link>https://samsonwang.me/posts/javascript-object-oriented-programming/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; 引言&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
js也是具有OOP（object oriented programming）特性的，OOP在构建一些大型应用程序还是有一套成熟理论的。作为C++的使用者在学习js中的OOP特性的过程中，能够较快地理解其中的各种术语和概念，也能比较两种语言的异同，深化知识理解。通过js的OOP特性的学习也让我开始从语言层面考虑程序设计问题。&lt;br&gt;
本篇文章主要介绍了js中的一些OOP特性，并且比较了js与C++的语言特性。如果你能熟练掌握C++的OOP特性，本文能帮助你快速地对js中的OOP特性建立整体的认识。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2" class="outline-2"&gt;
&lt;h2 id="sec-2"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; 写给C++使用者的js中的OOP特性介绍&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;/div&gt;&lt;div id="outline-container-sec-2-1" class="outline-3"&gt;
&lt;h3 id="sec-2-1"&gt;&lt;span class="section-number-3"&gt;2.1&lt;/span&gt; 创建对象（object）&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-1"&gt;
&lt;p&gt;
js中创建object的代码，示例如下：&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;let duck = {
  name: "Aflac",
  numLegs: 2,
  sayName: function() {
    return "The name of this duck is " + this.name + ".";
  }
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
js直接通过 &lt;code&gt;{}&lt;/code&gt; 就可以创建出对象示例来，不需要对该对象（object）的类（class）进行声明。这点和C++不是很相同，C++需要先声明一个class再创建object。&lt;br&gt;
这个object有两个成员变量和一个成员函数，需要注意的是这两个成员变量都是公有（public）的，他们是可以直接用 &lt;code&gt;.&lt;/code&gt; 符号访问的。&lt;br&gt;
js中也有 &lt;code&gt;this&lt;/code&gt; 关键字，与C++相同， &lt;code&gt;this&lt;/code&gt; 关键字用于表示当前实例。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2-2" class="outline-3"&gt;
&lt;h3 id="sec-2-2"&gt;&lt;span class="section-number-3"&gt;2.2&lt;/span&gt; 类（class）的声明&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-2"&gt;
&lt;p&gt;
js中声明一个类的操作实际上就是声明一个构造函数。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;let Bird = function(name, color) {
  this.name = name;
  this.color = color;
  this.numLegs = 2;
}

let crow = new Bird("Alexis", "black");

crow instanceof Bird; // =&amp;gt; true
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
上面的代码声明了Bird类，在js中通常类的名字都是由首字母大写的单词表示的。类的构造函数也能接受参数用于对实例的初始化，这点与C++非常相似，使用 &lt;code&gt;new&lt;/code&gt; 关键字就能够创建该类的实例。&lt;br&gt;
使用 &lt;code&gt;instanceof&lt;/code&gt; 关键字用于检查对象是否属于某个类，也可通过验证 &lt;code&gt;constructor&lt;/code&gt; 属性来判断一个对象是否属于一个类 &lt;code&gt;crow.constructor == Bird&lt;/code&gt; 。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2-3" class="outline-3"&gt;
&lt;h3 id="sec-2-3"&gt;&lt;span class="section-number-3"&gt;2.3&lt;/span&gt; 类的共有成员&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-3"&gt;
&lt;p&gt;
js中通过 &lt;code&gt;prototype&lt;/code&gt; 这一属性（把它叫做关键字好像还不太合适）能够实现C++中静态成员变量和静态成员函数的特性。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Bird.prototype.numLegs = 2;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
上面的代码就给Bird类增加了一个静态成员变量。这个 &lt;code&gt;prototype&lt;/code&gt; 可以是一个对象，这样类的共有成员就能方便地承载更多的属性了，示例代码如下。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Bird.prototype = {
  constructor: Bird,
  numLegs: 2,
  eat: function() {
    console.log("nom nom nom");
  },
  describe: function() {
    console.log("My name is " + this.name);
  }
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
需要注意的是需要设置好 &lt;code&gt;constructor&lt;/code&gt; 属性，这样是为了保证代码逻辑的一致性。&lt;br&gt;
对象会获得类的 &lt;code&gt;prototype&lt;/code&gt; 属性，可以通过 &lt;code&gt;isPrototypeof&lt;/code&gt; 方法来验证。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Bird.prototype.isPrototypeOf(duck);
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2-4" class="outline-3"&gt;
&lt;h3 id="sec-2-4"&gt;&lt;span class="section-number-3"&gt;2.4&lt;/span&gt; 类的私有成员&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-4"&gt;
&lt;p&gt;
js与C++一样，也可以有私有成员变量，代码如下所示。 &lt;code&gt;hatchedEgg&lt;/code&gt; 就相当与是Bird的私有成员变量，并且提供了修改这个成员变量的方法 &lt;code&gt;getHatchedEggCount&lt;/code&gt; 。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;function Bird() {
  let hatchedEgg = 10; // private property

  this.getHatchedEggCount = function() {
    // publicly available method that a bird object can use
    return hatchedEgg;
  };
}
let ducky = new Bird();
ducky.getHatchedEggCount(); // returns 10
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
这种形式在js中被称作闭包（closure），函数能够访问到与他处在同一个作用域（context）中的变量。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2-5" class="outline-3"&gt;
&lt;h3 id="sec-2-5"&gt;&lt;span class="section-number-3"&gt;2.5&lt;/span&gt; 类的继承和派生&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-5"&gt;
&lt;p&gt;
js中的派生主要通过 &lt;code&gt;prototype&lt;/code&gt; 体现，下面的代码表示Bird派生自Object。同样，需要注意将 &lt;code&gt;constructor&lt;/code&gt; 属性设置好。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Bird.prototype = Object.create(Animal.prototype);
Bird.prototype.constructor = Bird;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2-6" class="outline-3"&gt;
&lt;h3 id="sec-2-6"&gt;&lt;span class="section-number-3"&gt;2.6&lt;/span&gt; 类的覆盖&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-6"&gt;
&lt;p&gt;
js中可以重写基类中的方法，代码如下所示，这点与C++中的 &lt;code&gt;override&lt;/code&gt; 相同。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;function Animal() { }
Animal.prototype.eat = function() {
  return "nom nom nom";
};
function Bird() { }

// Inherit all methods from Animal
Bird.prototype = Object.create(Animal.prototype);

// Bird.eat() overrides Animal.eat()
Bird.prototype.eat = function() {
  return "peck peck peck";
};

Bird.prototype.fly = function() {
  console.log("I'm flying!");
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
通样也在派生之后也可以通过修改派生类的 &lt;code&gt;prototype&lt;/code&gt; 以达到特化派生类的作用，上面的 &lt;code&gt;fly&lt;/code&gt; 方法就是在Bird完成派生之后新增的方法。现在Bird有两个方法，它们分别是 &lt;code&gt;eat&lt;/code&gt; 和 &lt;code&gt;fly&lt;/code&gt; 。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-sec-3" class="outline-2"&gt;
&lt;h2 id="sec-3"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; 参考资料&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/object-oriented-programming/"&gt;FCC javascript oop tutorial&lt;/a&gt;&lt;br&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>cpp</category><category>javascript</category><category>oop</category><guid>https://samsonwang.me/posts/javascript-object-oriented-programming/</guid><pubDate>Sun, 26 Aug 2018 02:31:37 GMT</pubDate></item></channel></rss>