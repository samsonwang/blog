<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="/assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Hack Note (Posts about cpp)</title><link>https://samsonwang.me/</link><description></description><atom:link href="https://samsonwang.me/tags/cpp.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2017-2019 &lt;a href="mailto:wangzhilv@gmail.com"&gt;Samson Wang&lt;/a&gt; 
&lt;a rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/"&gt;&lt;img alt="知识共享许可协议" style="padding-bottom:2px" src="https://i.creativecommons.org/l/by-nc/4.0/80x15.png" /&gt;&lt;/a&gt;
</copyright><lastBuildDate>Tue, 29 Jan 2019 08:22:05 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>线程API总结</title><link>https://samsonwang.me/posts/thread-api-cheatsheet/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div&gt;&lt;p&gt;
线程的使用在软件开发中是十分普遍的，本文总结了两种常用的线程API接口：POSIX线程和CPP11线程。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://samsonwang.me/posts/thread-api-cheatsheet/"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>cpp</category><category>cpp11</category><category>linux</category><category>posix</category><category>thread</category><guid>https://samsonwang.me/posts/thread-api-cheatsheet/</guid><pubDate>Mon, 14 Jan 2019 02:50:31 GMT</pubDate></item><item><title>谈谈自己在开发launchy时的一些收获</title><link>https://samsonwang.me/posts/launchy-dev-note-1/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div&gt;&lt;p&gt;
在开发launchy时，我学到了很多开发相关的技巧，对于如何做好一款软件也有了更加全面的认识。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://samsonwang.me/posts/launchy-dev-note-1/"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>cpp</category><category>launchy</category><guid>https://samsonwang.me/posts/launchy-dev-note-1/</guid><pubDate>Wed, 09 Jan 2019 03:54:32 GMT</pubDate></item><item><title>C++常用的时间接口</title><link>https://samsonwang.me/posts/cpp-time-cheatsheet/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div&gt;&lt;p&gt;
与时间相关的操作在开发中是十分常见的，本文总结了常用时间接口，并给出了示例代码。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://samsonwang.me/posts/cpp-time-cheatsheet/"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>chrono</category><category>cpp</category><category>cpp11</category><category>time</category><guid>https://samsonwang.me/posts/cpp-time-cheatsheet/</guid><pubDate>Fri, 04 Jan 2019 08:05:56 GMT</pubDate></item><item><title>C++中的智能指针</title><link>https://samsonwang.me/posts/smart-pointers-in-cpp/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div&gt;&lt;p&gt;
C++中有很多智能指针如 &lt;code&gt;unique_ptr&lt;/code&gt; 和 &lt;code&gt;shared_ptr&lt;/code&gt; ，本篇文章主要介绍这些指针的功能和应用场景。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://samsonwang.me/posts/smart-pointers-in-cpp/"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>cpp</category><category>shared_ptr</category><category>smart pointer</category><category>unique_ptr</category><guid>https://samsonwang.me/posts/smart-pointers-in-cpp/</guid><pubDate>Wed, 28 Nov 2018 15:51:57 GMT</pubDate></item><item><title>写在launchy3.0.3发布之后</title><link>https://samsonwang.me/posts/launchy-maintain-303/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div&gt;&lt;p&gt;
维护launchy也有一段时间了，目前已经发了4个版本，整体功能也趋于稳定。在维护launchy的过程中有很多思考，今天集中写下来，算是里程碑样的记录。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://samsonwang.me/posts/launchy-maintain-303/"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>cpp</category><category>launchy</category><category>python</category><category>qt</category><guid>https://samsonwang.me/posts/launchy-maintain-303/</guid><pubDate>Mon, 26 Nov 2018 13:04:04 GMT</pubDate></item><item><title>静态成员变量初始化相关问题</title><link>https://samsonwang.me/posts/static-member-initialization-and-private-member-function/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div id="outline-container-org9698844" class="outline-2"&gt;
&lt;h2 id="org9698844"&gt;引言&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org9698844"&gt;
&lt;p&gt;
这篇文章的起因是出于对于 &lt;code&gt;C++&lt;/code&gt; 饿汉单例模式代码的一些疑问，查阅了一些资料。在仔细研究后，我发现在一些基础概念的理解还是存在偏差。&lt;br&gt;
下面请看这样的一段代码，能看出其中有那些不太“正常”的语句么。&lt;br&gt;
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Singleton&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;Singleton&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;getInstance&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;Singleton&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;Singleton&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;instance&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="n"&gt;Singleton&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;Singleton&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;instance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Singleton&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;Singleton&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;Singleton&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;getInstance&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;instance&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org30d1212" class="outline-2"&gt;
&lt;h2 id="org30d1212"&gt;私有静态成员的初始化&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org30d1212"&gt;
&lt;p&gt;
上面的代码是饿汉单例模式的 &lt;code&gt;C++&lt;/code&gt; 的实现，在没有查阅资料之前，我对其中私有静态成员变量的初始化存疑。主要有以下两点：&lt;br&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;为什么私有变量能够在类外被修改&lt;br&gt;&lt;/li&gt;
&lt;li&gt;为什么私有构造函数能够在类外被调用&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
在我之前的知识积累中， &lt;b&gt;私有的成员变量或成员函数是不能够在类外被访问的&lt;/b&gt; 。那么为什么以上代码没有问题呢？&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
在C++标准中找到了下面的一段话(可以在 &lt;a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3690.pdf"&gt;C++11 standard&lt;/a&gt; 的 9.4.2节 或  &lt;a href="http://eel.is/c++draft/class.static.data#2"&gt;C++ standard working draft&lt;/a&gt; 的 10.3.9.2节 中找到)&lt;br&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
The initializer expression in the definition of a static data member is in the scope of its class.&lt;br&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
这句话的意思是：静态成员变量的初始化是被看做为它自身的类域中的（ &lt;del&gt;翻译的可能不是很准&lt;/del&gt; ）。这样就不难理解为什么私有的静态成员变量能够在其类外被初始化了，由其私有构造函数进行构造也能说的通了。&lt;br&gt;
&lt;/p&gt;


&lt;p&gt;
&lt;b&gt;同样&lt;/b&gt; ,在C++标准中给出了下面这样的示例代码：&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;process&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;run_chain&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;running&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="n"&gt;process&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;running&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;get_main&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;process&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;run_chain&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;running&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
给出的说明如下：&lt;br&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
The static data member &lt;code&gt;run_chain&lt;/code&gt; of class process is defined in global scope; the notation &lt;code&gt;process​::​run_chain&lt;/code&gt; specifies that the member &lt;code&gt;run_chain&lt;/code&gt; is a member of class &lt;code&gt;process&lt;/code&gt; and in the scope of class &lt;code&gt;process&lt;/code&gt;. In the static data member definition, the initializer expression refers to the static data member running of class &lt;code&gt;process&lt;/code&gt;.&lt;br&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
静态成员 &lt;code&gt;run_chain&lt;/code&gt; 定义在全局域；而 &lt;code&gt;process::run_chain&lt;/code&gt; 则表示 &lt;code&gt;run_chain&lt;/code&gt; 是 &lt;code&gt;process&lt;/code&gt; 类的成员变量，从而处在 &lt;code&gt;process&lt;/code&gt; 类的作用域中。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org494ceab" class="outline-2"&gt;
&lt;h2 id="org494ceab"&gt;私有构造函数&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org494ceab"&gt;
&lt;p&gt;
在查阅资料时，我发现 Peter 的 &lt;a href="https://stackoverflow.com/a/41361967"&gt;描述&lt;/a&gt; 纠正了我对私有构造函数的一些看法。&lt;br&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
The point of a &lt;code&gt;private&lt;/code&gt; constructor is not preventing object construction. It is about controlling which code can access the constructor, and therefore limiting which code to create an object that is an instance of that class. A &lt;code&gt;private&lt;/code&gt; constructor is accessible to all member functions ( &lt;code&gt;static&lt;/code&gt; or otherwise) of the class, and to all declared &lt;code&gt;friend&lt;/code&gt; s of the class (which may be individual functions, or other classes) - so any of those can create an instance of the class using a &lt;code&gt;private&lt;/code&gt; constructor (assuming the constructor is defined).&lt;br&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
私有构造函数的目的并不是禁止对象构造，其目的在于控制哪些代码能够调用这个构造函数，进而限制类对象的创建。私有的构造函数可以被该类的所有成员函数（静态或非静态的）调用，该类的友元类或友元方法也能访问该类的私有函数，所以在上述情况中都可以通过私有的构造函数实例化出类对象。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb71d845" class="outline-2"&gt;
&lt;h2 id="orgb71d845"&gt;参考资料&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgb71d845"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3690.pdf"&gt;ISO C++11 standard&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://eel.is/c++draft/class.static.data#2"&gt;ISO C++ standard working draft&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/38583989/access-to-private-static-function-during-static-member-initialization"&gt;stackoverflow.com - access to private static function…&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/41361223/why-private-constructor-prevents-object-creation-c"&gt;stackoverflow.com - private constructor&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/7857989/static-member-variable-when-declared-private"&gt;stackoverflow.com - static member variable when declared private&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.cppreference.com/w/cpp/language/static#Static_data_members"&gt;cppreference.com - static data members&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>cpp</category><category>syntax</category><guid>https://samsonwang.me/posts/static-member-initialization-and-private-member-function/</guid><pubDate>Tue, 04 Sep 2018 15:37:37 GMT</pubDate></item><item><title>javscript中的OOP特性</title><link>https://samsonwang.me/posts/javascript-object-oriented-programming/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div id="outline-container-orgc565576" class="outline-2"&gt;
&lt;h2 id="orgc565576"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; 引言&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
js也是具有OOP（object oriented programming）特性的，OOP在构建一些大型应用程序还是有一套成熟理论的。作为C++的使用者在学习js中的OOP特性的过程中，能够较快地理解其中的各种术语和概念，也能比较两种语言的异同，深化知识理解。通过js的OOP特性的学习也让我开始从语言层面考虑程序设计问题。&lt;br&gt;
本篇文章主要介绍了js中的一些OOP特性，并且比较了js与C++的语言特性。如果你能熟练掌握C++的OOP特性，本文能帮助你快速地对js中的OOP特性建立整体的认识。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org79047ac" class="outline-2"&gt;
&lt;h2 id="org79047ac"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; 写给C++使用者的js中的OOP特性介绍&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgf2794de" class="outline-3"&gt;
&lt;h3 id="orgf2794de"&gt;&lt;span class="section-number-3"&gt;2.1&lt;/span&gt; 创建对象（object）&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-1"&gt;
&lt;p&gt;
js中创建object的代码，示例如下：&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;let duck = {
  name: "Aflac",
  numLegs: 2,
  sayName: function() {
    return "The name of this duck is " + this.name + ".";
  }
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
js直接通过 &lt;code&gt;{}&lt;/code&gt; 就可以创建出对象示例来，不需要对该对象（object）的类（class）进行声明。这点和C++不是很相同，C++需要先声明一个class再创建object。&lt;br&gt;
这个object有两个成员变量和一个成员函数，需要注意的是这两个成员变量都是公有（public）的，他们是可以直接用 &lt;code&gt;.&lt;/code&gt; 符号访问的。&lt;br&gt;
js中也有 &lt;code&gt;this&lt;/code&gt; 关键字，与C++相同， &lt;code&gt;this&lt;/code&gt; 关键字用于表示当前实例。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org9ed4029" class="outline-3"&gt;
&lt;h3 id="org9ed4029"&gt;&lt;span class="section-number-3"&gt;2.2&lt;/span&gt; 类（class）的声明&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-2"&gt;
&lt;p&gt;
js中声明一个类的操作实际上就是声明一个构造函数。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;let Bird = function(name, color) {
  this.name = name;
  this.color = color;
  this.numLegs = 2;
}

let crow = new Bird("Alexis", "black");

crow instanceof Bird; // =&amp;gt; true
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
上面的代码声明了Bird类，在js中通常类的名字都是由首字母大写的单词表示的。类的构造函数也能接受参数用于对实例的初始化，这点与C++非常相似，使用 &lt;code&gt;new&lt;/code&gt; 关键字就能够创建该类的实例。&lt;br&gt;
使用 &lt;code&gt;instanceof&lt;/code&gt; 关键字用于检查对象是否属于某个类，也可通过验证 &lt;code&gt;constructor&lt;/code&gt; 属性来判断一个对象是否属于一个类 &lt;code&gt;crow.constructor == Bird&lt;/code&gt; 。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org3eb8043" class="outline-3"&gt;
&lt;h3 id="org3eb8043"&gt;&lt;span class="section-number-3"&gt;2.3&lt;/span&gt; 类的共有成员&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-3"&gt;
&lt;p&gt;
js中通过 &lt;code&gt;prototype&lt;/code&gt; 这一属性（把它叫做关键字好像还不太合适）能够实现C++中静态成员变量和静态成员函数的特性。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Bird.prototype.numLegs = 2;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
上面的代码就给Bird类增加了一个静态成员变量。这个 &lt;code&gt;prototype&lt;/code&gt; 可以是一个对象，这样类的共有成员就能方便地承载更多的属性了，示例代码如下。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Bird.prototype = {
  constructor: Bird,
  numLegs: 2,
  eat: function() {
    console.log("nom nom nom");
  },
  describe: function() {
    console.log("My name is " + this.name);
  }
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
需要注意的是需要设置好 &lt;code&gt;constructor&lt;/code&gt; 属性，这样是为了保证代码逻辑的一致性。&lt;br&gt;
对象会获得类的 &lt;code&gt;prototype&lt;/code&gt; 属性，可以通过 &lt;code&gt;isPrototypeof&lt;/code&gt; 方法来验证。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Bird.prototype.isPrototypeOf(duck);
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org2896dfc" class="outline-3"&gt;
&lt;h3 id="org2896dfc"&gt;&lt;span class="section-number-3"&gt;2.4&lt;/span&gt; 类的私有成员&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-4"&gt;
&lt;p&gt;
js与C++一样，也可以有私有成员变量，代码如下所示。 &lt;code&gt;hatchedEgg&lt;/code&gt; 就相当与是Bird的私有成员变量，并且提供了修改这个成员变量的方法 &lt;code&gt;getHatchedEggCount&lt;/code&gt; 。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;function Bird() {
  let hatchedEgg = 10; // private property

  this.getHatchedEggCount = function() {
    // publicly available method that a bird object can use
    return hatchedEgg;
  };
}
let ducky = new Bird();
ducky.getHatchedEggCount(); // returns 10
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
这种形式在js中被称作闭包（closure），函数能够访问到与他处在同一个作用域（context）中的变量。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org60ae5c2" class="outline-3"&gt;
&lt;h3 id="org60ae5c2"&gt;&lt;span class="section-number-3"&gt;2.5&lt;/span&gt; 类的继承和派生&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-5"&gt;
&lt;p&gt;
js中的派生主要通过 &lt;code&gt;prototype&lt;/code&gt; 体现，下面的代码表示Bird派生自Object。同样，需要注意将 &lt;code&gt;constructor&lt;/code&gt; 属性设置好。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Bird.prototype = Object.create(Animal.prototype);
Bird.prototype.constructor = Bird;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org8e08442" class="outline-3"&gt;
&lt;h3 id="org8e08442"&gt;&lt;span class="section-number-3"&gt;2.6&lt;/span&gt; 类的覆盖&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-6"&gt;
&lt;p&gt;
js中可以重写基类中的方法，代码如下所示，这点与C++中的 &lt;code&gt;override&lt;/code&gt; 相同。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;function Animal() { }
Animal.prototype.eat = function() {
  return "nom nom nom";
};
function Bird() { }

// Inherit all methods from Animal
Bird.prototype = Object.create(Animal.prototype);

// Bird.eat() overrides Animal.eat()
Bird.prototype.eat = function() {
  return "peck peck peck";
};

Bird.prototype.fly = function() {
  console.log("I'm flying!");
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
通样也在派生之后也可以通过修改派生类的 &lt;code&gt;prototype&lt;/code&gt; 以达到特化派生类的作用，上面的 &lt;code&gt;fly&lt;/code&gt; 方法就是在Bird完成派生之后新增的方法。现在Bird有两个方法，它们分别是 &lt;code&gt;eat&lt;/code&gt; 和 &lt;code&gt;fly&lt;/code&gt; 。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org7add9b7" class="outline-2"&gt;
&lt;h2 id="org7add9b7"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; 参考资料&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/object-oriented-programming/"&gt;FCC javascript oop tutorial&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>cpp</category><category>javascript</category><category>oop</category><guid>https://samsonwang.me/posts/javascript-object-oriented-programming/</guid><pubDate>Sun, 26 Aug 2018 02:31:37 GMT</pubDate></item><item><title>C/C++中的位域</title><link>https://samsonwang.me/posts/bit-field/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div id="outline-container-orgc7b4427" class="outline-2"&gt;
&lt;h2 id="orgc7b4427"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; 什么是位域&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
&lt;a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E6%AE%B5"&gt;维基百科&lt;/a&gt; 给出了以下解释&lt;br&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
位域（或称“位段”，bit field）为一种数据结构，可以把数据以位的形式紧凑的储存，并允许程序员对此结构的位进行操作。&lt;br&gt;
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;
&lt;a href="https://en.cppreference.com/w/cpp/language/bit_field"&gt;cppreference&lt;/a&gt; 给出了以下定义&lt;br&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
Declares a class data member with explicit size, in bits. Adjacent bit field members may be packed to share and straddle the individual bytes.&lt;br&gt;
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;
这种数据结构的好处：&lt;br&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;可以使数据单元节省储存空间，当程序需要成千上万个数据单元时，这种方法就显得尤为重要。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;位段可以很方便的访问一个整数值的部分内容从而可以简化程序源代码。&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
而位域这种数据结构的缺点在于，其内存分配与内存对齐的实现方式依赖于具体的机器和系统，在不同的平台可能有不同的结果，这导致了位段在本质上是不可移植的。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgd98702b" class="outline-2"&gt;
&lt;h2 id="orgd98702b"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; 位域的语法&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;identifier&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;optional&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;attr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;optional&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
注意：&lt;br&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;size的大小不能超过identifier所包含最大比特位个数。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;identifier为空时表示对应的size个数的比特位不使用&lt;br&gt;&lt;/li&gt;
&lt;li&gt;size为0时表示根据前类型强制补齐&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;S1&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// will usually occupy 2 bytes:&lt;/span&gt;
    &lt;span class="c1"&gt;// 3 bits: value of b1&lt;/span&gt;
    &lt;span class="c1"&gt;// 2 bits: unused&lt;/span&gt;
    &lt;span class="c1"&gt;// 6 bits: value of b2&lt;/span&gt;
    &lt;span class="c1"&gt;// 2 bits: value of b3&lt;/span&gt;
    &lt;span class="c1"&gt;// 3 bits: unused&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="nl"&gt;b1&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nl"&gt;b2&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nl"&gt;b3&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;S2&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// will usually occupy 2 bytes:&lt;/span&gt;
    &lt;span class="c1"&gt;// 3 bits: value of b1&lt;/span&gt;
    &lt;span class="c1"&gt;// 5 bits: unused&lt;/span&gt;
    &lt;span class="c1"&gt;// 6 bits: value of b2&lt;/span&gt;
    &lt;span class="c1"&gt;// 2 bits: value of b3&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="nl"&gt;b1&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// start a new byte&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="nl"&gt;b2&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="nl"&gt;b3&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgcdddbb1" class="outline-3"&gt;
&lt;h3 id="orgcdddbb1"&gt;&lt;span class="section-number-3"&gt;2.1&lt;/span&gt; 在size取0时如何理解&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-1"&gt;
&lt;p&gt;
对于size取0时的各种情况进行了尝试，详细用例如下。思路是使用联合体能比较方便地将内存分布表示出来。&lt;br&gt;
如下所示，定义了如下几种情况。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf75adc7" class="outline-4"&gt;
&lt;h4 id="orgf75adc7"&gt;&lt;span class="section-number-4"&gt;2.1.1&lt;/span&gt; case1&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-2-1-1"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;union&lt;/span&gt; &lt;span class="n"&gt;un1&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
	&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nl"&gt;nn1&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
	&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
	&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nl"&gt;nn2&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;st&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
对联合体中的结构体位段进行赋值，并将联合体中的内容打印出来。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;union&lt;/span&gt; &lt;span class="n"&gt;un1&lt;/span&gt; &lt;span class="n"&gt;u1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;u1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;st&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;nn1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;u1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;st&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;nn2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"union u1.n1=0x%08x sizeof(un1)=%zu&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;u1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;n1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;un1&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
输出结果为&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;union&lt;/span&gt; &lt;span class="n"&gt;un1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;n1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mh"&gt;0x00000001&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;un1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org1a187b4" class="outline-4"&gt;
&lt;h4 id="org1a187b4"&gt;&lt;span class="section-number-4"&gt;2.1.2&lt;/span&gt; case2&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-2-1-2"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;union&lt;/span&gt; &lt;span class="n"&gt;un1&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
	&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nl"&gt;nn1&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
	&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
	&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nl"&gt;nn2&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;st&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
输出结果为&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;union&lt;/span&gt; &lt;span class="n"&gt;un1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;n1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mh"&gt;0x00000101&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;un1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgd302c37" class="outline-4"&gt;
&lt;h4 id="orgd302c37"&gt;&lt;span class="section-number-4"&gt;2.1.3&lt;/span&gt; case3&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-2-1-3"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;union&lt;/span&gt; &lt;span class="n"&gt;un1&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
	&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nl"&gt;nn1&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
	&lt;span class="kt"&gt;short&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
	&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nl"&gt;nn2&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;st&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
输出结果为&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;union&lt;/span&gt; &lt;span class="n"&gt;un1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;n1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mh"&gt;0x00010001&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;un1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org6c15566" class="outline-4"&gt;
&lt;h4 id="org6c15566"&gt;&lt;span class="section-number-4"&gt;2.1.4&lt;/span&gt; case4&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-2-1-4"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;union&lt;/span&gt; &lt;span class="n"&gt;un1&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
	&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nl"&gt;nn1&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
	&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
	&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nl"&gt;nn2&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;st&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
输出结果为&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;union&lt;/span&gt; &lt;span class="n"&gt;un1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;n1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mh"&gt;0x00000101&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;un1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org856e17e" class="outline-3"&gt;
&lt;h3 id="org856e17e"&gt;&lt;span class="section-number-3"&gt;2.2&lt;/span&gt; &lt;code&gt;struct&lt;/code&gt; 标识符&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-2"&gt;
&lt;p&gt;
多数例子都是以 &lt;code&gt;struct&lt;/code&gt; 作为位域的组织标识，在C++中能否使用 &lt;code&gt;class&lt;/code&gt; 作为位域的标识符。&lt;br&gt;
经过测试，是可以使用 &lt;code&gt;class&lt;/code&gt; 的，但是需要注意 &lt;code&gt;class&lt;/code&gt; 的默认访问控制属性为 &lt;code&gt;private&lt;/code&gt;&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org8cbb13d" class="outline-2"&gt;
&lt;h2 id="org8cbb13d"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; 位域的常见应用场景&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
&lt;b&gt;为什么要使用位域？位域适合那些情况？&lt;/b&gt;&lt;br&gt;
位域的主要使用目的是节省对象的内存使用。在存放一些比较小的数据时，使用位域能够使字节中的每个比特位合理地利用起来，避免内存浪费。&lt;br&gt;
比较典型的应用是描述硬件寄存器。如果有32个一组的寄存器，每个寄存器代表一个比特位，就可以使用位域表示这组寄存器。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgc7ba7be" class="outline-2"&gt;
&lt;h2 id="orgc7ba7be"&gt;&lt;span class="section-number-2"&gt;4&lt;/span&gt; C++中的位操作接口&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;p&gt;
C++中也提供了一套位操作的接口 &lt;code&gt;std::bitset&lt;/code&gt; ，这套接口提供了指定比特位数据的操作接口。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgafa0e9e" class="outline-2"&gt;
&lt;h2 id="orgafa0e9e"&gt;&lt;span class="section-number-2"&gt;5&lt;/span&gt; 参考资料&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-5"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E6%AE%B5"&gt;wikipedia bit-field&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.cppreference.com/w/cpp/language/bit_field"&gt;cppreference bit-field&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://msdn.microsoft.com/zh-cn/library/ewwyfdbe.aspx"&gt;microsoft msdn&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/24933242/when-to-use-bit-fields-in-c"&gt;stackoverflow&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.cppreference.com/w/cpp/utility/bitset"&gt;cppreference std::bitset&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>cpp</category><guid>https://samsonwang.me/posts/bit-field/</guid><pubDate>Wed, 11 Jul 2018 10:03:37 GMT</pubDate></item><item><title>C风格和C++风格的文件操作库函数总结</title><link>https://samsonwang.me/posts/c-style-and-cpp-style-file-api/</link><dc:creator>Samson Wang</dc:creator><description>&lt;p&gt;
由于C++是兼容C的，所以使用C++进行文件操作时，会发现有两套库函数可以使用，它们分别是C风格的和C++风格的。&lt;br&gt;
&lt;/p&gt;

&lt;div id="outline-container-org82b888d" class="outline-2"&gt;
&lt;h2 id="org82b888d"&gt;C风格的文件操作函数&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org82b888d"&gt;
&lt;p&gt;
&lt;b&gt;打开文件，关闭文件&lt;/b&gt;&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;FILE&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;fopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;fclose&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;FILE&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
&lt;b&gt;读取文件，写入文件&lt;/b&gt;&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="nf"&gt;fread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;nmemb&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;FILE&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="nf"&gt;fwrite&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;nmemb&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;FILE&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
关于fread中两个表示大小的参数，在这个 &lt;a href="https://stackoverflow.com/questions/8589425/how-does-fread-really-work"&gt;stackoverflow&lt;/a&gt; 问题中得到了比较好的解答。&lt;br&gt;
&lt;/p&gt;


&lt;p&gt;
&lt;b&gt;改变文件指示器的位置&lt;/b&gt;&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;fseek&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;FILE&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;offset&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;whence&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="nf"&gt;ftell&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;FILE&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;rewind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;FILE&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org6b645ca" class="outline-2"&gt;
&lt;h2 id="org6b645ca"&gt;C++风格的文件操作函数&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org6b645ca"&gt;
&lt;p&gt;
C++将文件操作函数封装为 &lt;code&gt;fstream&lt;/code&gt; 操作类，一个文件实际上就会对应一个 &lt;code&gt;fstream&lt;/code&gt; 对象，一下函数都是 &lt;code&gt;fstream&lt;/code&gt; 的成员函数。&lt;br&gt;
文件打开和关闭&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ios_base&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;openmode&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ios_base&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;in&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;ios_base&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ios_base&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;openmode&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ios_base&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;in&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;ios_base&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;close&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
对于文件的读写可以才采用流运算符重载的方法完成。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="n"&gt;fstream&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fstream&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;ofs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;CRecord&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;objRecord&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="n"&gt;fstream&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fstream&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;ifs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;CRecord&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;objRecord&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-orgd7d550d" class="outline-2"&gt;
&lt;h2 id="orgd7d550d"&gt;题外话&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgd7d550d"&gt;
&lt;p&gt;
在liunx下，可以使用wc命令查看文件中的相关信息。wc命令会打印出该文件的行数、单词数、字符数。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>cpp</category><category>linux</category><guid>https://samsonwang.me/posts/c-style-and-cpp-style-file-api/</guid><pubDate>Wed, 16 May 2018 10:06:45 GMT</pubDate></item><item><title>字节序与union类型</title><link>https://samsonwang.me/posts/endianness-and-union-type/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div id="outline-container-org4c42c7a" class="outline-2"&gt;
&lt;h2 id="org4c42c7a"&gt;字节序&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org4c42c7a"&gt;
&lt;p&gt;
字节序是指在数据传输时，高位字节存储在内存中的较高位地址还是较低位地址。&lt;br&gt;
字节序分为大端字节序和小端字节序，两种字节序不能混用。&lt;br&gt;
&lt;b&gt;大端字节序&lt;/b&gt; ：高位字节保存在较低位地址的内存中&lt;br&gt;
&lt;b&gt;小端字节序&lt;/b&gt; ：高位字节保存在较高位地址的内存中&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
以 &lt;code&gt;int n = 0x12345678&lt;/code&gt; 为例，大端字节序内存中的存储的顺序为 &lt;code&gt;0x12 0x34 0x56 0x78&lt;/code&gt; ，小端字节序内存中的存储顺序为 &lt;code&gt;0x78 0x56 0x34 0x12&lt;/code&gt; 。很明显可以看出大端字节序更符合人类的阅读习惯。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
常见的大端系统CPU：IBM z/Atchitecture&lt;br&gt;
常见的小端系统CPU：intel x86&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
网络字节序使用的大端字节序，常用网络协议如IPv4、IPv6、TCP和UDP协议都是使用大端字节序完成数据传输的。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;



&lt;div id="outline-container-orgf3c15de" class="outline-2"&gt;
&lt;h2 id="orgf3c15de"&gt;查看当前系统的字节序&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgf3c15de"&gt;
&lt;p&gt;
通过 &lt;code&gt;lscpu&lt;/code&gt; 命令，能得到cpu的大端和小端信息。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;lscpu &lt;span class="p"&gt;|&lt;/span&gt; grep -i endian
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
通过常用shell命令，在大端系统中会输出0，在小端系统中会输出1。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; -n I &lt;span class="p"&gt;|&lt;/span&gt; od -to2 &lt;span class="p"&gt;|&lt;/span&gt; head -n1 &lt;span class="p"&gt;|&lt;/span&gt; cut -f2 -d&lt;span class="s2"&gt;" "&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; cut -c6
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
借助python进行判断。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;python -c &lt;span class="s2"&gt;"import sys; print(sys.byteorder)"&lt;/span&gt;
&lt;span class="c1"&gt;# or&lt;/span&gt;
python -c &lt;span class="s2"&gt;"import sys;sys.exit(0 if sys.byteorder=='big' else 1)"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
借助linux的ELF进行判断，查看第6个字节，小端系统中为1，大端系统中为2。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;xxd -c &lt;span class="m"&gt;1&lt;/span&gt; -l &lt;span class="m"&gt;6&lt;/span&gt; /bin/bash
&lt;span class="c1"&gt;# or&lt;/span&gt;
hexdump -n &lt;span class="m"&gt;6&lt;/span&gt; -C /bin/bash
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;



&lt;div id="outline-container-org8e40552" class="outline-2"&gt;
&lt;h2 id="org8e40552"&gt;union类型&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org8e40552"&gt;
&lt;p&gt;
可以使用union类型验证字节序，以下示例代码在不同的字节序下会有不同的输出。&lt;br&gt;
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;inttypes.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;union&lt;/span&gt; &lt;span class="n"&gt;un&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int32_t&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;ch&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="n"&gt;un&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;un&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ch&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ch&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ch&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ch&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"u.x=0x%x&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org8e385a9" class="outline-2"&gt;
&lt;h2 id="org8e385a9"&gt;参考资料&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org8e385a9"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Endianness"&gt;wikipedia.com - endianness&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://serverfault.com/questions/163487/how-to-tell-if-a-linux-system-is-big-endian-or-little-endian"&gt;serverfault.com - how to check endian&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format"&gt;wikipedia.com - ELF format&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
（全文完）&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>computer science</category><category>cpp</category><category>endian</category><category>union</category><guid>https://samsonwang.me/posts/endianness-and-union-type/</guid><pubDate>Fri, 11 May 2018 01:55:34 GMT</pubDate></item></channel></rss>