<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="/assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Hack Note (Posts about cpp)</title><link>https://samsonwang.me/</link><description></description><atom:link href="https://samsonwang.me/tags/cpp.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2017-2019 &lt;a href="mailto:wangzhilv@gmail.com"&gt;Samson Wang&lt;/a&gt; 
&lt;a rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/"&gt;&lt;img alt="知识共享许可协议" style="padding-bottom:2px" src="https://i.creativecommons.org/l/by-nc/4.0/80x15.png" /&gt;&lt;/a&gt;
</copyright><lastBuildDate>Wed, 03 Apr 2019 08:35:09 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>分支预测技术</title><link>https://samsonwang.me/posts/branch-prediction-optimization/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div&gt;&lt;p&gt;
分支预测技术是CPU体系结构（architecture）中的知识点，用于提高指令（instruction）的执行效率。本篇博文是对网络上相关信息的总结，以备后续查阅使用。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://samsonwang.me/posts/branch-prediction-optimization/"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>branch prediction</category><category>cpp</category><category>optimization</category><guid>https://samsonwang.me/posts/branch-prediction-optimization/</guid><pubDate>Thu, 28 Mar 2019 02:13:32 GMT</pubDate></item><item><title>深入探索C++内存模型（2）</title><link>https://samsonwang.me/posts/inside-the-cpp-object-model-2/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div&gt;&lt;p&gt;
构造函语意学是本书的第二章，这一章节主要针对构造函数在不同情况的底层实现细节进行的全面的讨论。阐述了在类对象（class object）的构造期间，编译器进行的额外操作的原理。针对默认构造函数（default constructor）和拷贝构造函数（copy constructor）分别展开了细致的讨论，引出了编译器 NRV 优化的概念，揭示了成员初始化列表的作用机理。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://samsonwang.me/posts/inside-the-cpp-object-model-2/"&gt;Read more…&lt;/a&gt; (2 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>cpp</category><category>digest</category><category>Lippman</category><category>memory layout</category><category>object model</category><guid>https://samsonwang.me/posts/inside-the-cpp-object-model-2/</guid><pubDate>Mon, 25 Mar 2019 07:52:36 GMT</pubDate></item><item><title>深入探索C++内存模型（1）</title><link>https://samsonwang.me/posts/inside-the-cpp-object-model-1/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div&gt;&lt;p&gt;
最近花时间读了一下《深入探索C++内存模型》，这本带我了解到了更底层的C++知识。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
这本书从C++语言各种特性的实现机制上进行细致剖析，进而总结出对软件开发具有指导意义的经验和结论。这本书的目标群体是具有开发经验的中高级开发人员，其内容的专业性是不容质疑的。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
从我的阅读感受上讲，它相对比那些一般的技术文档要耗时耗力。全书共三百多页，粗略地估算了一下，我却用了一个月的空余时间才读完。我会将读书笔记整理成博文，这样能够加深记忆，也方便以后查阅。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://samsonwang.me/posts/inside-the-cpp-object-model-1/"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>cpp</category><category>digest</category><category>Lippman</category><category>memory layout</category><category>object model</category><guid>https://samsonwang.me/posts/inside-the-cpp-object-model-1/</guid><pubDate>Mon, 11 Mar 2019 02:30:13 GMT</pubDate></item><item><title>C++(Qt)和Python混合编程的一些经验之谈</title><link>https://samsonwang.me/posts/cpp-python-hybird-programming/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div&gt;&lt;p&gt;
在Launchy的开发中，我使用了Python作为Qt程序的插件开发语言，最近有朋友问我Qt和Python结合使用的一些细节。结合我之前踩坑的经历，C++（Qt）和Python的混合编程可以从几个方面进行考虑。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://samsonwang.me/posts/cpp-python-hybird-programming/"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>cpp</category><category>launchy</category><category>python</category><category>qt</category><guid>https://samsonwang.me/posts/cpp-python-hybird-programming/</guid><pubDate>Fri, 01 Feb 2019 00:53:37 GMT</pubDate></item><item><title>线程API总结</title><link>https://samsonwang.me/posts/thread-api-cheatsheet/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div&gt;&lt;p&gt;
线程的使用在软件开发中是十分普遍的，本文总结了两种常用的线程API接口：POSIX线程和CPP11线程。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://samsonwang.me/posts/thread-api-cheatsheet/"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>cpp</category><category>cpp11</category><category>linux</category><category>posix</category><category>thread</category><guid>https://samsonwang.me/posts/thread-api-cheatsheet/</guid><pubDate>Mon, 14 Jan 2019 02:50:31 GMT</pubDate></item><item><title>谈谈自己在开发launchy时的一些收获</title><link>https://samsonwang.me/posts/launchy-dev-note-1/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div&gt;&lt;p&gt;
在开发launchy时，我学到了很多开发相关的技巧，对于如何做好一款软件也有了更加全面的认识。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://samsonwang.me/posts/launchy-dev-note-1/"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>cpp</category><category>launchy</category><guid>https://samsonwang.me/posts/launchy-dev-note-1/</guid><pubDate>Wed, 09 Jan 2019 03:54:32 GMT</pubDate></item><item><title>C++常用的时间接口</title><link>https://samsonwang.me/posts/cpp-time-cheatsheet/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div&gt;&lt;p&gt;
与时间相关的操作在开发中是十分常见的，本文总结了常用时间接口，并给出了示例代码。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://samsonwang.me/posts/cpp-time-cheatsheet/"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>chrono</category><category>cpp</category><category>cpp11</category><category>time</category><guid>https://samsonwang.me/posts/cpp-time-cheatsheet/</guid><pubDate>Fri, 04 Jan 2019 08:05:56 GMT</pubDate></item><item><title>C++中的智能指针</title><link>https://samsonwang.me/posts/smart-pointers-in-cpp/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div&gt;&lt;p&gt;
C++中有很多智能指针如 &lt;code&gt;unique_ptr&lt;/code&gt; 和 &lt;code&gt;shared_ptr&lt;/code&gt; ，本篇文章主要介绍这些指针的功能和应用场景。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://samsonwang.me/posts/smart-pointers-in-cpp/"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>cpp</category><category>shared_ptr</category><category>smart pointer</category><category>unique_ptr</category><guid>https://samsonwang.me/posts/smart-pointers-in-cpp/</guid><pubDate>Wed, 28 Nov 2018 15:51:57 GMT</pubDate></item><item><title>写在launchy3.0.3发布之后</title><link>https://samsonwang.me/posts/launchy-maintain-303/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div&gt;&lt;p&gt;
维护launchy也有一段时间了，目前已经发了4个版本，整体功能也趋于稳定。在维护launchy的过程中有很多思考，今天集中写下来，算是里程碑样的记录。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://samsonwang.me/posts/launchy-maintain-303/"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>cpp</category><category>launchy</category><category>python</category><category>qt</category><guid>https://samsonwang.me/posts/launchy-maintain-303/</guid><pubDate>Mon, 26 Nov 2018 13:04:04 GMT</pubDate></item><item><title>静态成员变量初始化相关问题</title><link>https://samsonwang.me/posts/static-member-initialization-and-private-member-function/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div id="outline-container-org9f39c2d" class="outline-2"&gt;
&lt;h2 id="org9f39c2d"&gt;引言&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org9f39c2d"&gt;
&lt;p&gt;
这篇文章的起因是出于对于 &lt;code&gt;C++&lt;/code&gt; 饿汉单例模式代码的一些疑问，查阅了一些资料。在仔细研究后，我发现在一些基础概念的理解还是存在偏差。&lt;br&gt;
下面请看这样的一段代码，能看出其中有那些不太“正常”的语句么。&lt;br&gt;
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Singleton&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;Singleton&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;getInstance&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;Singleton&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;Singleton&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;instance&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="n"&gt;Singleton&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;Singleton&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;instance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Singleton&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;Singleton&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;Singleton&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;getInstance&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;instance&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orga12a676" class="outline-2"&gt;
&lt;h2 id="orga12a676"&gt;私有静态成员的初始化&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orga12a676"&gt;
&lt;p&gt;
上面的代码是饿汉单例模式的 &lt;code&gt;C++&lt;/code&gt; 的实现，在没有查阅资料之前，我对其中私有静态成员变量的初始化存疑。主要有以下两点：&lt;br&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;为什么私有变量能够在类外被修改&lt;br&gt;&lt;/li&gt;
&lt;li&gt;为什么私有构造函数能够在类外被调用&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
在我之前的知识积累中， &lt;b&gt;私有的成员变量或成员函数是不能够在类外被访问的&lt;/b&gt; 。那么为什么以上代码没有问题呢？&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
在C++标准中找到了下面的一段话(可以在 &lt;a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3690.pdf"&gt;C++11 standard&lt;/a&gt; 的 9.4.2节 或  &lt;a href="http://eel.is/c++draft/class.static.data#2"&gt;C++ standard working draft&lt;/a&gt; 的 10.3.9.2节 中找到)&lt;br&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
The initializer expression in the definition of a static data member is in the scope of its class.&lt;br&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
这句话的意思是：静态成员变量的初始化是被看做为它自身的类域中的（ &lt;del&gt;翻译的可能不是很准&lt;/del&gt; ）。这样就不难理解为什么私有的静态成员变量能够在其类外被初始化了，由其私有构造函数进行构造也能说的通了。&lt;br&gt;
&lt;/p&gt;


&lt;p&gt;
&lt;b&gt;同样&lt;/b&gt; ,在C++标准中给出了下面这样的示例代码：&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;process&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;run_chain&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;running&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="n"&gt;process&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;running&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;get_main&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;process&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;run_chain&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;running&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
给出的说明如下：&lt;br&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
The static data member &lt;code&gt;run_chain&lt;/code&gt; of class process is defined in global scope; the notation &lt;code&gt;process​::​run_chain&lt;/code&gt; specifies that the member &lt;code&gt;run_chain&lt;/code&gt; is a member of class &lt;code&gt;process&lt;/code&gt; and in the scope of class &lt;code&gt;process&lt;/code&gt;. In the static data member definition, the initializer expression refers to the static data member running of class &lt;code&gt;process&lt;/code&gt;.&lt;br&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
静态成员 &lt;code&gt;run_chain&lt;/code&gt; 定义在全局域；而 &lt;code&gt;process::run_chain&lt;/code&gt; 则表示 &lt;code&gt;run_chain&lt;/code&gt; 是 &lt;code&gt;process&lt;/code&gt; 类的成员变量，从而处在 &lt;code&gt;process&lt;/code&gt; 类的作用域中。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org573b1b4" class="outline-2"&gt;
&lt;h2 id="org573b1b4"&gt;私有构造函数&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org573b1b4"&gt;
&lt;p&gt;
在查阅资料时，我发现 Peter 的 &lt;a href="https://stackoverflow.com/a/41361967"&gt;描述&lt;/a&gt; 纠正了我对私有构造函数的一些看法。&lt;br&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
The point of a &lt;code&gt;private&lt;/code&gt; constructor is not preventing object construction. It is about controlling which code can access the constructor, and therefore limiting which code to create an object that is an instance of that class. A &lt;code&gt;private&lt;/code&gt; constructor is accessible to all member functions ( &lt;code&gt;static&lt;/code&gt; or otherwise) of the class, and to all declared &lt;code&gt;friend&lt;/code&gt; s of the class (which may be individual functions, or other classes) - so any of those can create an instance of the class using a &lt;code&gt;private&lt;/code&gt; constructor (assuming the constructor is defined).&lt;br&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
私有构造函数的目的并不是禁止对象构造，其目的在于控制哪些代码能够调用这个构造函数，进而限制类对象的创建。私有的构造函数可以被该类的所有成员函数（静态或非静态的）调用，该类的友元类或友元方法也能访问该类的私有函数，所以在上述情况中都可以通过私有的构造函数实例化出类对象。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org1740918" class="outline-2"&gt;
&lt;h2 id="org1740918"&gt;参考资料&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org1740918"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3690.pdf"&gt;ISO C++11 standard&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://eel.is/c++draft/class.static.data#2"&gt;ISO C++ standard working draft&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/38583989/access-to-private-static-function-during-static-member-initialization"&gt;stackoverflow.com - access to private static function…&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/41361223/why-private-constructor-prevents-object-creation-c"&gt;stackoverflow.com - private constructor&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/7857989/static-member-variable-when-declared-private"&gt;stackoverflow.com - static member variable when declared private&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.cppreference.com/w/cpp/language/static#Static_data_members"&gt;cppreference.com - static data members&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>cpp</category><category>syntax</category><guid>https://samsonwang.me/posts/static-member-initialization-and-private-member-function/</guid><pubDate>Tue, 04 Sep 2018 15:37:37 GMT</pubDate></item></channel></rss>