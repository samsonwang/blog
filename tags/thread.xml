<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="/assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Hack Note (Posts about thread)</title><link>https://blog.wangzhl.com/</link><description></description><atom:link href="https://blog.wangzhl.com/tags/thread.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2017-2024 &lt;a href="mailto:wangzhilv@gmail.com"&gt;Samson Wang&lt;/a&gt; 
&lt;a rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/"&gt;
&lt;img alt="cc-by-nc 4.0" style="padding-bottom:2px" src="/images/cc-by-nc.png" /&gt;&lt;/a&gt;
</copyright><lastBuildDate>Wed, 31 Jul 2024 10:23:25 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>为什么条件变量需要与互斥锁配合使用</title><link>https://blog.wangzhl.com/posts/2019/why-condition-variable-requires-mutex/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div&gt;&lt;p&gt;
条件变量（condition variable）是常用的线程同步技术，通常用于让线程阻塞并等待某个条件满足。它需要与互斥锁搭配使用，但是你有想过为什么需要搭配一个互斥锁呢？&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://blog.wangzhl.com/posts/2019/why-condition-variable-requires-mutex/"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>boost</category><category>condition variable</category><category>cpp</category><category>cpp11</category><category>mutex</category><category>thread</category><guid>https://blog.wangzhl.com/posts/2019/why-condition-variable-requires-mutex/</guid><pubDate>Thu, 12 Dec 2019 14:38:41 GMT</pubDate></item><item><title>单个进程内最多可以有多少个线程</title><link>https://blog.wangzhl.com/posts/2019/max-number-of-threads-per-process/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div&gt;&lt;p&gt;
在开发一个服务程序时，使用的是单个进程中多线程的模式，要为每个连接的设备分配一个线程。随着设备越来越多，分配的线程数量就不断上升，当线程数量达到一定值时程序就报错退出了。于是问题就来了，单个进程到底可以有多少个线程呢？&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://blog.wangzhl.com/posts/2019/max-number-of-threads-per-process/"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>linux</category><category>process</category><category>thread</category><category>windows</category><guid>https://blog.wangzhl.com/posts/2019/max-number-of-threads-per-process/</guid><pubDate>Fri, 06 Dec 2019 12:44:50 GMT</pubDate></item><item><title>线程API总结</title><link>https://blog.wangzhl.com/posts/2019/thread-api-cheatsheet/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div&gt;&lt;p&gt;
线程的使用在软件开发中是十分普遍的，本文总结了两种常用的线程API接口：POSIX线程和CPP11线程。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://blog.wangzhl.com/posts/2019/thread-api-cheatsheet/"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>cpp</category><category>cpp11</category><category>linux</category><category>posix</category><category>thread</category><guid>https://blog.wangzhl.com/posts/2019/thread-api-cheatsheet/</guid><pubDate>Mon, 14 Jan 2019 02:50:31 GMT</pubDate></item><item><title>线程与进程的比较</title><link>https://blog.wangzhl.com/posts/2018/compares-between-thread-and-process/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div id="outline-container-orgb85b713" class="outline-2"&gt;
&lt;h2 id="orgb85b713"&gt;进程与线程之间有什么区别&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgb85b713"&gt;
&lt;p&gt;
进程（process）是指在系统中正在运行的一个应用程序，是系统资源分配的基本单位，在内存中有其完备的数据空间和代码空间，拥有完整的虚拟空间地址。一个进程所拥有的数据和变量只属于它自己。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
线程（thread）是进程内相对独立的可执行单元，所以也被称为轻量进程（lightweight processes）。线程是操作系统进行任务调度的基本单元，它与父进程的其它线程共享该进程所拥有的全部代码空间和全局变量，但拥有独立的堆栈（即局部变量对于线程来说是私有的）。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
进程和线程都具有就绪、阻塞和运行三种基本状态。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org62fc6ac" class="outline-3"&gt;
&lt;h3 id="org62fc6ac"&gt;联系&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org62fc6ac"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;一个进程至少拥有一个线程(主线程)，也可以拥有多个线程&lt;br&gt;&lt;/li&gt;
&lt;li&gt;一个线程必须有一个父进程，多个进程可以并发执行&lt;br&gt;&lt;/li&gt;
&lt;li&gt;一个线程可以创建和撤销另一个线程&lt;br&gt;&lt;/li&gt;
&lt;li&gt;同一个进程中的多个线程之间可以并发执行&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org4bffd32" class="outline-3"&gt;
&lt;h3 id="org4bffd32"&gt;区别&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org4bffd32"&gt;
&lt;p&gt;
系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销&lt;br&gt;
资源管理：进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb0a3dcb" class="outline-3"&gt;
&lt;h3 id="orgb0a3dcb"&gt;通信方式&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgb0a3dcb"&gt;
&lt;p&gt;
进程间通信主要包括管道、系统IPC(包括消息队列，信号量，共享存储)、SOCKET，具体说明参考linux进程间通信方式。进程间通信其实是指分属于不同进程的线程之间的通讯，所以进程间的通信方法同样适用于线程间的通信。但对于同一进程的不同线程来说，使用全局变量进行通信效率会更高。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-orgddfd699" class="outline-2"&gt;
&lt;h2 id="orgddfd699"&gt;什么情况下适合使用线程&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgddfd699"&gt;
&lt;p&gt;
线程相对于进程的优势：&lt;br&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;线程间通信（数据交互）比进程间通信更加简便快捷。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;线程之间的上下文切换速度要比进程间的快，也就是说，对于操作系统而言，停止一个线程并启动另一个线程的速度比进程之间相似操作更快。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;创建一个线程的速度比创建一个进程的速度快。&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
下面的一些情景更适合使用线程来完成：&lt;br&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;进行耗时较长的处理：当一个windows界面程序正在计算时，它就不能处理其他消息（message）了，界面就不能及时更新。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;进行后台处理：有些任务并不是时间紧迫的，但是需要定期执行。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;进行 &lt;code&gt;I/O&lt;/code&gt; 处理： &lt;code&gt;I/O&lt;/code&gt; 操作或网络操作一般都会有一定的延迟，线程能保证程序中的其他部分不会受到延迟的影响。&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-orgede06cf" class="outline-2"&gt;
&lt;h2 id="orgede06cf"&gt;什么情况下适合使用进程&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgede06cf"&gt;
&lt;p&gt;
进程相对于线程的优势：&lt;br&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;多线程系单进程的软件只能运行在一台机器上，而多进程的软件可以运行在多台机器上。这在一定程度上限制软件的可拓展性，单台机器的性能总是有限的。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;多进程模型的鲁棒性更好，有更好的容错性。运行在同一进程下的多个线程会相互影响，如果其中的一个线程出了问题，可能会波及整个进程。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;有些功能模块并不是线程安全的，这时就只能使用多进程模型了。&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
以chrome浏览器为例，它使用了多进程模型。每一个标签页都是一个进程，这样能够将渲染引擎中的bug隔离在该进程内，从而使整个程序免受影响。多进程模型将JavaScript隔离在每个进程中，这样就能防止其因占用过多的CPU或内存，使整个软件失去响应。另一方面，多进程模型的系统开销也是比较大的，这点能够从chrome的高额内存使用中看出来。不过chrome的优化策略可以让较低内存的情况下有更好内存使用效率。当一个标签页处于非激活状态，其对应的内存可以在需要时被交换进硬盘中，这样用户当前操作的页面就能够保持响应状态。如果使用的是多线程模型，区分活跃内存和非活跃内存就变得十分困难，导致内存使用效率的下降。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org533d734" class="outline-2"&gt;
&lt;h2 id="org533d734"&gt;参考资料&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org533d734"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://www.backblaze.com/blog/whats-the-diff-programs-processes-and-threads/"&gt;backblaze.com - difference between process and thread&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/zh-cn/windows/desktop/ProcThread/about-processes-and-threads"&gt;msdn - about processes and threads&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.csdn.net/xiexievv/article/details/7294189"&gt;csdn - blog&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/617787/why-should-i-use-a-thread-vs-using-a-process"&gt;stackoverflow - why should I use thread vs process&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.chromium.org/2008/09/multi-process-architecture.html"&gt;chromium blog - multi process architecture&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;
（全文完）&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>computer science</category><category>process</category><category>thread</category><guid>https://blog.wangzhl.com/posts/2018/compares-between-thread-and-process/</guid><pubDate>Fri, 14 Sep 2018 01:51:15 GMT</pubDate></item></channel></rss>