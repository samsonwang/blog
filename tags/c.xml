<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="/assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Hack Note (Posts about c)</title><link>https://blog.wangzhl.com/</link><description></description><atom:link href="https://blog.wangzhl.com/tags/c.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2017-2023 &lt;a href="mailto:wangzhilv@gmail.com"&gt;Samson Wang&lt;/a&gt; 
&lt;a rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/"&gt;
&lt;img alt="cc-by-nc 4.0" style="padding-bottom:2px" src="/images/cc-by-nc.png" /&gt;&lt;/a&gt;
</copyright><lastBuildDate>Fri, 24 Nov 2023 10:03:22 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>检查C字符串为空</title><link>https://blog.wangzhl.com/posts/check-c-string-empty/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div&gt;&lt;p&gt;
在C语言中如何检测字符串为空字符串，最近看到twitter上有对此问题讨论，让我学习到了很多新的知识点。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://blog.wangzhl.com/posts/check-c-string-empty/"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>c</category><category>strlen</category><guid>https://blog.wangzhl.com/posts/check-c-string-empty/</guid><pubDate>Fri, 10 Mar 2023 01:08:51 GMT</pubDate></item><item><title>结构体字节对齐的陷阱</title><link>https://blog.wangzhl.com/posts/cpp-pragma-pack-pitfall/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div&gt;&lt;p&gt;
&lt;code&gt;pragma pack&lt;/code&gt; 的功能是设定结构体内成员变量的字节对齐方式。它在使用时有一个易错点，而且出错后排查起来还非常不容易。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://blog.wangzhl.com/posts/cpp-pragma-pack-pitfall/"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>c</category><category>cpp</category><guid>https://blog.wangzhl.com/posts/cpp-pragma-pack-pitfall/</guid><pubDate>Tue, 16 Nov 2021 03:27:35 GMT</pubDate></item><item><title>在运行时获取动态库的路径</title><link>https://blog.wangzhl.com/posts/get-runtime-dll-path/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div&gt;&lt;p&gt;
最近在开发一个动态库，这个动态库需要在运行时动态地加载另一个动态库。在库发布时会同时提供这两个动态库。库的使用者会主动加载第一个动态库，问题出现在第一个动态库加载第二个动态库时，如何确定第二个动态库的位置。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://blog.wangzhl.com/posts/get-runtime-dll-path/"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>c</category><category>cpp</category><category>linux</category><category>windows</category><guid>https://blog.wangzhl.com/posts/get-runtime-dll-path/</guid><pubDate>Fri, 11 Jun 2021 10:19:06 GMT</pubDate></item><item><title>栈溢出问题和chkstk</title><link>https://blog.wangzhl.com/posts/stackoverflow-and-chkstk/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div&gt;&lt;p&gt;
最近在调试程序时遇到了一个栈溢出的问题，栈溢出通常是由程序错误引起的，通过修正程序的bug就能解决问题。但是这次的栈溢出，从代码上看并没有错误，经过一番排查和调试，我找到了解决问题的方法，同时也加深了对操作系统中一些概念的理解。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://blog.wangzhl.com/posts/stackoverflow-and-chkstk/"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>c</category><category>chkstk</category><category>cpp</category><category>stack overflow</category><category>windows</category><guid>https://blog.wangzhl.com/posts/stackoverflow-and-chkstk/</guid><pubDate>Sun, 10 May 2020 06:08:32 GMT</pubDate></item><item><title>MSVC的stdio版本适配问题</title><link>https://blog.wangzhl.com/posts/msvc-legacy-stdio/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div&gt;&lt;p&gt;
windows系统的向下兼容性一直是做的比较好的，一些老旧软件不需要修改就能跑在最新版的windows上。这篇文章主要讨论的是库（library）的向下兼容性，在开发中某些库可能是由较老的编译器生成的，当使用新版本的编译器进行链接时可能需要对stdio相关库进行适配。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://blog.wangzhl.com/posts/msvc-legacy-stdio/"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>c</category><category>cpp</category><category>msvc</category><category>ucrt</category><category>vcrt</category><category>windows</category><guid>https://blog.wangzhl.com/posts/msvc-legacy-stdio/</guid><pubDate>Sun, 03 May 2020 01:54:38 GMT</pubDate></item><item><title>如何实现一个定时器</title><link>https://blog.wangzhl.com/posts/how-to-implement-a-timer/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div&gt;&lt;p&gt;
在以前的一次面试中，我被问到该如何实现一个定时器，当时我并没有思考过这个问题，所以回答的并不令人满意。在日常的开发中，一个需要定时执行的任务是很常见的。我认为这个问题比较有意义，也非常具有代表性。于是，我查阅了一些资料，并整理出这篇博客。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://blog.wangzhl.com/posts/how-to-implement-a-timer/"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>alarm</category><category>c</category><category>cpp</category><category>linux</category><category>signal</category><category>timer</category><category>timerfd</category><guid>https://blog.wangzhl.com/posts/how-to-implement-a-timer/</guid><pubDate>Sat, 11 Apr 2020 01:10:09 GMT</pubDate></item><item><title>文件操作函数接口的比较</title><link>https://blog.wangzhl.com/posts/fopen-api-compare/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div&gt;&lt;p&gt;
最近在维护一个老项目时发现，该程序的日志在程序运行时是不能够被其他程序打开的，也就不能通过日志实时地观察程序的运行状态。在我的印象里，我一直认为打开的文件都是共享的，这应该是个错觉。本篇日志主要总结了在打开一个文件时所使用函数接口，方便以后查阅。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://blog.wangzhl.com/posts/fopen-api-compare/"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>c</category><category>c11</category><category>cpp</category><category>cpp11</category><category>file</category><category>windows</category><guid>https://blog.wangzhl.com/posts/fopen-api-compare/</guid><pubDate>Thu, 19 Dec 2019 14:08:11 GMT</pubDate></item><item><title>C语言中数组地址的特性</title><link>https://blog.wangzhl.com/posts/c-array-address-tips/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div&gt;&lt;p&gt;
最近在开发中使用到了C风格的数组，在对数组地址进行增减操作时有些疑惑，现在将这些要点总结下来，方便查阅。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://blog.wangzhl.com/posts/c-array-address-tips/"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>array</category><category>c</category><category>cpp</category><guid>https://blog.wangzhl.com/posts/c-array-address-tips/</guid><pubDate>Wed, 30 Oct 2019 08:51:42 GMT</pubDate></item><item><title>位域与联合体的内存布局</title><link>https://blog.wangzhl.com/posts/bit-field-and-union-type/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div&gt;&lt;p&gt;
位域（bit field）与联合体（union）都可以用来控制内存布局。本文主要阐述的内存可总结为：位域的内存布局是编译器决定的，而联合体的内存布局是由大小端决定的。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://blog.wangzhl.com/posts/bit-field-and-union-type/"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>bit field</category><category>c</category><category>cpp</category><category>endian</category><category>memory layout</category><category>union</category><guid>https://blog.wangzhl.com/posts/bit-field-and-union-type/</guid><pubDate>Tue, 21 May 2019 08:35:02 GMT</pubDate></item><item><title>libshmcache源码阅读笔记</title><link>https://blog.wangzhl.com/posts/notes-on-libshmcache/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div id="outline-container-orgb29a7bb" class="outline-2"&gt;
&lt;h2 id="orgb29a7bb"&gt;引言&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgb29a7bb"&gt;
&lt;p&gt;
由于在工作中需要开发一套内存缓存服务，使用了共享内存作为多进程间的数据共享。为了提高共享内存缓存服务的性能，我找了一个类似的较为成熟的开源项目 &lt;a href="https://github.com/happyfish100/libshmcache"&gt;libshmcache&lt;/a&gt; ，通过研究源码学习其中的优点并改进自己的模块。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
libshmcache与redis相似的是都使用内存进行数据缓存；与redis不同的是，redis使用的进程自己申请的动态内存，而libshmcache使用的是共享内存。使用共享内存就意味着libshmcache主要的应用场景是同一台主机上的数据缓存。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
我花了一周时间阅读了比较感兴趣的部分代码，收获不少，现就以下几个方面总结一下自己的心得：&lt;br&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;纯C语言开发的代码风格&lt;br&gt;&lt;/li&gt;
&lt;li&gt;hash table的原理和实现&lt;br&gt;&lt;/li&gt;
&lt;li&gt;gcc原子化操作接口&lt;br&gt;&lt;/li&gt;
&lt;li&gt;有锁写和无锁读的实现细节&lt;br&gt;&lt;/li&gt;
&lt;li&gt;共享内存的两套函数接口(POSIX和SystemV)&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-orgc21cae1" class="outline-2"&gt;
&lt;h2 id="orgc21cae1"&gt;纯C语言开发时的代码风格&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgc21cae1"&gt;
&lt;p&gt;
我在工作中使用比较多的开发语言是C++，对于C语言编写的这样规模的项目，还是第一次仔细深入地研究。C语言使用 &lt;code&gt;struct&lt;/code&gt; 作为大多数自定义数据结构的关键字，相对于C++能够使用成员函数能够对类进行功能拓展，C语言比较常用的是将这个对象作为输入参数传到函数中。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
纵观所有项目代码，我感受比较深的就是使用结构体中嵌套匿名结构体，这样做能够增强数据结构的层次感，示例代码如下：&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;shmcache_context&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;pid_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lock_fd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;//for file lock&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;detect_deadlock_clocks&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;shmcache_config&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;shm_memory_info&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;memory&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;	&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;shmcache_segment_info&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;hashtable&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;	&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;	    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;	    &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;shmcache_segment_info&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;	&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;values&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;segments&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;shmcache_value_allocator_context&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value_allocator&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;shmcache_list&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="c1"&gt;//for value recycle&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;bool&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;create_segment&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;//if check segment size                                  &lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
注意 &lt;code&gt;shmcache_context&lt;/code&gt; 中的匿名结构体 &lt;code&gt;segments&lt;/code&gt; 和 &lt;code&gt;values&lt;/code&gt; ，这样的写法体现了相互包含关系，也使后续的操作该数据结构的语句更加容易理解。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
另外对于联合体和位域这两种技术也是我在之前开发中使用比较少的，通过阅读源码能够让我对其有了更深刻的理解。示例代码如下：&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;union&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;shm_hentry_offset&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int64_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;offset&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;	&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;	&lt;/span&gt;&lt;span class="kt"&gt;int64_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;offset&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;48&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;segment&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
这段代码使用了联合体赋予了 &lt;code&gt;shm_hentry_offset&lt;/code&gt; 两种访问方式，又使用了位域将 &lt;code&gt;int64_t&lt;/code&gt; 分割为两段。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-orgc2befd7" class="outline-2"&gt;
&lt;h2 id="orgc2befd7"&gt;hash table的原理和实现&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgc2befd7"&gt;
&lt;p&gt;
libshmcache内部使用的是hash table做内部缓存的数据结构，这使查找的时间复杂度是O(1)。&lt;br&gt;
之前看过一些介绍hash table的资料，对hash table的工作原理是有过一个基础的了解的，这次通过阅读源码，能够了解到hash table在代码实现上更加细节的内容。&lt;br&gt;
对于hash计算中出现的hash值冲突，即在hash计算时出现了两个不同的key在经过hash计算后得到的bucket相同，libshmcache采用的解决方案是使用linked list来存放这些相同bucket对应的value。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org2b606e9" class="outline-2"&gt;
&lt;h2 id="org2b606e9"&gt;gcc原子化操作接口&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org2b606e9"&gt;
&lt;p&gt;
使用原子化操作接口能够解决一些并发读写问题，原子化操作相对于互斥锁执行更快。原子化操作也是一种无锁编程的方式。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-orgc34d395" class="outline-2"&gt;
&lt;h2 id="orgc34d395"&gt;有锁写和无锁读的实现&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgc34d395"&gt;
&lt;p&gt;
在libshmcache中，写操作通过 &lt;code&gt;pthread_mutex_t&lt;/code&gt; 进行同步，而读操作是无锁的。&lt;br&gt;
对于写操作来说，需要对hash table进行操作，这肯定是需要同步的。&lt;br&gt;
将 &lt;code&gt;pthread_mutex_t&lt;/code&gt; 保存在共享内存中，不同的进程通过映射共享内存就能获得同一个互斥量，通过这个互斥量就能完成进程间同步。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org87c47c7" class="outline-2"&gt;
&lt;h2 id="org87c47c7"&gt;共享内存的两套函数接口(POSIX和SystemV)&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org87c47c7"&gt;
&lt;p&gt;
在linux上使用共享内存时有两套接口 &lt;code&gt;mmap&lt;/code&gt; 和 &lt;code&gt;shmget&lt;/code&gt; 。 &lt;code&gt;mmap&lt;/code&gt; 是 &lt;code&gt;POSIX&lt;/code&gt; 标准的接口，而 &lt;code&gt;shmget&lt;/code&gt; 是 &lt;code&gt;System V&lt;/code&gt; 标准的接口，两者都能够实现进程间共享内存，但他们在使用上还是有些区别的。对于 &lt;code&gt;mmap&lt;/code&gt; 来说，需要在硬盘上创建一个文件，再将该文件映射到内存中。对于 &lt;code&gt;shmget&lt;/code&gt; 来说，需要指定一个key，不同的进程通过相同的key就能映射到同一片内存。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>c</category><category>memcached</category><category>redis</category><guid>https://blog.wangzhl.com/posts/notes-on-libshmcache/</guid><pubDate>Mon, 23 Jul 2018 02:51:59 GMT</pubDate></item></channel></rss>