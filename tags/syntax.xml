<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="/assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Hack Note (Posts about syntax)</title><link>https://samsonwang.me/</link><description></description><atom:link href="https://samsonwang.me/tags/syntax.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2017-2019 &lt;a href="mailto:wangzhilv@gmail.com"&gt;Samson Wang&lt;/a&gt; 
&lt;a rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/"&gt;&lt;img alt="知识共享许可协议" style="padding-bottom:2px" src="https://i.creativecommons.org/l/by-nc/4.0/80x15.png" /&gt;&lt;/a&gt;
</copyright><lastBuildDate>Thu, 28 Mar 2019 04:48:38 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>静态成员变量初始化相关问题</title><link>https://samsonwang.me/posts/static-member-initialization-and-private-member-function/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div id="outline-container-org119ff0b" class="outline-2"&gt;
&lt;h2 id="org119ff0b"&gt;引言&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org119ff0b"&gt;
&lt;p&gt;
这篇文章的起因是出于对于 &lt;code&gt;C++&lt;/code&gt; 饿汉单例模式代码的一些疑问，查阅了一些资料。在仔细研究后，我发现在一些基础概念的理解还是存在偏差。&lt;br&gt;
下面请看这样的一段代码，能看出其中有那些不太“正常”的语句么。&lt;br&gt;
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Singleton&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;Singleton&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;getInstance&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;Singleton&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;Singleton&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;instance&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="n"&gt;Singleton&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;Singleton&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;instance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Singleton&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;Singleton&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;Singleton&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;getInstance&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;instance&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org5b4db2e" class="outline-2"&gt;
&lt;h2 id="org5b4db2e"&gt;私有静态成员的初始化&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org5b4db2e"&gt;
&lt;p&gt;
上面的代码是饿汉单例模式的 &lt;code&gt;C++&lt;/code&gt; 的实现，在没有查阅资料之前，我对其中私有静态成员变量的初始化存疑。主要有以下两点：&lt;br&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;为什么私有变量能够在类外被修改&lt;br&gt;&lt;/li&gt;
&lt;li&gt;为什么私有构造函数能够在类外被调用&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
在我之前的知识积累中， &lt;b&gt;私有的成员变量或成员函数是不能够在类外被访问的&lt;/b&gt; 。那么为什么以上代码没有问题呢？&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
在C++标准中找到了下面的一段话(可以在 &lt;a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3690.pdf"&gt;C++11 standard&lt;/a&gt; 的 9.4.2节 或  &lt;a href="http://eel.is/c++draft/class.static.data#2"&gt;C++ standard working draft&lt;/a&gt; 的 10.3.9.2节 中找到)&lt;br&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
The initializer expression in the definition of a static data member is in the scope of its class.&lt;br&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
这句话的意思是：静态成员变量的初始化是被看做为它自身的类域中的（ &lt;del&gt;翻译的可能不是很准&lt;/del&gt; ）。这样就不难理解为什么私有的静态成员变量能够在其类外被初始化了，由其私有构造函数进行构造也能说的通了。&lt;br&gt;
&lt;/p&gt;


&lt;p&gt;
&lt;b&gt;同样&lt;/b&gt; ,在C++标准中给出了下面这样的示例代码：&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;process&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;run_chain&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;running&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="n"&gt;process&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;running&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;get_main&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;process&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;run_chain&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;running&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
给出的说明如下：&lt;br&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
The static data member &lt;code&gt;run_chain&lt;/code&gt; of class process is defined in global scope; the notation &lt;code&gt;process​::​run_chain&lt;/code&gt; specifies that the member &lt;code&gt;run_chain&lt;/code&gt; is a member of class &lt;code&gt;process&lt;/code&gt; and in the scope of class &lt;code&gt;process&lt;/code&gt;. In the static data member definition, the initializer expression refers to the static data member running of class &lt;code&gt;process&lt;/code&gt;.&lt;br&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
静态成员 &lt;code&gt;run_chain&lt;/code&gt; 定义在全局域；而 &lt;code&gt;process::run_chain&lt;/code&gt; 则表示 &lt;code&gt;run_chain&lt;/code&gt; 是 &lt;code&gt;process&lt;/code&gt; 类的成员变量，从而处在 &lt;code&gt;process&lt;/code&gt; 类的作用域中。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org3f521d3" class="outline-2"&gt;
&lt;h2 id="org3f521d3"&gt;私有构造函数&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org3f521d3"&gt;
&lt;p&gt;
在查阅资料时，我发现 Peter 的 &lt;a href="https://stackoverflow.com/a/41361967"&gt;描述&lt;/a&gt; 纠正了我对私有构造函数的一些看法。&lt;br&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
The point of a &lt;code&gt;private&lt;/code&gt; constructor is not preventing object construction. It is about controlling which code can access the constructor, and therefore limiting which code to create an object that is an instance of that class. A &lt;code&gt;private&lt;/code&gt; constructor is accessible to all member functions ( &lt;code&gt;static&lt;/code&gt; or otherwise) of the class, and to all declared &lt;code&gt;friend&lt;/code&gt; s of the class (which may be individual functions, or other classes) - so any of those can create an instance of the class using a &lt;code&gt;private&lt;/code&gt; constructor (assuming the constructor is defined).&lt;br&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
私有构造函数的目的并不是禁止对象构造，其目的在于控制哪些代码能够调用这个构造函数，进而限制类对象的创建。私有的构造函数可以被该类的所有成员函数（静态或非静态的）调用，该类的友元类或友元方法也能访问该类的私有函数，所以在上述情况中都可以通过私有的构造函数实例化出类对象。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb5379f3" class="outline-2"&gt;
&lt;h2 id="orgb5379f3"&gt;参考资料&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgb5379f3"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3690.pdf"&gt;ISO C++11 standard&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://eel.is/c++draft/class.static.data#2"&gt;ISO C++ standard working draft&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/38583989/access-to-private-static-function-during-static-member-initialization"&gt;stackoverflow.com - access to private static function…&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/41361223/why-private-constructor-prevents-object-creation-c"&gt;stackoverflow.com - private constructor&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/7857989/static-member-variable-when-declared-private"&gt;stackoverflow.com - static member variable when declared private&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.cppreference.com/w/cpp/language/static#Static_data_members"&gt;cppreference.com - static data members&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>cpp</category><category>syntax</category><guid>https://samsonwang.me/posts/static-member-initialization-and-private-member-function/</guid><pubDate>Tue, 04 Sep 2018 15:37:37 GMT</pubDate></item><item><title>STL容器的迭代器失效问题</title><link>https://samsonwang.me/posts/stl-iterator-invalidate/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div id="outline-container-org2202887" class="outline-2"&gt;
&lt;h2 id="org2202887"&gt;1 引言&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org2202887"&gt;
&lt;p&gt;
常见的STL容器都能使用迭代器访问容器内元素，迭代器相同于一个指向容器内元素的指针，可以通过移动迭代器实现遍历容器。&lt;br&gt;
但是在使用迭代器时需要考虑STL容器的失效问题；迭代器失效主要出现在对容器进行了增删操作之后，迭代器不再指向原本的元素。&lt;br&gt;
这时如果再通过迭代器访问容器就有可能出现异常。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org5533a43" class="outline-2"&gt;
&lt;h2 id="org5533a43"&gt;2 map容器&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org5533a43"&gt;
&lt;p&gt;
&lt;b&gt;内部数据结构&lt;/b&gt; ：红黑树&lt;br&gt;
&lt;b&gt;插入操作&lt;/b&gt; ：插入操作会申请新的节点空间，然后加入都红黑树中，原来的迭代器指向的内存空间都未改变，故不会出现迭代器失效。&lt;br&gt;
&lt;b&gt;删除操作&lt;/b&gt; ：删除操作只会引起被删除节点的迭代器失效。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgff31316" class="outline-2"&gt;
&lt;h2 id="orgff31316"&gt;3 vector容器&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgff31316"&gt;
&lt;p&gt;
&lt;b&gt;内部数据结构&lt;/b&gt; ：数组(一段连续内存空间)&lt;br&gt;
&lt;b&gt;插入操作&lt;/b&gt; ：由于vector使用的是一段有长度限制的连续空间，插入( &lt;code&gt;push_back&lt;/code&gt; / &lt;code&gt;insert&lt;/code&gt; )操作在vector中加入新的元素时需要分情况考虑。&lt;br&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;当vector中元素总数仍不大于capacity，这时插入位置后的元素都被依次移动到下一个位置，所以插入位置之后的迭代器都会失效。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;当vector中元素总数大于capacity，这个时候会重新开辟更大的内存空间，将原来的vector中的内容复制到新的vector中，回收原先vector的内存空间。由于新的vector的地址已完全改变，所以原先的所有迭代器都会失效。&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
&lt;b&gt;删除操作&lt;/b&gt; ：删除( &lt;code&gt;pop_back&lt;/code&gt; / &lt;code&gt;erase&lt;/code&gt; )操作在vector中删除元素，删除位置后的元素都被依次复制到前一个位置，所以删除位置之后的迭代器都会失效。&lt;br&gt;
示例代码：&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org86880ff" class="outline-2"&gt;
&lt;h2 id="org86880ff"&gt;4 list容器&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org86880ff"&gt;
&lt;p&gt;
&lt;b&gt;内部数据结构&lt;/b&gt; ：双向环状链表&lt;br&gt;
&lt;b&gt;插入操作&lt;/b&gt; ：插入操作会申请新的节点空间，然后加入到链表中，原来的迭代器指向的内存空间都未改变，故不会出现迭代器失效。&lt;br&gt;
&lt;b&gt;删除操作&lt;/b&gt; ：删除操作只会引起被删除节点的迭代器失效。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb547aef" class="outline-2"&gt;
&lt;h2 id="orgb547aef"&gt;5 小结&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgb547aef"&gt;
&lt;p&gt;
在操作STL容器时，对容器增删（ &lt;code&gt;erase&lt;/code&gt; / &lt;code&gt;insert&lt;/code&gt; ）之后应该注意接收返回值，这样可以有效避免迭代器失效的产生。&lt;br&gt;
对容器进行遍历删除操作时，另一种语法技巧是在 &lt;code&gt;erase&lt;/code&gt; 接口中对迭代器进行后自增（it++），这种写法也能够保证遍历正常进行。理解这种写法需要参考运算符重载的相关知识，后自增操作会产生一个临时变量用于函数返回。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>cpp</category><category>STL</category><category>syntax</category><guid>https://samsonwang.me/posts/stl-iterator-invalidate/</guid><pubDate>Wed, 10 Jan 2018 14:06:04 GMT</pubDate></item><item><title>关于size_t和size_type的比较</title><link>https://samsonwang.me/posts/size_t-and-size_type/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div id="outline-container-orgc77f87e" class="outline-2"&gt;
&lt;h2 id="orgc77f87e"&gt;1 引言&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgc77f87e"&gt;
&lt;p&gt;
编程中常见的表示两种大小的类型标识符有 &lt;code&gt;size_t&lt;/code&gt; 和 &lt;code&gt;size_type&lt;/code&gt; ，这两种类型十分相似，非常容易混淆。本文对他们的使用场景进行了比较，并提供了示例代码。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org306d614" class="outline-2"&gt;
&lt;h2 id="org306d614"&gt;2 &lt;code&gt;size_t&lt;/code&gt; 类型&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org306d614"&gt;
&lt;p&gt;
当需要描述某个对象的大小（size）时都应该使用 &lt;code&gt;size_t&lt;/code&gt; ，其大小被限制为 0 到 &lt;code&gt;SIZE_MAX&lt;/code&gt; 之间。&lt;br&gt;
&lt;code&gt;size_t&lt;/code&gt; 的定义在 &lt;code&gt;&amp;lt;cstddef&amp;gt;&lt;/code&gt; 中， &lt;code&gt;SIZE_MAX&lt;/code&gt; 的定义在 &lt;code&gt;&amp;lt;climits&amp;gt;&lt;/code&gt; 中。&lt;br&gt;
&lt;code&gt;size_t&lt;/code&gt; 一般会作为 &lt;code&gt;sizeof&lt;/code&gt; 运算符的返回结果，可以理解为在给定的平台中是统一的。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org0f49f04" class="outline-2"&gt;
&lt;h2 id="org0f49f04"&gt;3 &lt;code&gt;size_type&lt;/code&gt; 类型&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org0f49f04"&gt;
&lt;p&gt;
在 &lt;code&gt;STL&lt;/code&gt; 中定义了 &lt;code&gt;size_type&lt;/code&gt; 是与 &lt;code&gt;Allocator::size_tpye&lt;/code&gt; 相对应的。而 &lt;code&gt;Allocator&lt;/code&gt; 是模板的一个参数。&lt;br&gt;
&lt;code&gt;size_type&lt;/code&gt; 可以理解为在给定容器范围内是统一的。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgcf04738" class="outline-2"&gt;
&lt;h2 id="orgcf04738"&gt;4 二者之间的比较&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgcf04738"&gt;
&lt;p&gt;
这两种类型主要是为了提高代码的可移植性。一般情况来说，这两种类型是没有区别的，因为使用标准库默认的 &lt;code&gt;Allocator&lt;/code&gt; 所对应的 &lt;code&gt;size_type&lt;/code&gt; 就是 &lt;code&gt;size_t&lt;/code&gt; 。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-orgdaaba0b" class="outline-2"&gt;
&lt;h2 id="orgdaaba0b"&gt;5 示例代码&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgdaaba0b"&gt;
&lt;p&gt;
注意 &lt;code&gt;size_type&lt;/code&gt; 在使用时需要加上容器类型限定。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;n1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;size_type&lt;/span&gt; &lt;span class="n"&gt;n2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;size_type&lt;/span&gt; &lt;span class="n"&gt;n3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org6609dd4" class="outline-2"&gt;
&lt;h2 id="org6609dd4"&gt;6 参考资料&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org6609dd4"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="http://en.cppreference.com/w/cpp/types/size_t"&gt;http://en.cppreference.com/w/cpp/types/size_t&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/918567/size-t-vs-containersize-type"&gt;https://stackoverflow.com/questions/918567/size-t-vs-containersize-type&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>cpp</category><category>syntax</category><guid>https://samsonwang.me/posts/size_t-and-size_type/</guid><pubDate>Mon, 08 Jan 2018 09:27:13 GMT</pubDate></item></channel></rss>