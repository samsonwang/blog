<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="/assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Hack Note (Posts about computer science)</title><link>https://samsonwang.me/</link><description></description><atom:link href="https://samsonwang.me/tags/computer-science.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2017-2019 &lt;a href="mailto:wangzhilv@gmail.com"&gt;Samson Wang&lt;/a&gt; 
&lt;a rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/"&gt;&lt;img alt="知识共享许可协议" style="padding-bottom:2px" src="https://i.creativecommons.org/l/by-nc/4.0/80x15.png" /&gt;&lt;/a&gt;
</copyright><lastBuildDate>Mon, 28 Jan 2019 15:18:23 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>线程与进程的比较</title><link>https://samsonwang.me/posts/compares-between-thread-and-process/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div id="outline-container-org6c3978c" class="outline-2"&gt;
&lt;h2 id="org6c3978c"&gt;进程与线程之间有什么区别&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org6c3978c"&gt;
&lt;p&gt;
进程（process）是指在系统中正在运行的一个应用程序，是系统资源分配的基本单位，在内存中有其完备的数据空间和代码空间，拥有完整的虚拟空间地址。一个进程所拥有的数据和变量只属于它自己。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
线程（thread）是进程内相对独立的可执行单元，所以也被称为轻量进程（lightweight processes）。线程是操作系统进行任务调度的基本单元，它与父进程的其它线程共享该进程所拥有的全部代码空间和全局变量，但拥有独立的堆栈（即局部变量对于线程来说是私有的）。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
进程和线程都具有就绪、阻塞和运行三种基本状态。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb9d27f0" class="outline-3"&gt;
&lt;h3 id="orgb9d27f0"&gt;联系&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgb9d27f0"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;一个进程至少拥有一个线程(主线程)，也可以拥有多个线程&lt;br&gt;&lt;/li&gt;
&lt;li&gt;一个线程必须有一个父进程，多个进程可以并发执行&lt;br&gt;&lt;/li&gt;
&lt;li&gt;一个线程可以创建和撤销另一个线程&lt;br&gt;&lt;/li&gt;
&lt;li&gt;同一个进程中的多个线程之间可以并发执行&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org45d93d7" class="outline-3"&gt;
&lt;h3 id="org45d93d7"&gt;区别&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org45d93d7"&gt;
&lt;p&gt;
系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销&lt;br&gt;
资源管理：进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orga4687a8" class="outline-3"&gt;
&lt;h3 id="orga4687a8"&gt;通信方式&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orga4687a8"&gt;
&lt;p&gt;
进程间通信主要包括管道、系统IPC(包括消息队列，信号量，共享存储)、SOCKET，具体说明参考linux进程间通信方式。进程间通信其实是指分属于不同进程的线程之间的通讯，所以进程间的通信方法同样适用于线程间的通信。但对于同一进程的不同线程来说，使用全局变量进行通信效率会更高。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-orgf10434b" class="outline-2"&gt;
&lt;h2 id="orgf10434b"&gt;什么情况下适合使用线程&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgf10434b"&gt;
&lt;p&gt;
线程相对于进程的优势：&lt;br&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;线程间通信（数据交互）比进程间通信更加简便快捷。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;线程之间的上下文切换速度要比进程间的快，也就是说，对于操作系统而言，停止一个线程并启动另一个线程的速度比进程之间相似操作更快。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;创建一个线程的速度比创建一个进程的速度快。&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
下面的一些情景更适合使用线程来完成：&lt;br&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;进行耗时较长的处理：当一个windows界面程序正在计算时，它就不能处理其他消息（message）了，界面就不能及时更新。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;进行后台处理：有些任务并不是时间紧迫的，但是需要定期执行。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;进行 &lt;code&gt;I/O&lt;/code&gt; 处理： &lt;code&gt;I/O&lt;/code&gt; 操作或网络操作一般都会有一定的延迟，线程能保证程序中的其他部分不会受到延迟的影响。&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org9e8cf3b" class="outline-2"&gt;
&lt;h2 id="org9e8cf3b"&gt;什么情况下适合使用进程&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org9e8cf3b"&gt;
&lt;p&gt;
进程相对于线程的优势：&lt;br&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;多线程系单进程的软件只能运行在一台机器上，而多进程的软件可以运行在多台机器上。这在一定程度上限制软件的可拓展性，单台机器的性能总是有限的。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;多进程模型的鲁棒性更好，有更好的容错性。运行在同一进程下的多个线程会相互影响，如果其中的一个线程出了问题，可能会波及整个进程。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;有些功能模块并不是线程安全的，这时就只能使用多进程模型了。&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
以chrome浏览器为例，它使用了多进程模型。每一个标签页都是一个进程，这样能够将渲染引擎中的bug隔离在该进程内，从而使整个程序免受影响。多进程模型将JavaScript隔离在每个进程中，这样就能防止其因占用过多的CPU或内存，使整个软件失去响应。另一方面，多进程模型的系统开销也是比较大的，这点能够从chrome的高额内存使用中看出来。不过chrome的优化策略可以让较低内存的情况下有更好内存使用效率。当一个标签页处于非激活状态，其对应的内存可以在需要时被交换进硬盘中，这样用户当前操作的页面就能够保持响应状态。如果使用的是多线程模型，区分活跃内存和非活跃内存就变得十分困难，导致内存使用效率的下降。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org3c096b0" class="outline-2"&gt;
&lt;h2 id="org3c096b0"&gt;参考资料&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org3c096b0"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://www.backblaze.com/blog/whats-the-diff-programs-processes-and-threads/"&gt;backblaze.com - difference between process and thread&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/zh-cn/windows/desktop/ProcThread/about-processes-and-threads"&gt;msdn - about processes and threads&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.csdn.net/xiexievv/article/details/7294189"&gt;csdn - blog&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/617787/why-should-i-use-a-thread-vs-using-a-process"&gt;stackoverflow - why should I use thread vs process&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.chromium.org/2008/09/multi-process-architecture.html"&gt;chromium blog - multi process architecture&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;
（全文完）&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>computer science</category><category>process</category><category>thread</category><guid>https://samsonwang.me/posts/compares-between-thread-and-process/</guid><pubDate>Fri, 14 Sep 2018 01:51:15 GMT</pubDate></item><item><title>同步和异步、阻塞和非阻塞</title><link>https://samsonwang.me/posts/asynchronous-synchronous-and-blocking-unblocking/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div id="outline-container-org0205830" class="outline-2"&gt;
&lt;h2 id="org0205830"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; 同步和异步&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
同步和异步指的是在进行I/O操作完成之前，是否允许其他处理步骤继续执行。&lt;br&gt;
计算机中的I/O操作相对于数据处理操作时十分耗时的。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
一个简单的I/O操作方式就是启动连接并等待操作完成，但是这样的操作（同步阻塞I/O）在通信过程中会阻塞进程的处理进度。&lt;br&gt;
相应的，可以在启动通信的同时进行其他的处理，并不需要等待I/O操作的完成，这样的操作就被称作是异步I/O。那些依赖于I/O操作执行完成的任务会阻塞等待I/O操作的完成，其他不依赖与I/O操作的任务能够继续执行。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
同步模型常用的函数接口： &lt;code&gt;read&lt;/code&gt; , &lt;code&gt;write&lt;/code&gt; , &lt;code&gt;send&lt;/code&gt; , &lt;code&gt;recv&lt;/code&gt;&lt;br&gt;
异步模型常用的函数接口： &lt;code&gt;aio_write&lt;/code&gt; , &lt;code&gt;aio_read&lt;/code&gt;&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org19164e3" class="outline-3"&gt;
&lt;h3 id="org19164e3"&gt;&lt;span class="section-number-3"&gt;1.1&lt;/span&gt; POSIX AIO&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-1"&gt;
&lt;p&gt;
在头文件 &lt;code&gt;aio.h&lt;/code&gt; 中定义，链接时使用 &lt;code&gt;-lrt&lt;/code&gt;&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;函数接口&lt;/b&gt;&lt;br&gt;
异步写操作&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;aio_read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;aiocb&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;aiocbp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
异步读操作&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;aio_write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;aiocb&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;aiocbp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
获取异步操作结果&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;aio_return&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;aiocb&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;aiocbp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
获取异步操作中的错误&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;aio_error&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;aiocb&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;aiocbp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
示例代码： &lt;a href="https://gist.github.com/rsms/771059"&gt;github gist&lt;/a&gt;&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb3b8864" class="outline-3"&gt;
&lt;h3 id="orgb3b8864"&gt;&lt;span class="section-number-3"&gt;1.2&lt;/span&gt; Linux AIO&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-2"&gt;
&lt;p&gt;
在头文件 &lt;code&gt;libaio.h&lt;/code&gt; 中定义，链接时使用 &lt;code&gt;-laio&lt;/code&gt;&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;函数接口&lt;/b&gt;&lt;br&gt;
需要注意的是aio的函数接口需要借助 &lt;code&gt;syscall&lt;/code&gt; 进行调用。&lt;br&gt;
创建aio context对象&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;io_setup&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="n"&gt;nr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;aio_context_t&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;ctxp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
销毁aio context对象&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;io_destroy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;aio_context_t&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
提交异步操作&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;io_submit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;aio_context_t&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;nr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;iocb&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="n"&gt;iocbpp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
获取异步操作结果&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;io_getevents&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;aio_context_t&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;min_nr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;max_nr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
		 &lt;span class="n"&gt;io_event&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;events&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;timespec&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;timeout&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
示例代码:&lt;br&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://gist.github.com/larytet/87f90b08643ac3de934df2cadff4989c"&gt;github gist&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.xmailserver.org/eventfd-aio-test.c"&gt;xmailserver.org&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgd4e19db" class="outline-3"&gt;
&lt;h3 id="orgd4e19db"&gt;&lt;span class="section-number-3"&gt;1.3&lt;/span&gt; POSIX AIO与Linux AIO的区别&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-3"&gt;
&lt;p&gt;
摘自 &lt;a href="https://stackoverflow.com/questions/8768083/difference-between-posix-aio-and-libaio-on-linux"&gt;stackoverflow.com&lt;/a&gt;&lt;br&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
On linux, the two AIO implementations are fundamentally different.&lt;br&gt;
The POSIX AIO is a user-level implementation that performs normal blocking I/O in multiple threads, hence giving the illusion that the I/Os are asynchronous. The main reason to do this is that:&lt;br&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;it works with any filesystem&lt;br&gt;&lt;/li&gt;
&lt;li&gt;it works (essentially) on any operating system (keep in mind that gnu's libc is portable)&lt;br&gt;&lt;/li&gt;
&lt;li&gt;it works on files with buffering enabled (i.e. no O&lt;sub&gt;DIRECT&lt;/sub&gt; flag set)&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
The main drawback is that your queue depth (i.e. the number of outstanding operations you can have in practice) is limited by the number of threads you choose to have, which also means that a slow operation on one disk may block an operation going to a different disk. It also affects which I/Os (or how many) is seen by the kernel and the disk scheduler as well.&lt;br&gt;
The kernel AIO (i.e. io&lt;sub&gt;submit&lt;/sub&gt;() et.al.) is kernel support for asynchronous I/O operations, where the io requests are actually queued up in the kernel, sorted by whatever disk scheduler you have, presumably some of them are forwarded (in somewhat optimal order one would hope) to the actual disk as asynchronous operations (using TCQ or NCQ). The main restriction with this approach is that not all filesystems work that well or at all with async I/O (and may fall back to blocking semantics), files have to be opened with O&lt;sub&gt;DIRECT&lt;/sub&gt; which comes with a whole lot of other restrictions on the I/O requests. If you fail to open your files with O&lt;sub&gt;DIRECT&lt;/sub&gt;, it may still "work", as in you get the right data back, but it probably isn't done asynchronously, but is falling back to blocking semantics.&lt;br&gt;
Also keep in mind that io&lt;sub&gt;submit&lt;/sub&gt;() can actually block on the disk under certain circumstances.&lt;br&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
在Linux上两种AIO是完全不同的；&lt;br&gt;
POSIX AIO实现在用户层，实际上进行的操作是普通的多线程阻塞操作，表现为I/O操作是异步的，这种AIO的优点是兼容性和可移植性好，缺点是操作队列长度受限于最大线程数量。&lt;br&gt;
Linux AIO是内核提供的AIO函数接口，I/O操作请求的队列在内核中维护，这种AIO的缺点是并不支持所有的文件系统，Linux AIO在某些情况下的磁盘操作是会阻塞的。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org112a583" class="outline-2"&gt;
&lt;h2 id="org112a583"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; 阻塞和非阻塞&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
阻塞与非阻塞的概念针对的是函数是否会立即返回。&lt;br&gt;
非阻塞模型常与IO复用技术组合使用。&lt;br&gt;
可以通过函数将IO设备设置为非阻塞模式。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org566cda9" class="outline-2"&gt;
&lt;h2 id="org566cda9"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; 如何理解阻塞非阻塞与同步异步的区别&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
在处理 IO 的时候，阻塞和非阻塞都是同步 IO。&lt;br&gt;
只有使用了特殊的 API 才是异步 IO。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org3fed284" class="outline-2"&gt;
&lt;h2 id="org3fed284"&gt;&lt;span class="section-number-2"&gt;4&lt;/span&gt; 参考资料&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://blog.csdn.net/hguisu/article/details/38638183"&gt;csdn.net&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/littledan/linux-aio%20repo"&gt;github.com linux-aio&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.ibm.com/developerworks/linux/library/l-async/index.html"&gt;ibm developerworks&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>computer science</category><guid>https://samsonwang.me/posts/asynchronous-synchronous-and-blocking-unblocking/</guid><pubDate>Tue, 26 Jun 2018 01:27:06 GMT</pubDate></item><item><title>字节序与union类型</title><link>https://samsonwang.me/posts/endianness-and-union-type/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div id="outline-container-orgc61f3c7" class="outline-2"&gt;
&lt;h2 id="orgc61f3c7"&gt;字节序&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgc61f3c7"&gt;
&lt;p&gt;
字节序是指在数据传输时，高位字节存储在内存中的较高位地址还是较低位地址。&lt;br&gt;
字节序分为大端字节序和小端字节序，两种字节序不能混用。&lt;br&gt;
&lt;b&gt;大端字节序&lt;/b&gt; ：高位字节保存在较低位地址的内存中&lt;br&gt;
&lt;b&gt;小端字节序&lt;/b&gt; ：高位字节保存在较高位地址的内存中&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
以 &lt;code&gt;int n = 0x12345678&lt;/code&gt; 为例，大端字节序内存中的存储的顺序为 &lt;code&gt;0x12 0x34 0x56 0x78&lt;/code&gt; ，小端字节序内存中的存储顺序为 &lt;code&gt;0x78 0x56 0x34 0x12&lt;/code&gt; 。很明显可以看出大端字节序更符合人类的阅读习惯。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
常见的大端系统CPU：IBM z/Atchitecture&lt;br&gt;
常见的小端系统CPU：intel x86&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
网络字节序使用的大端字节序，常用网络协议如IPv4、IPv6、TCP和UDP协议都是使用大端字节序完成数据传输的。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;



&lt;div id="outline-container-org6700374" class="outline-2"&gt;
&lt;h2 id="org6700374"&gt;查看当前系统的字节序&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org6700374"&gt;
&lt;p&gt;
通过 &lt;code&gt;lscpu&lt;/code&gt; 命令，能得到cpu的大端和小端信息。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;lscpu &lt;span class="p"&gt;|&lt;/span&gt; grep -i endian
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
通过常用shell命令，在大端系统中会输出0，在小端系统中会输出1。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; -n I &lt;span class="p"&gt;|&lt;/span&gt; od -to2 &lt;span class="p"&gt;|&lt;/span&gt; head -n1 &lt;span class="p"&gt;|&lt;/span&gt; cut -f2 -d&lt;span class="s2"&gt;" "&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; cut -c6
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
借助python进行判断。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;python -c &lt;span class="s2"&gt;"import sys; print(sys.byteorder)"&lt;/span&gt;
&lt;span class="c1"&gt;# or&lt;/span&gt;
python -c &lt;span class="s2"&gt;"import sys;sys.exit(0 if sys.byteorder=='big' else 1)"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
借助linux的ELF进行判断，查看第6个字节，小端系统中为1，大端系统中为2。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;xxd -c &lt;span class="m"&gt;1&lt;/span&gt; -l &lt;span class="m"&gt;6&lt;/span&gt; /bin/bash
&lt;span class="c1"&gt;# or&lt;/span&gt;
hexdump -n &lt;span class="m"&gt;6&lt;/span&gt; -C /bin/bash
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;



&lt;div id="outline-container-org98ab303" class="outline-2"&gt;
&lt;h2 id="org98ab303"&gt;union类型&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org98ab303"&gt;
&lt;p&gt;
可以使用union类型验证字节序，以下示例代码在不同的字节序下会有不同的输出。&lt;br&gt;
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;inttypes.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;union&lt;/span&gt; &lt;span class="n"&gt;un&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int32_t&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;ch&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="n"&gt;un&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;un&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ch&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ch&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ch&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ch&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"u.x=0x%x&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org390267b" class="outline-2"&gt;
&lt;h2 id="org390267b"&gt;参考资料&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org390267b"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Endianness"&gt;wikipedia.com - endianness&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://serverfault.com/questions/163487/how-to-tell-if-a-linux-system-is-big-endian-or-little-endian"&gt;serverfault.com - how to check endian&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format"&gt;wikipedia.com - ELF format&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
（全文完）&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>computer science</category><category>cpp</category><category>endian</category><category>union</category><guid>https://samsonwang.me/posts/endianness-and-union-type/</guid><pubDate>Fri, 11 May 2018 01:55:34 GMT</pubDate></item></channel></rss>