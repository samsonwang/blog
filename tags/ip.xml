<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="/assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Hack Note (Posts about ip)</title><link>https://samsonwang.me/</link><description></description><atom:link href="https://samsonwang.me/tags/ip.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2017-2018 &lt;a href="mailto:wangzhilv@gmail.com"&gt;Samson Wang&lt;/a&gt; 
&lt;a rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/"&gt;&lt;img alt="知识共享许可协议" style="padding-bottom:2px" src="https://i.creativecommons.org/l/by-nc/4.0/80x15.png" /&gt;&lt;/a&gt;
</copyright><lastBuildDate>Tue, 25 Sep 2018 04:38:14 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>IP协议(RFC791)</title><link>https://samsonwang.me/posts/internet-protocol/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;引言&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
本文是IPv4协议的摘要和笔记，IPv4协议由RFC791规定，RFC791协议的原文可以在 &lt;a href="https://tools.ietf.org/html/rfc791"&gt;这里&lt;/a&gt; 找到。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2" class="outline-2"&gt;
&lt;h2 id="sec-2"&gt;协议规格&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;/div&gt;&lt;div id="outline-container-sec-2-1" class="outline-3"&gt;
&lt;h3 id="sec-2-1"&gt;协议头格式&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-1"&gt;
&lt;p&gt;
&lt;img src="https://samsonwang.me/assets/images/spinner.svg" data-src="/images/post-ip-protocol-1.png" alt="header format"&gt;&lt;br&gt;
其中，每一个小格代表1bit.&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Version:&lt;/b&gt; 4 bits&lt;br&gt;
The Version field indicates the format of the internet header. This document describes version 4.&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;IHL:&lt;/b&gt; 4 bits&lt;br&gt;
Internet Header Length is the length of the internet header in 32 bit words, and thus points to the beginning of the data. Note that the minimum value for a correct header is 5.&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Type of Service:&lt;/b&gt; 8 bits&lt;br&gt;
The Type of Service provides an indication of the abstract parameters of the quality of service desired. These parameters are to be used to guide the selection of the actual service parameters when transmitting a datagram through a particular network. Several networks offer service precedence, which somehow treats high precedence traffic as more important than other traffic (generally by accepting only traffic above a certain precedence at time of high load). The major choice is a three way tradeoff between low-delay, high-reliability, and high-throughput.&lt;br&gt;
Bits 0-2: Precedence.&lt;br&gt;
Bit 3: 0 = Normal Delay, 1 = Low Delay.&lt;br&gt;
Bits 4: 0 = Normal Throughput, 1 = High Throughput.&lt;br&gt;
Bits 5: 0 = Normal Relibility, 1 = High Relibility.&lt;br&gt;
Bit 6-7: Reserved for Future Use.&lt;br&gt;
Precedence:&lt;br&gt;
111 - Network Control&lt;br&gt;
110 - Internetwork Control&lt;br&gt;
101 - CRITIC/ECP&lt;br&gt;
100 - Flash Override&lt;br&gt;
011 - Flash&lt;br&gt;
010 - Immediate&lt;br&gt;
001 - Priority&lt;br&gt;
000 - Routine&lt;br&gt;
The use of the Delay, Throughput, and Reliability indications may increase the cost (in some sense) of the service. In many networks better performance for one of these parameters is coupled with worse performance on another. Except for very unusual cases at most two of these three indications should be set.The type of service is used to specify the treatment of the datagram during its transmission through the internet system.&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Total Length:&lt;/b&gt; 16 bits&lt;br&gt;
Total Length is the length of the datagram, measured in octets,  including internet header and data. This field allows the length of a datagram to be up to 65,535 octets. Such long datagrams are impractical for most hosts and networks. All hosts must be prepared to accept datagrams of up to 576 octets (whether they arrive whole or in fragments). It is recommended that hosts only send datagrams larger than 576 octets if they have assurance that the destination is prepared to accept the larger datagrams. The number 576 is selected to allow a reasonable sized data block to be transmitted in addition to the required header information. For example, this size allows a data block of 512 octets plus 64 header octets to fit in a datagram. The maximal internet header is 60 octets, and a typical internet header is 20 octets, allowing a margin for headers of higher level protocols.&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Identification:&lt;/b&gt; 16 bits&lt;br&gt;
An identifying value assigned by the sender to aid in assembling the fragments of a datagram.&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Flags:&lt;/b&gt; 3 bits&lt;br&gt;
Various Control Flags.&lt;br&gt;
Bit 0: reserved, must be zero&lt;br&gt;
Bit 1: (DF) 0 = May Fragment, 1 = Don’t Fragment.&lt;br&gt;
Bit 2: (MF) 0 = Last Fragment, 1 = More Fragments.&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Fragment Offset:&lt;/b&gt; 13 bits&lt;br&gt;
This field indicates where in the datagram this fragment belongs. The fragment offset is measured in units of 8 octets (64 bits). The first fragment has offset zero.&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Time to Live:&lt;/b&gt; 8 bits&lt;br&gt;
This field indicates the maximum time the datagram is allowed to remain in the internet system. If this field contains the value zero, then the datagram must be destroyed. This field is modified in internet header processing. The time is measured in units of seconds, but since every module that processes a datagram must decrease the TTL by at least one even if it process the datagram in less than a second, the TTL must be thought of only as an upper bound on the time a datagram may exist. The intention is to cause undeliverable datagrams to be discarded, and to bound the maximum datagram lifetime.&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Protocol:&lt;/b&gt; 8 bits&lt;br&gt;
This field indicates the next level protocol used in the data portion of the internet datagram. The values for various protocols are specified in "Assigned Numbers".&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Header Checksum:&lt;/b&gt; 16 bits&lt;br&gt;
A checksum on the header only. Since some header fields change (e.g., time to live), this is recomputed and verified at each point that the internet header is processed.&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Source Address:&lt;/b&gt; 32 bits&lt;br&gt;
&lt;b&gt;Destination Address:&lt;/b&gt; 32 bits&lt;br&gt;
详见下文的地址说明&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Options:&lt;/b&gt; variable&lt;br&gt;
The options may appear or not in datagrams. They must be implemented by all IP modules (host and gateways). What is optional is their transmission in any particular datagram, not their implementation.&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Padding:&lt;/b&gt; variable&lt;br&gt;
The internet header padding is used to ensure that the internet header ends on a 32 bit boundary. The padding is zero.&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2-2" class="outline-3"&gt;
&lt;h3 id="sec-2-2"&gt;额外说明&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-2"&gt;
&lt;p&gt;
&lt;b&gt;Addressing&lt;/b&gt;&lt;br&gt;
To provide for flexibility in assigning address to networks and allow for the large number of small to intermediate sized networks the interpretation of the address field is coded to specify a small number of networks with a large number of host, a moderate number of networks with a moderate number of hosts, and a large number of networks with a small number of hosts. In addition there is an escape code for extended addressing mode.&lt;br&gt;
&lt;/p&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="right"&gt;

&lt;col class="left"&gt;

&lt;col class="left"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="right"&gt;High Order Bit&lt;/th&gt;
&lt;th scope="col" class="left"&gt;Format&lt;/th&gt;
&lt;th scope="col" class="left"&gt;Class&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="right"&gt;0&lt;/td&gt;
&lt;td class="left"&gt;7 bits of net, 24 bits of host&lt;/td&gt;
&lt;td class="left"&gt;a&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="right"&gt;10&lt;/td&gt;
&lt;td class="left"&gt;14 bits of net, 16 bits of host&lt;/td&gt;
&lt;td class="left"&gt;b&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="right"&gt;110&lt;/td&gt;
&lt;td class="left"&gt;21 bits of net, 8 bits of host&lt;/td&gt;
&lt;td class="left"&gt;d&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="right"&gt;111&lt;/td&gt;
&lt;td class="left"&gt;escape to extended addressing mode&lt;/td&gt;
&lt;td class="left"&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
The local address, assigned by the local network, must allow for a single physical host to act as several distinct internet hosts. That is, there must be a mapping between internet host addresses and network/host interfaces that allows several internet addresses to correspond to one interface. It must also be allowed for a host to have several physical interfaces and to treat the datagrams from several of them as if they were all addressed to a single host.&lt;br&gt;
有关ip地址更详细的说明在 &lt;a href="https://tools.ietf.org/html/rfc790"&gt;rfc790&lt;/a&gt; 中，该文档中还包含ip地址和端口号的分配。&lt;br&gt;
&lt;/p&gt;


&lt;p&gt;
&lt;b&gt;Fragmentation and Reassembly&lt;/b&gt;&lt;br&gt;
The internet identification field (ID) is used together with the source and destination address, and the protocol fields, to identify datagram fragments for reassembly.&lt;br&gt;
The More Fragments flag bit (MF) is set if the datagram is not the last fragment. The Fragment Offset field identifies the fragment location, relative to the beginning of the original unfragmented datagram. Fragments are counted in units of 8 octets. The fragmentation strategy is designed so than an unfragmented datagram has all zero fragmentation information (MF = 0, fragment offset = 0). If an internet datagram is fragmented, its data portion must be broken on 8 octet boundaries.&lt;br&gt;
When fragmentation occurs, some options are copied, but others remain with the first fragment only.&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Type of Service&lt;/b&gt;&lt;br&gt;
The type of service (TOS) is for internet service quality selection. The type of service is specified along the abstract parameters precedence, delay, throughput, and reliability. These abstract parameters are to be mapped into the actual service parameters of the particular networks the datagram traverses.&lt;br&gt;
Precedence. An independent measure of the importance of this datagram.&lt;br&gt;
Delay. Prompt delivery is important for datagrams with this indication.&lt;br&gt;
Throughput. High data rate is important for datagrams with this indication.&lt;br&gt;
Reliability. A higher level of effort to ensure delivery is important for datagrams with this indication.&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Time to Live&lt;/b&gt;&lt;br&gt;
The time to live is set by the sender to the maximum time the datagram is allowed to be in the internet system. If the datagram is in the internet system longer than the time to live, then the datagram must be destroyed.&lt;br&gt;
This field must be decreased at each point that the internet header is processed to reflect the time spent processing the datagram. Even if no local information is available on the time actually spent, the field must be decremented by 1. The time is measured in units of seconds (i.e. the value 1 means one second). Thus, the maximum time to live is 255 seconds or 4.25 minutes. Since every module that processes a datagram must decrease the TTL by at least one even if it process the datagram in less than a second, the TTL must be thought of only as an upper bound on the time a datagram may exist. The intention is to cause undeliverable datagrams to be discarded, and to bound the maximum datagram lifetime.&lt;br&gt;
Some higher level reliable connection protocols are based on assumptions that old duplicate datagrams will not arrive after a certain time elapses. The TTL is a way for such protocols to have an assurance that their assumption is met.&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Options&lt;/b&gt;&lt;br&gt;
The options are optional in each datagram, but required in implementations. That is, the presence or absence of an option is the choice of the sender, but each internet module must be able to parse every option. There can be several options present in the option field.&lt;br&gt;
The options might not end on a 32-bit boundary. The internet header must be filled out with octets of zeros. The first of these would be interpreted as the end-of-options option, and the remainder as internet header padding.&lt;br&gt;
Every internet module must be able to act on every option. The Security Option is required if classified, restricted, or compartmented traffic is to be passed.&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Checksum&lt;/b&gt;&lt;br&gt;
The internet header checksum is recomputed if the internet header is changed. For example, a reduction of the time to live, additions or changes to internet options, or due to fragmentation. This checksum at the internet level is intended to protect the internet header fields from transmission errors.&lt;br&gt;
There are some applications where a few data bit errors are acceptable while retransmission delays are not. If the internet protocol enforced data correctness such applications could not be supported.&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Errors&lt;/b&gt;&lt;br&gt;
Internet protocol errors may be reported via the ICMP messages.&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-sec-3" class="outline-2"&gt;
&lt;h2 id="sec-3"&gt;参考资料&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Internet_Protocol"&gt;wikipedia - internet protocol&lt;/a&gt;&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://tools.ietf.org/html/rfc791"&gt;ietf - rfc791 (Sep. 1981)&lt;/a&gt;&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://tools.ietf.org/html/rfc790"&gt;ietf - rfc790 (Sep. 1981)&lt;/a&gt;&lt;br&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>ip</category><category>network</category><category>protocol</category><guid>https://samsonwang.me/posts/internet-protocol/</guid><pubDate>Mon, 24 Sep 2018 12:16:15 GMT</pubDate></item><item><title>网络通信协议</title><link>https://samsonwang.me/posts/network-protocol-suite/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;OSI模型&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
OSI（open system interconnection）模型是一个概念模型，它特征化、标准化了计算机系统之间的通信过程。OSI模型分为7层，在模型中对端的同一层间使用相同的通信协议。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;OSI模型及其常见协议&lt;/b&gt;&lt;br&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;7 - Application（应用层）: DNS, HTTP, NTP, SMTP, Telnet, DHCP&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;6 - Presentation（表示层）: MIME, XDR, ASN.1&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;5 - Session（会话层）: Named pipe, NetBIOS, SAP, PPTP, RTP, SOCKS&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;4 - Transport（传输层）: TCP, UDP, SCTP, DCCP, SPX&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;3 - Network（网络层）: IP, ICMP, IPsec, IGMP, IPX, AppleTalk&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;2 - Data link（链路层）: ARP, MAC, IEEE 802.2, L2TP, PPP&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;1 - Physical（物理层）: RS-232, USB, IEEE 1394, IEEE 802.3&lt;br&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
&lt;b&gt;PDU与SDU的概念&lt;/b&gt;&lt;br&gt;
在每一层上，在两个通信设备上互为同层的对端交换的是按照该层协议的PDU(protocol data units)。每个PDU中包含的载荷被称作SDU（service data units）。每个PDU包含该层协议的包头包尾与SDU。通俗地讲，上层协议在向下层传递时，会按照对应的协议增加包头和包尾。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;常见通信方式都使用了哪些层协议&lt;/b&gt;&lt;br&gt;
以太网（ethernet）的标准协议IEEE 802.3，无线网（Wi-Fi）的标准协议IEEE 802.11&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2" class="outline-2"&gt;
&lt;h2 id="sec-2"&gt;TCP/IP协议（互联网协议）&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
互联网协议是以TCP协议（transmission control protocol）和IP协议（internet protocol）做为基础的，所以它也称为TCP/IP协议。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;互联网协议分层&lt;/b&gt;&lt;br&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Application（应用层）: SMTP, FTP, SSH, HTTP&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;Transport（传输层）: TCP, UDP&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;Internet（网络层）: IP, ICMP&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;Link（链路层）: ARP, MAC&lt;br&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
&lt;b&gt;应用层&lt;/b&gt;&lt;br&gt;
应用程序之间进行用户数据的交换就在应用层。应用程序或进程借助较底层提供的“管道”与其他进程实现信息交互。高层通信协议在这一层运作，常见的有SMTP、FTP、SSH、HTTP。通过端口号来够区分不同的服务。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;传输层&lt;/b&gt;&lt;br&gt;
传输层进行主机到主机（host-to-host）的通信，这个过程可以发生在同一个主机上，也可以借助路由放生在不同网络的主机之间。UDP是基本的传输层协议，提供一个不可靠的数据报服务。TCP提供拥塞控制（flow control）、连接建立和数据的可靠传输。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;网络层&lt;/b&gt;&lt;br&gt;
网络层提供一个统一的网络接口，将底层的网络拓扑和网络分布隐藏起来。这一层定义了网络寻址和路由结构。这一层的主要协议是IP协议，IP协议定义了IP地址。路由的功能是将数据报传输到距离终点更近的下一个路由上，最终完成数据包的传输。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;链路层&lt;/b&gt;&lt;br&gt;
链路层定义了除路由之外的本地网络连接之间的通信。这一层包括用于描述本地网络的拓扑结构的协议和相邻主机之间传输网络层数据包所需要的接口。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-sec-3" class="outline-2"&gt;
&lt;h2 id="sec-3"&gt;TCP/IP协议与OSI模型的比较&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
两种网络协议的区别可以通过下面的图表看出来。&lt;br&gt;
&lt;/p&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="left"&gt;

&lt;col class="left"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="left"&gt;TCP/IP&lt;/th&gt;
&lt;th scope="col" class="left"&gt;OSI&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="left"&gt;Application&lt;/td&gt;
&lt;td class="left"&gt;Application&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="left"&gt; &lt;/td&gt;
&lt;td class="left"&gt;Presentation&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="left"&gt; &lt;/td&gt;
&lt;td class="left"&gt;Session&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="left"&gt;Transport&lt;/td&gt;
&lt;td class="left"&gt;Transport&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="left"&gt;Internet&lt;/td&gt;
&lt;td class="left"&gt;Network&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="left"&gt;Link&lt;/td&gt;
&lt;td class="left"&gt;Data link&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="left"&gt; &lt;/td&gt;
&lt;td class="left"&gt;Physical&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-4" class="outline-2"&gt;
&lt;h2 id="sec-4"&gt;参考资料&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://codeburst.io/learning-tcp-ip-protocol-suite-6947b601ea11"&gt;codeburst.io - tcp ip suite&lt;/a&gt;&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://zh.wikipedia.org/wiki/OSI%25E6%25A8%25A1%25E5%259E%258B"&gt;wikipedia - OSI网络模型&lt;/a&gt;&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Internet_protocol_suite"&gt;wikipedia - internet protocol suite&lt;/a&gt;&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Protocol_stack"&gt;wikipedia - protocol stack&lt;/a&gt;&lt;br&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>ip</category><category>network</category><category>osi</category><category>tcp</category><guid>https://samsonwang.me/posts/network-protocol-suite/</guid><pubDate>Fri, 21 Sep 2018 09:51:57 GMT</pubDate></item></channel></rss>