<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="/blog/assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Hack Note (Posts about union)</title><link>https://samsonwang.github.io/blog/</link><description></description><atom:link href="https://samsonwang.github.io/blog/tags/union.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2017-2019 &lt;a href="mailto:wangzhilv@gmail.com"&gt;Samson Wang&lt;/a&gt; 
&lt;a rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/"&gt;&lt;img alt="知识共享许可协议" style="padding-bottom:2px" src="https://i.creativecommons.org/l/by-nc/4.0/80x15.png" /&gt;&lt;/a&gt;
</copyright><lastBuildDate>Fri, 20 Dec 2019 16:28:14 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>位域与联合体的内存布局</title><link>https://samsonwang.github.io/blog/posts/bit-field-and-union-type/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div&gt;&lt;p&gt;
位域（bit field）与联合体（union）都可以用来控制内存布局。本文主要阐述的内存可总结为：位域的内存布局是编译器决定的，而联合体的内存布局是由大小端决定的。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://samsonwang.github.io/blog/posts/bit-field-and-union-type/"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>bit field</category><category>c</category><category>cpp</category><category>endian</category><category>memory layout</category><category>union</category><guid>https://samsonwang.github.io/blog/posts/bit-field-and-union-type/</guid><pubDate>Tue, 21 May 2019 08:35:02 GMT</pubDate></item><item><title>字节序与union类型</title><link>https://samsonwang.github.io/blog/posts/endianness-and-union-type/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;字节序&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
字节序是指在数据传输时，高位字节存储在内存中的较高位地址还是较低位地址。&lt;br&gt;
字节序分为大端字节序和小端字节序，两种字节序不能混用。&lt;br&gt;
&lt;b&gt;大端字节序&lt;/b&gt; ：高位字节保存在较低位地址的内存中&lt;br&gt;
&lt;b&gt;小端字节序&lt;/b&gt; ：高位字节保存在较高位地址的内存中&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
以 &lt;code&gt;int n = 0x12345678&lt;/code&gt; 为例，大端字节序内存中的存储的顺序为 &lt;code&gt;0x12 0x34 0x56 0x78&lt;/code&gt; ，小端字节序内存中的存储顺序为 &lt;code&gt;0x78 0x56 0x34 0x12&lt;/code&gt; 。很明显可以看出大端字节序更符合人类的阅读习惯。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
常见的大端系统CPU：IBM z/Atchitecture&lt;br&gt;
常见的小端系统CPU：intel x86&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
网络字节序使用的大端字节序，常用网络协议如IPv4、IPv6、TCP和UDP协议都是使用大端字节序完成数据传输的。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;



&lt;div id="outline-container-sec-2" class="outline-2"&gt;
&lt;h2 id="sec-2"&gt;查看当前系统的字节序&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
通过 &lt;code&gt;lscpu&lt;/code&gt; 命令，能得到cpu的大端和小端信息。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;lscpu &lt;span class="p"&gt;|&lt;/span&gt; grep -i endian
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
通过常用shell命令，在大端系统中会输出0，在小端系统中会输出1。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; -n I &lt;span class="p"&gt;|&lt;/span&gt; od -to2 &lt;span class="p"&gt;|&lt;/span&gt; head -n1 &lt;span class="p"&gt;|&lt;/span&gt; cut -f2 -d&lt;span class="s2"&gt;" "&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; cut -c6
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
借助python进行判断。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;python -c &lt;span class="s2"&gt;"import sys; print(sys.byteorder)"&lt;/span&gt;
&lt;span class="c1"&gt;# or&lt;/span&gt;
python -c &lt;span class="s2"&gt;"import sys;sys.exit(0 if sys.byteorder=='big' else 1)"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
借助linux的ELF进行判断，查看第6个字节，小端系统中为1，大端系统中为2。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;xxd -c &lt;span class="m"&gt;1&lt;/span&gt; -l &lt;span class="m"&gt;6&lt;/span&gt; /bin/bash
&lt;span class="c1"&gt;# or&lt;/span&gt;
hexdump -n &lt;span class="m"&gt;6&lt;/span&gt; -C /bin/bash
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;



&lt;div id="outline-container-sec-3" class="outline-2"&gt;
&lt;h2 id="sec-3"&gt;union类型&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
可以使用union类型验证字节序，以下示例代码在不同的字节序下会有不同的输出。&lt;br&gt;
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;inttypes.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;union&lt;/span&gt; &lt;span class="n"&gt;un&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int32_t&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;ch&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="n"&gt;un&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;un&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ch&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ch&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ch&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ch&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"u.x=0x%x&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-sec-4" class="outline-2"&gt;
&lt;h2 id="sec-4"&gt;参考资料&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Endianness"&gt;wikipedia.com - endianness&lt;/a&gt;&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://serverfault.com/questions/163487/how-to-tell-if-a-linux-system-is-big-endian-or-little-endian"&gt;serverfault.com - how to check endian&lt;/a&gt;&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format"&gt;wikipedia.com - ELF format&lt;/a&gt;&lt;br&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
（全文完）&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>computer science</category><category>cpp</category><category>endian</category><category>union</category><guid>https://samsonwang.github.io/blog/posts/endianness-and-union-type/</guid><pubDate>Fri, 11 May 2018 01:55:34 GMT</pubDate></item></channel></rss>