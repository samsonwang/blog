<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="/assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Hack Note (Posts about network)</title><link>http://samsonwang.me/</link><description></description><atom:link href="http://samsonwang.me/tags/network.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2017-2018 &lt;a href="mailto:wangzhilv@gmail.com"&gt;Samson Wang&lt;/a&gt; 
&lt;a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/"&gt;&lt;img alt="知识共享许可协议" style="border-width:0; vertical-align:text-top;" src="https://i.creativecommons.org/l/by-nc/4.0/80x15.png" /&gt;&lt;/a&gt;
</copyright><lastBuildDate>Mon, 17 Sep 2018 03:17:38 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>客户端使用非阻塞socket进行connect的流程</title><link>http://samsonwang.me/posts/non-blocking-socket-connect-tips/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;问题&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
使用非阻塞（ &lt;code&gt;non-blocking&lt;/code&gt; ） socket尝试与服务端建立连接（ &lt;code&gt;connect&lt;/code&gt; ）时，由于是io非阻塞的，所以 &lt;code&gt;connect&lt;/code&gt; 函数会立即返回，那么如何判断client与server连接成功了呢？&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2" class="outline-2"&gt;
&lt;h2 id="sec-2"&gt;解答&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
客户端建立连接的示例代码如下：&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;connect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...);&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;errno&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;EINPROGRESS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// case1. error, fail somehow, close socket&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// case2. connection has succeeded immediately&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// case3. connection attempt is in progress&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
由于是非阻塞模式，所以 &lt;code&gt;connect&lt;/code&gt; 之后会直接返回，根据返回值 &lt;code&gt;res&lt;/code&gt; 和 &lt;code&gt;errno&lt;/code&gt; 能够判断建立连接的结果。&lt;br&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;case1，表示连接失败；&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;case2，表示连接建立成功；&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;case3，表示正在建立连接的过程中，在这个情况下，需要等待socket变成可写（writable）状态，可以使用 &lt;code&gt;select&lt;/code&gt; 或 &lt;code&gt;epoll&lt;/code&gt; 完成；&lt;br&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
在 case3 情况下，socket可写后，执行下面的代码检查socket是否出现错误。&lt;br&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;case4和case5，表示socket出现了错误，将会关闭连接；&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;case6，表示连接建立成功，可以开始 &lt;code&gt;read&lt;/code&gt; 和 &lt;code&gt;write&lt;/code&gt; 了。&lt;br&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;socklen_t&lt;/span&gt; &lt;span class="n"&gt;result_len&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;getsockopt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SOL_SOCKET&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SO_ERROR&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;result_len&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// case4. error, fail somehow, close socket&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// case5. connection failed; error code is in 'result'&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// case6. socket is ready for read()/write()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-3" class="outline-2"&gt;
&lt;h2 id="sec-3"&gt;参考资料&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/10187347/async-connect-and-disconnect-with-epoll-linux/10194883#10194883"&gt;stackoverflow.com&lt;/a&gt;&lt;br&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>network</category><category>nio</category><category>non-blocking</category><category>socket</category><guid>http://samsonwang.me/posts/non-blocking-socket-connect-tips/</guid><pubDate>Fri, 31 Aug 2018 09:04:19 GMT</pubDate></item><item><title>Reactor模式</title><link>http://samsonwang.me/posts/reactor-pattern/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; 什么是Reactor模式&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
Reactor模式是一种事件驱动的设计模式，用于处理多输入源的并发服务请求。服务处理者（service handler）将接收到的服务请求同步分发给每个请求处理者（request handler）。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2" class="outline-2"&gt;
&lt;h2 id="sec-2"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; Reactor模式的优缺点&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;/div&gt;&lt;div id="outline-container-sec-2-1" class="outline-3"&gt;
&lt;h3 id="sec-2-1"&gt;&lt;span class="section-number-3"&gt;2.1&lt;/span&gt; 优点&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-1"&gt;
&lt;p&gt;
节选自 DC.Shmidt 的论文&lt;br&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Separation of concerns: The Reactor pattern decouples application-independent demultiplexing and dispatching mechanisms from application-specific hook method functionality. The application-independent mechanisms become reusable components that know how to demultiplex events and dispatch the appropriate hook methods defined by Event Handlers. In contrast, the application-specific functionality in a hook method knows how to perform a particular type of service.&lt;br&gt;
&lt;/li&gt;

&lt;li&gt;Improve modularity, reusability, and configurability of event-driven applications: The pattern decouples application functionality into separate classes. For instance, there are two separate classes in the logging server: one for establishing connections and another for receiving and processing logging records. This decoupling enables the reuse of the connection establishment class for different types of connection-oriented services (such as file transfer, remote login, and video-on-demand). Therefore, modifying or extending the functionality of the logging server only affects the implementation of the logging handler class.&lt;br&gt;
&lt;/li&gt;

&lt;li&gt;Improves application portability: The Initiation Dispatcher’s interface can be reused independently of the OS system calls that perform event demultiplexing. These system calls detect and report the occurrence of one or more events that may occur simultaneously on multiple sources of events. Common sources of events may include I/O handles, timers, and synchronization objects. On UNIX platforms, the event demultiplexing system calls are called select and poll. In the Win32 API, the WaitForMultipleObjects system call performs event demultiplexing.&lt;br&gt;
&lt;/li&gt;

&lt;li&gt;Provides coarse-grained concurrency control: The Reactor pattern serializes the invocation of event handlers at the level of event demultiplexing and dispatching within a process or thread. Serialization at the Initiation Dispatcher level often eliminates the need for more complicated synchronization or locking within an application process.&lt;br&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2-2" class="outline-3"&gt;
&lt;h3 id="sec-2-2"&gt;&lt;span class="section-number-3"&gt;2.2&lt;/span&gt; 缺点&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-2"&gt;
&lt;p&gt;
节选的 DC.Schmidt 的论文&lt;br&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Restricted applicability: The Reactor pattern can only be applied efficiently if the OS supports Handles. It is possible to emulate the semantics of the Reactor pattern using multiple threads within the Initiation Dispatcher, e.g. one thread for each Handle. Whenever there are events available on a handle, its associated thread will read the event and place it on a queue that is processed sequentially by the initiation dispatcher. However, this design is typically very inefficient since it serializes all Event Handlers, thereby increasing synchronization and context switching overhead without enhancing parallelism.&lt;br&gt;
&lt;/li&gt;

&lt;li&gt;Non-preemptive: In a single-threaded application process, Event Handlers are not preempted while they are executing. This implies that an Event Handler should not perform blocking I/O on an individual Handle since this will block the entire process and impede the responsiveness for clients connected to other Handles. Therefore, for long-duration operations, such as transferring multimegabyte medical images, the Active Object pattern may be more effective. An Active Object uses multithreading or multi-processing to complete its tasks in parallel with the Initiation Dispatcher’s main event-loop.&lt;br&gt;
&lt;/li&gt;

&lt;li&gt;Hard to debug: Applications written with the Reactor pattern can be hard to debug since the inverted flow of control oscillates between the framework infrastructure and the method callbacks on application-specific handlers. This increases the difficulty of “single-stepping” through the runtime behavior of a framework within a debugger since application developers may not understand or have access to the framework code. This is similar to the problems encountered trying to debug a compiler lexical analyzer and parser written with LEX and YACC. In these applications, debugging is straightforward when the thread of control is within the user-defined action routines. Once the thread of control returns to the generated Deterministic Finite Automata (DFA) skeleton, however, it is hard to follow the program logic.&lt;br&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-3" class="outline-2"&gt;
&lt;h2 id="sec-3"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; 使用Reactor模式的代码示例&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
D.C.shmidt提出的Reactor模式，在他的ACE框架中广泛使用了该设计模式。&lt;br&gt;
libevent是否是使用Reactor模式进行设计编写的呢？&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-sec-4" class="outline-2"&gt;
&lt;h2 id="sec-4"&gt;&lt;span class="section-number-2"&gt;4&lt;/span&gt; Reactor模式与Proactor模式&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;p&gt;
Proacotor模式是一种异步IO的方式，。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-5" class="outline-2"&gt;
&lt;h2 id="sec-5"&gt;&lt;span class="section-number-2"&gt;5&lt;/span&gt; 参考资料&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-5"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Reactor_pattern"&gt;https://en.wikipedia.org/wiki/Reactor_pattern&lt;/a&gt;&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.cs.wustl.edu/~schmidt/PDF/reactor-siemens.pdf"&gt;http://www.cs.wustl.edu/~schmidt/PDF/reactor-siemens.pdf&lt;/a&gt;&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/9138294/what-is-the-difference-between-event-driven-model-and-reactor-pattern"&gt;https://stackoverflow.com/questions/9138294/what-is-the-difference-between-event-driven-model-and-reactor-pattern&lt;/a&gt;&lt;br&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>design pattern</category><category>network</category><guid>http://samsonwang.me/posts/reactor-pattern/</guid><pubDate>Thu, 28 Jun 2018 01:58:43 GMT</pubDate></item><item><title>Linux常用命令行指令 - netstat</title><link>http://samsonwang.me/posts/linux-command-examples-netstat/</link><dc:creator>Samson Wang</dc:creator><description>&lt;p&gt;
常见的选项有：&lt;br&gt;
-a (all)显示所有选项，netstat默认不显示LISTEN相关&lt;br&gt;
-t (tcp)仅显示tcp相关选项&lt;br&gt;
-u (udp)仅显示udp相关选项&lt;br&gt;
-n 拒绝显示别名，能显示数字的全部转化成数字。(重要)&lt;br&gt;
-l 仅列出有在 Listen (监听) 的服务状态&lt;br&gt;
-p 显示建立相关链接的程序名(macOS中表示协议 -p protocol)&lt;br&gt;
-r 显示路由信息，路由表&lt;br&gt;
-e 显示扩展信息，例如uid等&lt;br&gt;
-s 按各个协议进行统计 (重要)&lt;br&gt;
-c 每隔一个固定时间，执行该netstat命令。&lt;br&gt;
&lt;/p&gt;</description><category>linux</category><category>network</category><guid>http://samsonwang.me/posts/linux-command-examples-netstat/</guid><pubDate>Wed, 28 Mar 2018 14:55:16 GMT</pubDate></item><item><title>Linux常用命令行指令 - tcpdump</title><link>http://samsonwang.me/posts/linux-command-examples-tcpdump/</link><dc:creator>Samson Wang</dc:creator><description>&lt;p&gt;
tcpdump常用于网络抓包，能够将抓取的包保存下来，这样就能进一步深入分析。抓包保存的文件可以使用tcpdump进行查看，也可以借助第三方软件（如wireshark）进行辅助分析。&lt;br&gt;
&lt;/p&gt;

&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;1. 抓取指定网络设备上的包&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
抓取网卡eth0上的包&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;tcpdump -i eth0
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-sec-2" class="outline-2"&gt;
&lt;h2 id="sec-2"&gt;2. 限制抓包的数量&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
只抓取5个包&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;tcpdump -c 5 -i eth0
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-sec-3" class="outline-2"&gt;
&lt;h2 id="sec-3"&gt;3. 将抓取的包以ASCII的方式打印出来&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;tcpdump -A -i eth0
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-sec-4" class="outline-2"&gt;
&lt;h2 id="sec-4"&gt;4. 将抓取的包以十六进制的方式打印出来&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;tcpdump -XX -i eth0
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-sec-5" class="outline-2"&gt;
&lt;h2 id="sec-5"&gt;5. 对抓取到的包上打出更方便阅读的时间戳&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-5"&gt;
&lt;p&gt;
增加 &lt;code&gt;-t&lt;/code&gt; 参数能够将抓取到的包中的时间以方便阅读的形式打印出来，使用 &lt;code&gt;-tttt&lt;/code&gt; 参数能够将包中的时间戳以更详细的方式打印出来。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;tcpdump -t -i eth0
tcpdump -tttt -i eth0
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-sec-6" class="outline-2"&gt;
&lt;h2 id="sec-6"&gt;6. 将抓取的包写入到文件中&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-6"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;tcpdump -w netdump.pcap -i eth0
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-sec-7" class="outline-2"&gt;
&lt;h2 id="sec-7"&gt;7. 读取抓到的包&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-7"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;tcpdump -r netdump.pcap
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-sec-8" class="outline-2"&gt;
&lt;h2 id="sec-8"&gt;8. 在抓到的包中显示ip地址&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-8"&gt;
&lt;p&gt;
增加 &lt;code&gt;-n&lt;/code&gt; 参数不会解析主机名，增加 &lt;code&gt;-nn&lt;/code&gt; 参数不会解析主机名和端口名&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;tcpdump -n -i eth0
tcpdump -nn -i eth0
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-sec-9" class="outline-2"&gt;
&lt;h2 id="sec-9"&gt;9. 以绝对值显示包的ISN号&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-9"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;tcpdump -S -i eth0
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-sec-10" class="outline-2"&gt;
&lt;h2 id="sec-10"&gt;10. 对抓取到的包显示更详细的信息&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-10"&gt;
&lt;p&gt;
参数 &lt;code&gt;-v&lt;/code&gt; 是verbose的缩写，以下命令表示对抓取到的包显示更详细的信息。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;tcpdump -v -i eth0
tcpdump -vv -i eth0
tcpdump -vvv -i eth0
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-sec-11" class="outline-2"&gt;
&lt;h2 id="sec-11"&gt;11. 对抓到的包进行协议类型过滤&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-11"&gt;
&lt;p&gt;
支持的协议类型有：fddi, tr, wlan, ip, ip6, arp, rarp, decnet, tcp, udp&lt;br&gt;
以下命令只会抓取网卡eth0上的arp包&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;tcpdump -i eth0 arp
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-sec-12" class="outline-2"&gt;
&lt;h2 id="sec-12"&gt;12. 在抓包时对包进行大小过滤&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-12"&gt;
&lt;p&gt;
下面的命令会分别抓取大于1024字节和小于1024字节的包&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;tcpdump -i eth0 greater 1024
tcpdump -i eth0 less 1024
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-sec-13" class="outline-2"&gt;
&lt;h2 id="sec-13"&gt;13. 抓取指定端口上的包&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-13"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;tcpdump -i eth0 port 22
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-sec-14" class="outline-2"&gt;
&lt;h2 id="sec-14"&gt;14. 抓取发往指定目的和端口上包&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-14"&gt;
&lt;p&gt;
可以使用 &lt;code&gt;and&lt;/code&gt; 和 &lt;code&gt;or&lt;/code&gt; 对过滤条件进行组合以实现精确的抓包。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;tcpdump -w net_dump.pcap -i eth0 dst 10.181.140.216 and port 22
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-15" class="outline-2"&gt;
&lt;h2 id="sec-15"&gt;常用tcpdump命令示例&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-15"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;tcpdump –i any 'port 8888'
tcpdump –i any 'tcp port 8888'
tcpdump –i any 'tcp src port 8888'
tcpdump –i any 'tcp src port 8888 and udp dst port 9999'
tcpdump -i any 'src host 127.0.0.1 and tcp src port 12345' -XX -nn -vv
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-16" class="outline-2"&gt;
&lt;h2 id="sec-16"&gt;参考资料&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-16"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://danielmiessler.com/study/tcpdump/"&gt;danielmiessler.com tcpdump&lt;/a&gt;&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.thegeekstuff.com/2010/08/tcpdump-command-examples/"&gt;thegeekstuff.com tcpdump&lt;/a&gt;&lt;br&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>linux</category><category>network</category><category>shell</category><category>tcpdump</category><guid>http://samsonwang.me/posts/linux-command-examples-tcpdump/</guid><pubDate>Sun, 25 Mar 2018 15:34:53 GMT</pubDate></item></channel></rss>