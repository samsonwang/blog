<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="/assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Hack Note (Posts about linux)</title><link>http://samsonwang.me/</link><description></description><atom:link href="http://samsonwang.me/tags/category_linux.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2017-2018 &lt;a href="mailto:zl.wang@foxmail.com"&gt;Samson Wang&lt;/a&gt; 
&lt;a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/"&gt;&lt;img alt="知识共享许可协议" style="border-width:0; vertical-align:text-top;" src="https://i.creativecommons.org/l/by-nc/4.0/80x15.png" /&gt;&lt;/a&gt;
</copyright><lastBuildDate>Wed, 27 Jun 2018 01:53:32 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>查看Linux系统的相关信息</title><link>http://samsonwang.me/posts/check-system-information-on-linux/</link><dc:creator>Samson Wang</dc:creator><description>&lt;p&gt;
查看Linux系统相关信息有助于排查和解决软件和硬件的兼容性问题。系统信息包括硬件信息和软件信息，硬件信息主要有CPU信息、内存信息、PCI信息、USB信息、硬盘信息等等。软件信息主要有系统版本、分区使用状态等等。本文主要介绍了获取当前Linux系统信息的命令。&lt;br&gt;
&lt;/p&gt;

&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;查看系统相关信息&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
&lt;code&gt;uname&lt;/code&gt; 指令提供了查询系统信息的功能，使用该命令能够快速获取操作系统信息概览。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
查看内核名称&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;uname -s
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
查看处理器类型&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;uname -p
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
查看硬件架构&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;uname -i
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
查看所有的系统信息&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;uname -a
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2" class="outline-2"&gt;
&lt;h2 id="sec-2"&gt;查看CPU相关信息&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
&lt;code&gt;lscpu&lt;/code&gt; 指令能够查看当前系统中CPU的详细信息，包括型号、主频、构架、大小端等信息。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-3" class="outline-2"&gt;
&lt;h2 id="sec-3"&gt;查看硬盘相关信息&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
&lt;code&gt;lsblk&lt;/code&gt; 指令能够查看块设备（block device）的详细信息，块设备主要指系统中的存储设备如硬盘和闪存。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-4" class="outline-2"&gt;
&lt;h2 id="sec-4"&gt;查看PCI设备的相关信息&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;p&gt;
&lt;code&gt;lspci&lt;/code&gt; 指令能够查看PCI设备的信息，PCI设备包括USB、显卡、串口、网卡等其他外围设备。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
输出树形结果&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;lspci -t
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
输出详细信息&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;lspci -v
lspci -vv
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-5" class="outline-2"&gt;
&lt;h2 id="sec-5"&gt;查看USB设备的相关信息&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-5"&gt;
&lt;p&gt;
&lt;code&gt;lsusb&lt;/code&gt; 指令能够查看USBS设备的信息。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-6" class="outline-2"&gt;
&lt;h2 id="sec-6"&gt;查看文件系统相关信息&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-6"&gt;
&lt;p&gt;
&lt;code&gt;fdisk&lt;/code&gt; 命令能够查看和操作linux系统的分区表。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
查看文件系统信息&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;fdisk -l
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
&lt;code&gt;df&lt;/code&gt; 命令能够查看分区信息和硬盘使用信息&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
使输出信息更容易理解&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;df -h
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-7" class="outline-2"&gt;
&lt;h2 id="sec-7"&gt;参考资料&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-7"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://www.tecmint.com/commands-to-collect-system-and-hardware-information-in-linux/"&gt;tecmint.com&lt;/a&gt;&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.binarytides.com/linux-commands-hardware-info/"&gt;binarytides.com&lt;/a&gt;&lt;br&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>linux</category><guid>http://samsonwang.me/posts/check-system-information-on-linux/</guid><pubDate>Wed, 20 Jun 2018 02:30:50 GMT</pubDate></item><item><title>Linux常用命令行指令 - top</title><link>http://samsonwang.me/posts/linux-command-examples-top/</link><dc:creator>Samson Wang</dc:creator><description>&lt;p&gt;
linux的top命令能够动态显示当前系统的运行状态。它能够显示操作系统的汇总信息和当前系统上的正在运行的进程列表。&lt;br&gt;
&lt;/p&gt;

&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; 统计信息说明&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
(可以通过配置文件修改通计信息区的显示格式，下文所描述的都是在默认配置下的显示内容)&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;div id="outline-container-sec-1-1" class="outline-3"&gt;
&lt;h3 id="sec-1-1"&gt;&lt;span class="section-number-3"&gt;1.1&lt;/span&gt; 第1行&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-1"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;当前系统时间&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;up 当前系统的启动时长&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;当前登录的用户数量&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;当前系统的平均负载（分别是1min,5min,10min的平均负载）&lt;br&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
这一行信息也可以通过 &lt;code&gt;uptime&lt;/code&gt; 和 &lt;code&gt;w&lt;/code&gt; 指令获得&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-sec-1-2" class="outline-3"&gt;
&lt;h3 id="sec-1-2"&gt;&lt;span class="section-number-3"&gt;1.2&lt;/span&gt; 第2行&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-2"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;总进程数&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;正在运行的进程数&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;休眠的进程数&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;停止的进程数&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;僵尸进程数&lt;br&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-sec-1-3" class="outline-3"&gt;
&lt;h3 id="sec-1-3"&gt;&lt;span class="section-number-3"&gt;1.3&lt;/span&gt; 第3行&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-3"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;us 用户空间占用CPU百分比&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;sy 内核空间占用CPU百分比&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;ni 用户进程空间内改变过优先级的进程占用CPU百分比&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;id 空闲CPU百分比&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;wa 等待输入输出的CPU时间百分比&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;hi CPU服务于硬件中断所耗费的时间总额&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;si CPU服务软中断所耗费的时间总额&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;st Steal time 虚拟机被hypervisor偷去的CPU时间（如果当前处于一个hypervisor下的vm，实际上hypervisor也是要消耗一部分CPU处理时间的）&lt;br&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-1-4" class="outline-3"&gt;
&lt;h3 id="sec-1-4"&gt;&lt;span class="section-number-3"&gt;1.4&lt;/span&gt; 第4行&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-4"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;物理内存总量&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;使用的物理内存总量&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;空闲内存总量&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;用作内核缓存的内存量&lt;br&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-1-5" class="outline-3"&gt;
&lt;h3 id="sec-1-5"&gt;&lt;span class="section-number-3"&gt;1.5&lt;/span&gt; 第5行&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-5"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;交换区总量&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;使用的交换区总量&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;空间交换区总量&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;缓冲交换区总量&lt;br&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2" class="outline-2"&gt;
&lt;h2 id="sec-2"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; 进程信息&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
在top命令中按f按可以查看显示的列信息，按对应字母来开启/关闭列，大写字母表示开启，小写字母表示关闭。带*号的是默认列。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
A: PID = (Process Id) 进程Id；&lt;br&gt;
E: USER = (User Name) 进程所有者的用户名；&lt;br&gt;
H: PR = (Priority) 优先级&lt;br&gt;
I: NI = (Nice value) nice值。负值表示高优先级，正值表示低优先级&lt;br&gt;
O: VIRT = (Virtual Image (kb)) 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES&lt;br&gt;
Q: RES = (Resident size (kb)) 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA&lt;br&gt;
T: SHR = (Shared Mem size (kb)) 共享内存大小，单位kb&lt;br&gt;
W: S = (Process Status) 进程状态。D=不可中断的睡眠状态,R=运行,S=睡眠,T=跟踪/停止,Z=僵尸进程&lt;br&gt;
K: %CPU = (CPU usage) 上次更新到现在的CPU时间占用百分比&lt;br&gt;
N: %MEM = (Memory usage (RES)) 进程使用的物理内存百分比&lt;br&gt;
M: TIME+ = (CPU Time, hundredths) 进程使用的CPU时间总计，单位1/100秒&lt;br&gt;
b: PPID = (Parent Process Pid) 父进程Id&lt;br&gt;
c: RUSER = (Real user name)&lt;br&gt;
d: UID = (User Id) 进程所有者的用户id&lt;br&gt;
f: GROUP = (Group Name) 进程所有者的组名&lt;br&gt;
g: TTY = (Controlling Tty) 启动进程的终端名。不是从终端启动的进程则显示为 ?&lt;br&gt;
j: P = (Last used cpu (SMP)) 最后使用的CPU，仅在多CPU环境下有意义&lt;br&gt;
p: SWAP = (Swapped size (kb)) 进程使用的虚拟内存中，被换出的大小，单位kb&lt;br&gt;
l: TIME = (CPU Time) 进程使用的CPU时间总计，单位秒&lt;br&gt;
r: CODE = (Code size (kb)) 可执行代码占用的物理内存大小，单位kb&lt;br&gt;
s: DATA = (Data+Stack size (kb)) 可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb&lt;br&gt;
u: nFLT = (Page Fault count) 页面错误次数&lt;br&gt;
v: nDRT = (Dirty Pages count) 最后一次写入到现在，被修改过的页面数&lt;br&gt;
y: WCHAN = (Sleeping in Function) 若该进程在睡眠，则显示睡眠中的系统函数名&lt;br&gt;
z: Flags = (Task Flags &amp;lt;sched.h&amp;gt;) 任务标志，参考 sched.h&lt;br&gt;
X: COMMAND = (Command name/line) 命令名/命令行&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-sec-3" class="outline-2"&gt;
&lt;h2 id="sec-3"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; 参考资料&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://www.tecmint.com/12-top-command-examples-in-linux/"&gt;tecmint.com&lt;/a&gt;&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.csdn.net/sanshiqiduer/article/details/1933625"&gt;csdn blog&lt;/a&gt;&lt;br&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>linux</category><guid>http://samsonwang.me/posts/linux-command-examples-top/</guid><pubDate>Thu, 14 Jun 2018 03:26:53 GMT</pubDate></item><item><title>云服务器安全相关配置</title><link>http://samsonwang.me/posts/cloud-server-security/</link><dc:creator>Samson Wang</dc:creator><description>&lt;p&gt;
我所租用的云服务器操作系统为CentOS Linux，在使用云服务器的过程中为了保证服务器的安全，进行了一些简单的配置，这样能够增加服务器被破解的难度。&lt;br&gt;
&lt;/p&gt;

&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;使用denyhosts防止暴力破解登录密码&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
登入服务器主要是使用用户名和密码，而且linux的root用户拥有最高权限。可以使用denyhosts，防止暴力破解用户名和密码。denyhosts的原理是在多次输入错误的用户名和密码时，屏蔽该登录ip，限制密码的尝试次数。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;安装denyhosts&lt;/b&gt;&lt;br&gt;
可以使用自带的包管理器安装denyhost，这样是比较方便的，后续的配置工作也会简单一些。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;yum install denyhosts
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
&lt;b&gt;编辑配置文件&lt;/b&gt;&lt;br&gt;
安装好denyhosts之后，它的默认配置文件为 &lt;code&gt;/etc/denyhosts.conf&lt;/code&gt; 。该配置文件有很好的注释，对于每个配置项的作用都有很好的说明。可能需要修改的相关配置项有如下几个。denyhosts可以分别配置root用户、普通用户、无效用户用户名的尝试次数。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;DENY_THRESHOLD_INVALID = 5
DENY_THRESHOLD_VALID = 10
DENY_THRESHOLD_ROOT = 5
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
&lt;b&gt;启动denyhosts&lt;/b&gt;&lt;br&gt;
使用以下命令启动denyhosts，查看denyhosts的运行状态。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;service denyhosts start
service denyhosts status
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
使用以下命令让denyhosts能够随系统自启动。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;chkconfig denyhosts on
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2" class="outline-2"&gt;
&lt;h2 id="sec-2"&gt;更改sshd的端口号&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
sshd的默认端口号为22，很多暴力破解程序会直接对该端口进行登录尝试，通过修改默认的sshd的端口号，可以增加破解难度。需要注意的是，在修改sshd端口号之后，自己使用shell工具登录服务器也需要端口号进行修改。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;编辑配置文件&lt;/b&gt;&lt;br&gt;
sshd的配置文件为 &lt;code&gt;/etc/ssh/sshd_config&lt;/code&gt; ，端口号配置为这一行 &lt;code&gt;# Port 22&lt;/code&gt; ，删去井号然后将22改为需要的端口号。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;重启sshd服务&lt;/b&gt;&lt;br&gt;
更改配置文件后，需要重启服务使配置文件生效。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;service sshd restart
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-3" class="outline-2"&gt;
&lt;h2 id="sec-3"&gt;使用 &lt;code&gt;last&lt;/code&gt; 和 &lt;code&gt;lastb&lt;/code&gt; 查看系统登录记录&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
&lt;code&gt;last&lt;/code&gt; 指令能够查看登录成功的记录，而 &lt;code&gt;lastb&lt;/code&gt; 指令能够查看登录失败的记录。通过查看登录失败的记录，能够判断出服务器是否有被暴力破解的记录。需要注意的是这两个命令均需要管理员权限才能够执行。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>linux</category><guid>http://samsonwang.me/posts/cloud-server-security/</guid><pubDate>Thu, 07 Jun 2018 06:12:38 GMT</pubDate></item><item><title>Linux常用命令行指令 - xargs</title><link>http://samsonwang.me/posts/linux-command-examples-xargs/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;基础用法&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
&lt;code&gt;xargs&lt;/code&gt; 指令默认情况下从 &lt;code&gt;stdin&lt;/code&gt; 中读取信息，按照空格分或换行区分开，并且执行输入的命令（默认的命令是 &lt;code&gt;/bin/echo&lt;/code&gt; ）。命令可以通过 &lt;code&gt;xargs&lt;/code&gt; 的参数指定执行一次或多次，命令的执行参数为自身初始参数追加上由 &lt;code&gt;stdin&lt;/code&gt; 读到的内容，命令在执行时会忽略空行。&lt;br&gt;
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;
xargs reads items from the standard input, delimited by blanks (which can be protected with double or single quotes or a backslash) or newlines, and executes the command (default is /bin/echo) one or more times with any initial-arguments followed by items read from standard input. Blank lines on the standard input are ignored.&lt;br&gt;
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;
在命令行输入 &lt;code&gt;xargs&lt;/code&gt; 命令，输入 “a b c d” 后按回车，再按 &lt;code&gt;ctrl+d&lt;/code&gt; 完成本次输入，则 &lt;code&gt;xargs&lt;/code&gt; 的默认 &lt;code&gt;echo&lt;/code&gt; 命令会将接收到的字符串打印出来，效果如下所示。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# xargs
a b c d
a b c d
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
&lt;code&gt;xargs&lt;/code&gt; 单独使用时功能比较单一，但是它与其他指令一起使用十分强大。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2" class="outline-2"&gt;
&lt;h2 id="sec-2"&gt;&lt;code&gt;xargs&lt;/code&gt; 与 &lt;code&gt;find&lt;/code&gt; 组合使用&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
常见的使用方法是使用 &lt;code&gt;find&lt;/code&gt; 指令找到指定的文件，组合以 &lt;code&gt;xargs&lt;/code&gt; 指令实现对指定文件的操作。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;find . -name "demo_" | xargs file -i
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
由于 &lt;code&gt;xargs&lt;/code&gt; 是使用空格作为各个参数的分隔符，如果遇到的文件名中含有空格，则并不能按照预期处理。可以使用 &lt;code&gt;find&lt;/code&gt; 指令的 &lt;code&gt;-print0&lt;/code&gt; 含有空格的文件名转化为 &lt;code&gt;\n&lt;/code&gt; 结尾的字符串，再配置 &lt;code&gt;xargs&lt;/code&gt; 的 &lt;code&gt;-0&lt;/code&gt; 参数就能完成文件名中含有空格的处理，改进后的命令如下。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;find . -name "demo_" -print0 | xargs -0 file -i
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-3" class="outline-2"&gt;
&lt;h2 id="sec-3"&gt;&lt;code&gt;xargs&lt;/code&gt; 与 &lt;code&gt;grep&lt;/code&gt; 组合使用&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
常用命令如下，能够实现对指定规则文件的搜索匹配。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;find . -name "*.log" | xargs grep error
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-4" class="outline-2"&gt;
&lt;h2 id="sec-4"&gt;使用 &lt;code&gt;-n&lt;/code&gt; 参数让 &lt;code&gt;xargs&lt;/code&gt; 的命令重复执行&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;p&gt;
如果想用 &lt;code&gt;find&lt;/code&gt; 指令完成多个匹配规则的搜索，则可以使用 &lt;code&gt;-n&lt;/code&gt; 参数将 &lt;code&gt;xargs&lt;/code&gt; 的内容分割成多个。&lt;br&gt;
下面的命令会执行3次 &lt;code&gt;find&lt;/code&gt; 命令， &lt;code&gt;xargs&lt;/code&gt; 会将接收的到的内容按照单词数为“1”分割，分3次传送给 &lt;code&gt;find&lt;/code&gt; 指令。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;echo "*.c" "*.cpp" "*.h" | xargs -n 1 find . -name
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-5" class="outline-2"&gt;
&lt;h2 id="sec-5"&gt;使用 &lt;code&gt;-t&lt;/code&gt; 参数让 &lt;code&gt;xargs&lt;/code&gt; 打印将要执行的命令&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-5"&gt;
&lt;p&gt;
让 &lt;code&gt;xargs&lt;/code&gt; 将指令的命令打印出来主要是方便查看命令执行情况，也方便在出现错误时进行调试。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;find . -name *.log | xargs -t rm -f
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-6" class="outline-2"&gt;
&lt;h2 id="sec-6"&gt;使用 &lt;code&gt;-p&lt;/code&gt; 参数让 &lt;code&gt;xargs&lt;/code&gt; 在执行命令前询问用户&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-6"&gt;
&lt;p&gt;
增加 &lt;code&gt;-p&lt;/code&gt; 参数后， &lt;code&gt;xargs&lt;/code&gt; 在每次执行命令前会将指令打印出来并询问用户，只有用户输入 “y” 时才会真正执行该条命令。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;echo "*.c" "*.cpp" "*.h" | xargs -n 1 -p find . -name
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-7" class="outline-2"&gt;
&lt;h2 id="sec-7"&gt;使用 &lt;code&gt;-I&lt;/code&gt; 参数让 &lt;code&gt;xargs&lt;/code&gt; 进行参数替换&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-7"&gt;
&lt;p&gt;
&lt;code&gt;xargs&lt;/code&gt; 默认会将读取到的内容追加在指令命令后面作为参数，使用 &lt;code&gt;-I&lt;/code&gt; 参数能够控制命令参数的组合方式。&lt;br&gt;
以下命令会将当前目录中的可执行文件移动到bin文件夹下。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;find . -executable -type f -print0 | xargs -0 -I {} mv {} ./bin
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-8" class="outline-2"&gt;
&lt;h2 id="sec-8"&gt;参考资料&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-8"&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;a href="http://man7.org/linux/man-pages/man1/xargs.1.html"&gt;http://man7.org/linux/man-pages/man1/xargs.1.html&lt;/a&gt;&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.howtoforge.com/tutorial/linux-xargs-command/"&gt;https://www.howtoforge.com/tutorial/linux-xargs-command/&lt;/a&gt;&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.thegeekstuff.com/2013/12/xargs-examples"&gt;https://www.thegeekstuff.com/2013/12/xargs-examples&lt;/a&gt;&lt;br&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>linux</category><guid>http://samsonwang.me/posts/linux-command-examples-xargs/</guid><pubDate>Fri, 27 Apr 2018 06:03:39 GMT</pubDate></item><item><title>Linux常用命令行指令 - ipcs</title><link>http://samsonwang.me/posts/linux-command-examples-ipcs/</link><dc:creator>Samson Wang</dc:creator><description>&lt;p&gt;
&lt;code&gt;IPC&lt;/code&gt; 是 &lt;code&gt;inter process communication&lt;/code&gt; 的缩写，这项技术能够让进程间相互通信。&lt;br&gt;
Q：每个进程都有自己的地址空间和独立的用户空间，那么进程间是如何通信的呢？&lt;br&gt;
A：内核，也就是操作系统的心脏，它能够访问整个操作系统的内存。我们可以要求内核分配一块用于进程间交互的空间。&lt;br&gt;
&lt;/p&gt;

&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;几种进程间通信的方法&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
进程间通信的方法有很多，有些支持同机器上进程的信息交互，有些支持跨机器的进程交互。&lt;br&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;管道&lt;/b&gt; ： pipes，管道提供了进程间交换信息的方法。&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;&lt;b&gt;共享内存&lt;/b&gt; ： shared memory，一个进程创建一块其他进程能够访问的内存空间，多个进程可以通过共享内存进行数据交换。&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;&lt;b&gt;消息队列&lt;/b&gt; ： message queue，消息队列是一个固定结构、有序的内存段，多个进程可以存放和取回数据。&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;&lt;b&gt;信号量&lt;/b&gt; ： semaphores，信号量提供了多进程访问同一资源的同步机制，信号量不负责传递数据，它协调对共享资源的访问。&lt;br&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2" class="outline-2"&gt;
&lt;h2 id="sec-2"&gt;常用ipcs指令&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
&lt;b&gt;列出所有的IPC设备&lt;/b&gt;&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ipcs -a
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
&lt;b&gt;列出所有的消息队列&lt;/b&gt;&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ipcs -q
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
&lt;b&gt;列出所有的信号量&lt;/b&gt;&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ipcs -s
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
&lt;b&gt;列出所有的共享内存&lt;/b&gt;&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ipcs -m
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
&lt;b&gt;获取与IPC设备信息&lt;/b&gt;&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ipcs -q -i msq_id
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
&lt;b&gt;列出IPC设备的限制&lt;/b&gt;&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ipcs -l
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
&lt;b&gt;列出IPC设备的创建者和拥有者&lt;/b&gt;&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ipcs -m -c
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
&lt;b&gt;列出最近使用IPC设备的进程id&lt;/b&gt;&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ipcs -m -p
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
&lt;b&gt;列出IPC设备的最后访问时间&lt;/b&gt;&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ipcs -s -t
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
&lt;b&gt;列出IPC设备的当前使用状态&lt;/b&gt;&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ipcs -u
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>ipc</category><category>linux</category><guid>http://samsonwang.me/posts/linux-command-examples-ipcs/</guid><pubDate>Wed, 25 Apr 2018 13:37:51 GMT</pubDate></item><item><title>使用gdb调试多线程程序</title><link>http://samsonwang.me/posts/debug-with-gdb-on-multi-thread-programs/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;查看当前线程信息&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
&lt;b&gt;将进程中的各个线程信息显示出来&lt;/b&gt;&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(gdb) info threads
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
&lt;b&gt;切换到指定进程&lt;/b&gt;&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(gdb) thread tid
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
&lt;b&gt;向指定的线程发送自定的指令&lt;/b&gt;&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(gdb) thread apply tid/all args
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
常用的指定是查看所有线程的调用堆栈 &lt;code&gt;thread apply all bt&lt;/code&gt; ，这个指令与 &lt;code&gt;pstack&lt;/code&gt; 命令有些相似。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;gdb默认会自动捕捉新产生线程&lt;/b&gt;&lt;br&gt;
会在产生一个新的线程时会显示出LWP的字样提示用户，LWP = light weight process&lt;br&gt;
可以设置gdb是否提示线程相关的事件&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(gdb) set print thread-events on/off
(gdb) show print thread-events
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2" class="outline-2"&gt;
&lt;h2 id="sec-2"&gt;为指定的线程设置断点&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
含有多线程的程序，可以为单独的线程设置断点&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(gdb) break linespec thread tid
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
任何时候当你的程序在GDB模式下停止的时候，包括当前调试线程的所有线程都会停下来，不会对继续对当前进程造成更改。这时你可以在线程间进行切换，查看整个进程的执行状况。&lt;br&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
Whenever your program stops under GDB for any reason, all threads of execution stop, not just the current thread. This allows you to examine the overall state of the program, including switching between threads, without worrying that things may change underfoot.&lt;br&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-3" class="outline-2"&gt;
&lt;h2 id="sec-3"&gt;防止gdb自动切换线程&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
在调试gdb程序时，在单步执行时，会出现线程间跳转切换，这样对跟踪代码执行状态十分不方便。&lt;br&gt;
可以通过设置 &lt;code&gt;scheduler-locking&lt;/code&gt; 让gdb在所调试的线程中运行，防止线程的自动切换。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(gdb) set scheduler-locking step
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
可以执行以下命令查看当前 &lt;code&gt;scheduler-locking&lt;/code&gt; 的设置&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(gdb) show scheduler-locking
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
&lt;code&gt;scheduler-locking&lt;/code&gt; 有三种模式&lt;br&gt;
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;code&gt;off&lt;/code&gt; 任何线程在任何时候都能执行&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;on&lt;/code&gt; 只有当前线程能够执行&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;step&lt;/code&gt; 为单步执行优化的模式，比较适合一般的调试&lt;br&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;
Set the scheduler locking mode. If it is off, then there is no locking and any thread may run at any time. If on, then only the current thread may run when the inferior is resumed. The step mode optimizes for single-stepping. It stops other threads from "seizing the prompt" by preempting the current thread while you are stepping. Other threads will only rarely (or never) get a chance to run when you step. They are more likely to run when you `next' over a function call, and they are completely free to run when you use commands like `continue', `until', or `finish'. However, unless another thread hits a breakpoint during its timeslice, they will never steal the GDB prompt away from the thread that you are debugging.&lt;br&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-sec-4" class="outline-2"&gt;
&lt;h2 id="sec-4"&gt;参考资料&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;a href="https://ftp.gnu.org/old-gnu/Manuals/gdb/html_node/gdb_39.html"&gt;gnu manual 1&lt;/a&gt;&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://ftp.gnu.org/old-gnu/Manuals/gdb/html_node/gdb_24.html"&gt;gun manual 2&lt;/a&gt;&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://sourceware.org/gdb/onlinedocs/gdb/Threads.html"&gt;sourceware gdb onlinedocs&lt;/a&gt;&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.drdobbs.com/cpp/multithreaded-debugging-techniques/199200938?pgno=1"&gt;drdobbs.com&lt;/a&gt;&lt;br&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>gdb</category><category>linux</category><guid>http://samsonwang.me/posts/debug-with-gdb-on-multi-thread-programs/</guid><pubDate>Fri, 20 Apr 2018 13:25:09 GMT</pubDate></item><item><title>在gdb调试时忽略系统信号（signal）</title><link>http://samsonwang.me/posts/gdb-ignore-received-signal/</link><dc:creator>Samson Wang</dc:creator><description>&lt;p&gt;
在gdb调试程序时，默认情况下gdb在收到信号时会中断程序的运行，并将收到的信号显示出来。这时，可以选择输入 &lt;code&gt;c&lt;/code&gt; ( &lt;code&gt;continue&lt;/code&gt; )让程序继续运行。如果程序会重复收到这信号，会非常影响调试效率。可以通过配置忽略指定的系统信号。&lt;br&gt;
查看当前系统信号的处理信息的指令&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(gdb) info signal
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
以调试网络程序为例，进程会经常收到 &lt;code&gt;SIGPIPE&lt;/code&gt; 消息，对于网络进程的 &lt;code&gt;SIGPIPE&lt;/code&gt; 消息在程序中会由自身处理，可以使用以下指令让gdb不再提示 &lt;code&gt;SIGPIPE&lt;/code&gt; 信号。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(gdb) handle SIGPIPE nostop noprint
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
参考资料： &lt;a href="ftp://ftp.gnu.org/old-gnu/Manuals/gdb/html_node/gdb_38.html"&gt;gnu gdb manual&lt;/a&gt;&lt;br&gt;
&lt;/p&gt;</description><category>gdb</category><category>linux</category><guid>http://samsonwang.me/posts/gdb-ignore-received-signal/</guid><pubDate>Thu, 19 Apr 2018 08:00:47 GMT</pubDate></item><item><title>Linux常用命令行指令 - scp</title><link>http://samsonwang.me/posts/linux-command-examples-scp/</link><dc:creator>Samson Wang</dc:creator><description>&lt;p&gt;
&lt;code&gt;scp&lt;/code&gt; 命令代表的是 secure copy，与 &lt;code&gt;cp&lt;/code&gt; 命令的本地拷贝十分相似，主要区别就在于 &lt;code&gt;scp&lt;/code&gt; 的路径可以是一个远程机器的路径。使用 &lt;code&gt;scp&lt;/code&gt; 进行文件拷贝时，文件的传输时加密的。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cp source_path dest_path
&lt;/pre&gt;&lt;/div&gt;

&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;从远程机器向本地拷贝&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
以下命令会把 &lt;code&gt;host&lt;/code&gt; 主机上的 &lt;code&gt;src_path&lt;/code&gt; 文件拷贝到本地 &lt;code&gt;dest_path&lt;/code&gt; 目录中。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;scp user@host:src_path dest_path
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2" class="outline-2"&gt;
&lt;h2 id="sec-2"&gt;从本地向远程机器拷贝&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
以下命令会把本地 &lt;code&gt;src_path&lt;/code&gt; 的文件拷贝打 &lt;code&gt;host&lt;/code&gt; 主机上的 &lt;code&gt;dest_path&lt;/code&gt; 路径上。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;scp src_path user@host:dest_path
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-3" class="outline-2"&gt;
&lt;h2 id="sec-3"&gt;拷贝目录下的所有文件&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
可以使用 &lt;code&gt;-r&lt;/code&gt; 参数完成目录的递归拷贝， &lt;code&gt;r&lt;/code&gt; 代表 &lt;code&gt;recursive&lt;/code&gt; 递归。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;scp -r user@host:/src_path dest_path
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-4" class="outline-2"&gt;
&lt;h2 id="sec-4"&gt;在拷贝时限制带宽&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;p&gt;
可以使用 &lt;code&gt;-l&lt;/code&gt; 参数限制传输的带宽， &lt;code&gt;l&lt;/code&gt; 代表 &lt;code&gt;limit&lt;/code&gt; 限制，限制带宽的单位是 &lt;code&gt;kbps&lt;/code&gt; 。&lt;br&gt;
命令会在将拷贝传输的速度限制为 100kbps。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;scp -l 100 src_path dest_path
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>linux</category><guid>http://samsonwang.me/posts/linux-command-examples-scp/</guid><pubDate>Tue, 17 Apr 2018 08:08:06 GMT</pubDate></item><item><title>Linux下的FIFO、pipe、unix domain socket漫谈</title><link>http://samsonwang.me/posts/fifo-pipe-unix-domain-socket/</link><dc:creator>Samson Wang</dc:creator><description>&lt;p&gt;
在做Linux开发时，经常会接触 &lt;code&gt;管道&lt;/code&gt; 、 &lt;code&gt;AF_UNIX&lt;/code&gt; 等相关词汇，为了弄清他们之间的关系，查阅了一些资料，将结果整理并记录下来。&lt;br&gt;
&lt;/p&gt;

&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;1. &lt;code&gt;FIFO&lt;/code&gt; 与 &lt;code&gt;pipe&lt;/code&gt; 的比较&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
FIFO可以通过 &lt;code&gt;mkfifo fifo_file&lt;/code&gt; 在本地创建一个文件用来表示一个管道，数据的交换是在操作系统内核完成的，所以在文件中没有内容。&lt;br&gt;
FIFO可以看做是一个带有名字的管道，我们在命令行中使用的管道是匿名管道。&lt;br&gt;
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;
A FIFO special file (a named pipe) is similar to a pipe, except that it is accessed as part of the file system. It can be opened by multiple processes for reading or writing. When processes are exchanging data via the FIFO, the kernel passes all data internally without writing it to the file system. Thus, the FIFO special file has no contents on the file system; the file system entry merely serves as a reference point so that processes can access the pipe using a name in the file system.&lt;br&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
以上内容截取自Linux的帮助文档（ &lt;code&gt;man fifo&lt;/code&gt; ）&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2" class="outline-2"&gt;
&lt;h2 id="sec-2"&gt;2. &lt;code&gt;FIFO&lt;/code&gt; 与 &lt;code&gt;unix domain socket&lt;/code&gt; 的比较&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
FIFO与unix domain socket在他们的实现方式上有相似之处，但是他们是完全不同的两个概念。&lt;br&gt;
FIFO是更底层的进程间通信方式，允许一端写入数据，另外一端读取数据；unix domain socket与 &lt;code&gt;TCP/IP&lt;/code&gt; 的套接字很相似。&lt;br&gt;
socket是双工的，支持多个进程同时访问。进程可以一个socket上同时允许多个客户端进程接入。在每次有新的 &lt;code&gt;connect&lt;/code&gt; 或 ~accept~时， 操作系统内核会分配一个新的文件描述符，通信数据包会送达正确的进程。&lt;br&gt;
FIFO并不支持以上特性。需要两个FIFO才能完成双工通信。对于每个客户端都需要一对FIFO才能完成通信交互。&lt;br&gt;
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;
UNIX domain sockets and FIFO may share some part of their implementation but they are conceptually very different. FIFO functions at a very low level. One process writes bytes into the pipe and another one reads from it. A UNIX domain socket has the same behaviour as a TCP/IP socket.&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
A socket is bidirectional and can be used by a lot of processes simultaneously. A process can accept many connections on the same socket and attend several clients simultaneously. The kernel delivers a new file descriptor each time connect(2) or accept(2) is called on the socket. The packets will always go to the right process.&lt;br&gt;
On a FIFO, this would be impossible. For bidirectional comunication, you need two FIFOs, and you need a pair of FIFOs for each of your clients. There is no way of writing or reading in a selective way, because they are a much more primitive way to communicate.&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
Anonymous pipes and FIFOs are very similar. The difference is that anonymous pipes don't exist as files on the filesystem so no process can open(2) it. They are used by processes that share them by another method. If a process opens a FIFOs and then performs, for example, a fork(2), its child will inherit its file descriptors and, among them, the pipe.&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
The UNIX domain sockets, anonymous pipes and FIFOs are similar in the fact they use shared memory segments. The details of implementation may vary from one system to another but the idea is always the same: attach the same portion of memory in two distinct processes memory mapping to have them sharing data&lt;br&gt;
(edit: that would one obvious way to implement it but that is not how it is actually done in Linux, which simply uses the kernel memory for the buffers, see answer by @tjb63 below).&lt;br&gt;
The kernel then handles the system calls and abstracts the mechanism.&lt;br&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
以上内容截取自 &lt;a href="https://unix.stackexchange.com/questions/75904/are-fifo-pipe-unix-domain-socket-the-same-thing-in-linux-kernel"&gt;unix stackexchange&lt;/a&gt;&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-3" class="outline-2"&gt;
&lt;h2 id="sec-3"&gt;3. &lt;code&gt;unix-domain-socket&lt;/code&gt; 与 &lt;code&gt;ip socket&lt;/code&gt; 的比较&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
unix domain socket是一种进程间通信方式，支持跑在同一个机器上的两个进程的双向数据交互。&lt;br&gt;
ip socket是一种网络通信方式，能够让两个进程通过网络完成数据交互。&lt;br&gt;
unix domain socket是针对于文件系统限制访问权限，而ip socket只能在过滤包的级别完成访问控制。&lt;br&gt;
unix domain socket比ip socket的效率更高，因为省去了校验检查、路由等操作步骤。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
参考资料如下：&lt;br&gt;
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;a href="https://unix.stackexchange.com/questions/236983/differences-between-unix-domain-sockets-and-network-sockets?utm_medium=organic&amp;amp;utm_source=google_rich_qa&amp;amp;utm_campaign=google_rich_qa"&gt;unix stackexchange&lt;/a&gt;&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://lists.freebsd.org/pipermail/freebsd-performance/2005-February/001143.html"&gt;lists freebsd&lt;/a&gt;&lt;br&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;
There are a few differences that might be of interest, in addition to the&lt;br&gt;
already pointed out difference that if you start out using IP sockets, you&lt;br&gt;
don't have to migrate to them later when you want inter-machine&lt;br&gt;
connectivity:&lt;br&gt;
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;UNIX domain sockets use the file system as the address name space.  This&lt;br&gt;
means you can use UNIX file permissions to control access to communicate&lt;br&gt;
with them.  I.e., you can limit what other processes can connect to the&lt;br&gt;
daemon – maybe one user can, but the web server can't, or the like.&lt;br&gt;
With IP sockets, the ability to connect to your daemon is exposed off&lt;br&gt;
the current system, so additional steps may have to be taken for&lt;br&gt;
security.  On the other hand, you get network transparency.  With UNIX&lt;br&gt;
domain sockets, you can actually retrieve the credential of the process&lt;br&gt;
that created the remote socket, and use that for access control also,&lt;br&gt;
which can be quite convenient on multi-user systems.&lt;br&gt;
&lt;/li&gt;

&lt;li&gt;IP sockets over localhost are basically looped back network on-the-wire&lt;br&gt;
IP.  There is intentionally "no special knowledge" of the fact that the&lt;br&gt;
connection is to the same system, so no effort is made to bypass the&lt;br&gt;
normal IP stack mechanisms for performance reasons.  For example,&lt;br&gt;
transmission over TCP will always involve two context switches to get to&lt;br&gt;
the remote socket, as you have to switch through the netisr, which&lt;br&gt;
occurs following the "loopback" of the packet through the synthetic&lt;br&gt;
loopback interface.  Likewise, you get all the overhead of ACKs, TCP&lt;br&gt;
flow control, encapsulation/decapsulation, etc.  Routing will be&lt;br&gt;
performed in order to decide if the packets go to the localhost.&lt;br&gt;
Large sends will have to be broken down into MTU-size datagrams, which&lt;br&gt;
also adds overhead for large writes.  It's really TCP, it just goes over&lt;br&gt;
a loopback interface by virtue of a special address, or discovering that&lt;br&gt;
the address requested is served locally rather than over an ethernet&lt;br&gt;
(etc).&lt;br&gt;
&lt;/li&gt;

&lt;li&gt;UNIX domain sockets have explicit knowledge that they're executing on&lt;br&gt;
the same system.  They avoid the extra context switch through the&lt;br&gt;
netisr, and a sending thread will write the stream or datagrams directly&lt;br&gt;
into the receiving socket buffer.  No checksums are calculated, no&lt;br&gt;
headers are inserted, no routing is performed, etc.  Because they have&lt;br&gt;
access to the remote socket buffer, they can also directly provide&lt;br&gt;
feedback to the sender when it is filling, or more importantly,&lt;br&gt;
emptying, rather than having the added overhead of explicit&lt;br&gt;
acknowledgement and window changes.  The one piece of functionality that&lt;br&gt;
UNIX domain sockets don't provide that TCP does is out-of-band data.  In&lt;br&gt;
practice, this is an issue for almost noone.&lt;br&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
In general, the argument for implementing over TCP is that it gives you&lt;br&gt;
location independence and immediate portability – you can move the client&lt;br&gt;
or the daemon, update an address, and it will "just work".  The sockets&lt;br&gt;
layer provides a reasonable abstraction of communications services, so&lt;br&gt;
it's not hard to write an application so that the connection/binding&lt;br&gt;
portion knows about TCP and UNIX domain sockets, and all the rest just&lt;br&gt;
uses the socket it's given.  So if you're looking for performance locally,&lt;br&gt;
I think UNIX domain sockets probably best meet your need.  Many people&lt;br&gt;
will code to TCP anyway because performance is often less critical, and&lt;br&gt;
the network portability benefit is substantial.&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
Right now, the UNIX domain socket code is covered by a subsystem lock; I&lt;br&gt;
have a version that used more fine-grain locking, but have not yet&lt;br&gt;
evaluated the performance impact of those changes.  I've you're running in&lt;br&gt;
an SMP environment with four processors, it could be that those changes&lt;br&gt;
might positively impact performance, so if you'd like the patches, let me&lt;br&gt;
know.  Right now they're on my schedule to start testing, but not on the&lt;br&gt;
path for inclusion in FreeBSD 5.4.  The primary benefit of greater&lt;br&gt;
granularity would be if you had many pairs of threads/processes&lt;br&gt;
communicating across processors using UNIX domain sockets, and as a result&lt;br&gt;
there was substantial contention on the UNIX domain socket subsystem lock.&lt;br&gt;
The patches don't increase the cost of normal send/receive operations, but&lt;br&gt;
due add extra mutex operations in the listen/accept/connect/bind paths.&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
Robert N M Watson&lt;br&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>linux</category><guid>http://samsonwang.me/posts/fifo-pipe-unix-domain-socket/</guid><pubDate>Wed, 11 Apr 2018 05:03:25 GMT</pubDate></item><item><title>Linux下使用gdb的调试技巧（2）</title><link>http://samsonwang.me/posts/debug-with-gdb-on-linux-2/</link><dc:creator>Samson Wang</dc:creator><description>&lt;p&gt;
相关文章：&lt;a href="https://samsonwang.me/posts/debug-with-gdb-on-linux/"&gt;Linux下使用gdb的调试技巧（1）&lt;/a&gt;&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
本文重点介绍在gdb模式下的常用命令。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
查看帮助信息&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(gdb) help all
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
查看线程信息&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(gdb) info thread
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
切换到某一线程&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(gdb) thread 2
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
查看调用堆栈信息&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(gdb) bt
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
查看某个调用栈&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(gdb) frame 3
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
增加断点&lt;br&gt;
断点格式：&lt;br&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;函数名&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;文件名：行号&lt;br&gt;
&lt;/li&gt;
&lt;li&gt;当前调试文件的行号&lt;br&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(gdb) breakpoint xxx
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
删除断点&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(gdb) delete xxx
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
启用/禁用断点&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(gdb) disable/enable xxx
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
查看断点信息&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(gdb) info break
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
临时断点，临时断点的使用方法与普通断点相同&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(gdb) tb xxx
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
在gdb模式下，回车会执行上一次输入的命令&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
运行到指定行&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;until 81
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
在gdb中打印长字符串&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(gdb) set print element 0
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
在gdb中强制在一个线程内调试运行&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;set scheduler-locking step
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
在gdb中向程序发送信号&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(gdb) signal
&lt;/pre&gt;&lt;/div&gt;</description><category>gdb</category><category>linux</category><guid>http://samsonwang.me/posts/debug-with-gdb-on-linux-2/</guid><pubDate>Tue, 03 Apr 2018 14:51:39 GMT</pubDate></item></channel></rss>