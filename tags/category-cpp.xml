<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="/assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Hack Note (Posts about cpp)</title><link>https://samsonwang.me/</link><description></description><atom:link href="https://samsonwang.me/tags/category-cpp.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2017-2019 &lt;a href="mailto:wangzhilv@gmail.com"&gt;Samson Wang&lt;/a&gt; 
&lt;a rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/"&gt;&lt;img alt="知识共享许可协议" style="padding-bottom:2px" src="https://i.creativecommons.org/l/by-nc/4.0/80x15.png" /&gt;&lt;/a&gt;
</copyright><lastBuildDate>Wed, 13 Mar 2019 08:02:31 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>深入探索C++内存模型（1）</title><link>https://samsonwang.me/posts/inside-the-cpp-object-model-1/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div&gt;&lt;p&gt;
最近花时间读了一下《深入探索C++内存模型》，这本带我了解到了更底层的C++知识。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
这本书从C++语言各种特性的实现机制上进行细致剖析，进而总结出对软件开发具有指导意义的经验和结论。这本书的目标群体是具有开发经验的中高级开发人员，其内容的专业性是不容质疑的。从我的阅读感受上讲，它相对比那些一般的技术文档要耗时耗力。全书共三百多页，粗略地估算了一下，我却用了一个月的空余时间才读完。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
我会将读书笔记整理成博文，这样能够加深记忆，也方便以后查阅。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://samsonwang.me/posts/inside-the-cpp-object-model-1/"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>cpp</category><category>digest</category><category>Lippman</category><category>memory layout</category><category>object model</category><guid>https://samsonwang.me/posts/inside-the-cpp-object-model-1/</guid><pubDate>Mon, 11 Mar 2019 02:30:13 GMT</pubDate></item><item><title>C++(Qt)和Python混合编程的一些经验之谈</title><link>https://samsonwang.me/posts/cpp-python-hybird-programming/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div&gt;&lt;p&gt;
在Launchy的开发中，我使用了Python作为Qt程序的插件开发语言，最近有朋友问我Qt和Python结合使用的一些细节。结合我之前踩坑的经历，C++（Qt）和Python的混合编程可以从几个方面进行考虑。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://samsonwang.me/posts/cpp-python-hybird-programming/"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>cpp</category><category>launchy</category><category>python</category><category>qt</category><guid>https://samsonwang.me/posts/cpp-python-hybird-programming/</guid><pubDate>Fri, 01 Feb 2019 00:53:37 GMT</pubDate></item><item><title>线程API总结</title><link>https://samsonwang.me/posts/thread-api-cheatsheet/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div&gt;&lt;p&gt;
线程的使用在软件开发中是十分普遍的，本文总结了两种常用的线程API接口：POSIX线程和CPP11线程。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://samsonwang.me/posts/thread-api-cheatsheet/"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>cpp</category><category>cpp11</category><category>linux</category><category>posix</category><category>thread</category><guid>https://samsonwang.me/posts/thread-api-cheatsheet/</guid><pubDate>Mon, 14 Jan 2019 02:50:31 GMT</pubDate></item><item><title>C++常用的时间接口</title><link>https://samsonwang.me/posts/cpp-time-cheatsheet/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div&gt;&lt;p&gt;
与时间相关的操作在开发中是十分常见的，本文总结了常用时间接口，并给出了示例代码。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://samsonwang.me/posts/cpp-time-cheatsheet/"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>chrono</category><category>cpp</category><category>cpp11</category><category>time</category><guid>https://samsonwang.me/posts/cpp-time-cheatsheet/</guid><pubDate>Fri, 04 Jan 2019 08:05:56 GMT</pubDate></item><item><title>C++中的智能指针</title><link>https://samsonwang.me/posts/smart-pointers-in-cpp/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div&gt;&lt;p&gt;
C++中有很多智能指针如 &lt;code&gt;unique_ptr&lt;/code&gt; 和 &lt;code&gt;shared_ptr&lt;/code&gt; ，本篇文章主要介绍这些指针的功能和应用场景。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://samsonwang.me/posts/smart-pointers-in-cpp/"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>cpp</category><category>shared_ptr</category><category>smart pointer</category><category>unique_ptr</category><guid>https://samsonwang.me/posts/smart-pointers-in-cpp/</guid><pubDate>Wed, 28 Nov 2018 15:51:57 GMT</pubDate></item><item><title>静态成员变量初始化相关问题</title><link>https://samsonwang.me/posts/static-member-initialization-and-private-member-function/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div id="outline-container-orgf946421" class="outline-2"&gt;
&lt;h2 id="orgf946421"&gt;引言&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgf946421"&gt;
&lt;p&gt;
这篇文章的起因是出于对于 &lt;code&gt;C++&lt;/code&gt; 饿汉单例模式代码的一些疑问，查阅了一些资料。在仔细研究后，我发现在一些基础概念的理解还是存在偏差。&lt;br&gt;
下面请看这样的一段代码，能看出其中有那些不太“正常”的语句么。&lt;br&gt;
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Singleton&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;Singleton&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;getInstance&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;Singleton&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;Singleton&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;instance&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="n"&gt;Singleton&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;Singleton&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;instance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Singleton&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;Singleton&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;Singleton&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;getInstance&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;instance&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgc156f51" class="outline-2"&gt;
&lt;h2 id="orgc156f51"&gt;私有静态成员的初始化&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgc156f51"&gt;
&lt;p&gt;
上面的代码是饿汉单例模式的 &lt;code&gt;C++&lt;/code&gt; 的实现，在没有查阅资料之前，我对其中私有静态成员变量的初始化存疑。主要有以下两点：&lt;br&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;为什么私有变量能够在类外被修改&lt;br&gt;&lt;/li&gt;
&lt;li&gt;为什么私有构造函数能够在类外被调用&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
在我之前的知识积累中， &lt;b&gt;私有的成员变量或成员函数是不能够在类外被访问的&lt;/b&gt; 。那么为什么以上代码没有问题呢？&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
在C++标准中找到了下面的一段话(可以在 &lt;a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3690.pdf"&gt;C++11 standard&lt;/a&gt; 的 9.4.2节 或  &lt;a href="http://eel.is/c++draft/class.static.data#2"&gt;C++ standard working draft&lt;/a&gt; 的 10.3.9.2节 中找到)&lt;br&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
The initializer expression in the definition of a static data member is in the scope of its class.&lt;br&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
这句话的意思是：静态成员变量的初始化是被看做为它自身的类域中的（ &lt;del&gt;翻译的可能不是很准&lt;/del&gt; ）。这样就不难理解为什么私有的静态成员变量能够在其类外被初始化了，由其私有构造函数进行构造也能说的通了。&lt;br&gt;
&lt;/p&gt;


&lt;p&gt;
&lt;b&gt;同样&lt;/b&gt; ,在C++标准中给出了下面这样的示例代码：&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;process&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;run_chain&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;running&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="n"&gt;process&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;running&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;get_main&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;process&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;run_chain&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;running&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
给出的说明如下：&lt;br&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
The static data member &lt;code&gt;run_chain&lt;/code&gt; of class process is defined in global scope; the notation &lt;code&gt;process​::​run_chain&lt;/code&gt; specifies that the member &lt;code&gt;run_chain&lt;/code&gt; is a member of class &lt;code&gt;process&lt;/code&gt; and in the scope of class &lt;code&gt;process&lt;/code&gt;. In the static data member definition, the initializer expression refers to the static data member running of class &lt;code&gt;process&lt;/code&gt;.&lt;br&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
静态成员 &lt;code&gt;run_chain&lt;/code&gt; 定义在全局域；而 &lt;code&gt;process::run_chain&lt;/code&gt; 则表示 &lt;code&gt;run_chain&lt;/code&gt; 是 &lt;code&gt;process&lt;/code&gt; 类的成员变量，从而处在 &lt;code&gt;process&lt;/code&gt; 类的作用域中。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org4d75ce1" class="outline-2"&gt;
&lt;h2 id="org4d75ce1"&gt;私有构造函数&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org4d75ce1"&gt;
&lt;p&gt;
在查阅资料时，我发现 Peter 的 &lt;a href="https://stackoverflow.com/a/41361967"&gt;描述&lt;/a&gt; 纠正了我对私有构造函数的一些看法。&lt;br&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
The point of a &lt;code&gt;private&lt;/code&gt; constructor is not preventing object construction. It is about controlling which code can access the constructor, and therefore limiting which code to create an object that is an instance of that class. A &lt;code&gt;private&lt;/code&gt; constructor is accessible to all member functions ( &lt;code&gt;static&lt;/code&gt; or otherwise) of the class, and to all declared &lt;code&gt;friend&lt;/code&gt; s of the class (which may be individual functions, or other classes) - so any of those can create an instance of the class using a &lt;code&gt;private&lt;/code&gt; constructor (assuming the constructor is defined).&lt;br&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
私有构造函数的目的并不是禁止对象构造，其目的在于控制哪些代码能够调用这个构造函数，进而限制类对象的创建。私有的构造函数可以被该类的所有成员函数（静态或非静态的）调用，该类的友元类或友元方法也能访问该类的私有函数，所以在上述情况中都可以通过私有的构造函数实例化出类对象。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgeeeb949" class="outline-2"&gt;
&lt;h2 id="orgeeeb949"&gt;参考资料&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgeeeb949"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3690.pdf"&gt;ISO C++11 standard&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://eel.is/c++draft/class.static.data#2"&gt;ISO C++ standard working draft&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/38583989/access-to-private-static-function-during-static-member-initialization"&gt;stackoverflow.com - access to private static function…&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/41361223/why-private-constructor-prevents-object-creation-c"&gt;stackoverflow.com - private constructor&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/7857989/static-member-variable-when-declared-private"&gt;stackoverflow.com - static member variable when declared private&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.cppreference.com/w/cpp/language/static#Static_data_members"&gt;cppreference.com - static data members&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>cpp</category><category>syntax</category><guid>https://samsonwang.me/posts/static-member-initialization-and-private-member-function/</guid><pubDate>Tue, 04 Sep 2018 15:37:37 GMT</pubDate></item><item><title>libshmcache源码阅读笔记</title><link>https://samsonwang.me/posts/notes-on-libshmcache/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div id="outline-container-org45d04df" class="outline-2"&gt;
&lt;h2 id="org45d04df"&gt;引言&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org45d04df"&gt;
&lt;p&gt;
由于在工作中需要开发一套内存缓存服务，使用了共享内存作为多进程间的数据共享。为了提高共享内存缓存服务的性能，我找了一个类似的较为成熟的开源项目 &lt;a href="https://github.com/happyfish100/libshmcache"&gt;libshmcache&lt;/a&gt; ，通过研究源码学习其中的优点并改进自己的模块。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
libshmcache与redis相似的是都使用内存进行数据缓存；与redis不同的是，redis使用的进程自己申请的动态内存，而libshmcache使用的是共享内存。使用共享内存就意味着libshmcache主要的应用场景是同一台主机上的数据缓存。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
我花了一周时间阅读了比较感兴趣的部分代码，收获不少，现就以下几个方面总结一下自己的心得：&lt;br&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;纯C语言开发的代码风格&lt;br&gt;&lt;/li&gt;
&lt;li&gt;hash table的原理和实现&lt;br&gt;&lt;/li&gt;
&lt;li&gt;gcc原子化操作接口&lt;br&gt;&lt;/li&gt;
&lt;li&gt;有锁写和无锁读的实现细节&lt;br&gt;&lt;/li&gt;
&lt;li&gt;共享内存的两套函数接口(POSIX和SystemV)&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-orgf565821" class="outline-2"&gt;
&lt;h2 id="orgf565821"&gt;纯C语言开发时的代码风格&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgf565821"&gt;
&lt;p&gt;
我在工作中使用比较多的开发语言是C++，对于C语言编写的这样规模的项目，还是第一次仔细深入地研究。C语言使用 &lt;code&gt;struct&lt;/code&gt; 作为大多数自定义数据结构的关键字，相对于C++能够使用成员函数能够对类进行功能拓展，C语言比较常用的是将这个对象作为输入参数传到函数中。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
纵观所有项目代码，我感受比较深的就是使用结构体中嵌套匿名结构体，这样做能够增强数据结构的层次感，示例代码如下：&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;shmcache_context&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;pid_t&lt;/span&gt; &lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;lock_fd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;//for file lock&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;detect_deadlock_clocks&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;shmcache_config&lt;/span&gt; &lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;shm_memory_info&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;memory&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
	&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;shmcache_segment_info&lt;/span&gt; &lt;span class="n"&gt;hashtable&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
	&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
	    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
	    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;shmcache_segment_info&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
	&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;values&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;segments&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;shmcache_value_allocator_context&lt;/span&gt; &lt;span class="n"&gt;value_allocator&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;shmcache_list&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;//for value recycle&lt;/span&gt;
    &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;create_segment&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;//if check segment size                                  &lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
注意 &lt;code&gt;shmcache_context&lt;/code&gt; 中的匿名结构体 &lt;code&gt;segments&lt;/code&gt; 和 &lt;code&gt;values&lt;/code&gt; ，这样的写法体现了相互包含关系，也使后续的操作该数据结构的语句更加容易理解。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
另外对于联合体和位域这两种技术也是我在之前开发中使用比较少的，通过阅读源码能够让我对其有了更深刻的理解。示例代码如下：&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;union&lt;/span&gt; &lt;span class="n"&gt;shm_hentry_offset&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int64_t&lt;/span&gt; &lt;span class="n"&gt;offset&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
	&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nl"&gt;index&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
	&lt;span class="kt"&gt;int64_t&lt;/span&gt; &lt;span class="nl"&gt;offset&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;48&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;segment&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
这段代码使用了联合体赋予了 &lt;code&gt;shm_hentry_offset&lt;/code&gt; 两种访问方式，又使用了位域将 &lt;code&gt;int64_t&lt;/code&gt; 分割为两段。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org012f353" class="outline-2"&gt;
&lt;h2 id="org012f353"&gt;hash table的原理和实现&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org012f353"&gt;
&lt;p&gt;
libshmcache内部使用的是hash table做内部缓存的数据结构，这使查找的时间复杂度是O(1)。&lt;br&gt;
之前看过一些介绍hash table的资料，对hash table的工作原理是有过一个基础的了解的，这次通过阅读源码，能够了解到hash table在代码实现上更加细节的内容。&lt;br&gt;
对于hash计算中出现的hash值冲突，即在hash计算时出现了两个不同的key在经过hash计算后得到的bucket相同，libshmcache采用的解决方案是使用linked list来存放这些相同bucket对应的value。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org5898f4a" class="outline-2"&gt;
&lt;h2 id="org5898f4a"&gt;gcc原子化操作接口&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org5898f4a"&gt;
&lt;p&gt;
使用原子化操作接口能够解决一些并发读写问题，原子化操作相对于互斥锁执行更快。原子化操作也是一种无锁编程的方式。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org955c306" class="outline-2"&gt;
&lt;h2 id="org955c306"&gt;有锁写和无锁读的实现&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org955c306"&gt;
&lt;p&gt;
在libshmcache中，写操作通过 &lt;code&gt;pthread_mutex_t&lt;/code&gt; 进行同步，而读操作是无锁的。&lt;br&gt;
对于写操作来说，需要对hash table进行操作，这肯定是需要同步的。&lt;br&gt;
将 &lt;code&gt;pthread_mutex_t&lt;/code&gt; 保存在共享内存中，不同的进程通过映射共享内存就能获得同一个互斥量，通过这个互斥量就能完成进程间同步。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org204a9c8" class="outline-2"&gt;
&lt;h2 id="org204a9c8"&gt;共享内存的两套函数接口(POSIX和SystemV)&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org204a9c8"&gt;
&lt;p&gt;
在linux上使用共享内存时有两套接口 &lt;code&gt;mmap&lt;/code&gt; 和 &lt;code&gt;shmget&lt;/code&gt; 。 &lt;code&gt;mmap&lt;/code&gt; 是 &lt;code&gt;POSIX&lt;/code&gt; 标准的接口，而 &lt;code&gt;shmget&lt;/code&gt; 是 &lt;code&gt;System V&lt;/code&gt; 标准的接口，两者都能够实现进程间共享内存，但他们在使用上还是有些区别的。对于 &lt;code&gt;mmap&lt;/code&gt; 来说，需要在硬盘上创建一个文件，再将该文件映射到内存中。对于 &lt;code&gt;shmget&lt;/code&gt; 来说，需要指定一个key，不同的进程通过相同的key就能映射到同一片内存。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>c</category><category>memcached</category><category>redis</category><guid>https://samsonwang.me/posts/notes-on-libshmcache/</guid><pubDate>Mon, 23 Jul 2018 02:51:59 GMT</pubDate></item><item><title>C/C++中的位域</title><link>https://samsonwang.me/posts/bit-field/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div id="outline-container-org040a361" class="outline-2"&gt;
&lt;h2 id="org040a361"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; 什么是位域&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
&lt;a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E6%AE%B5"&gt;维基百科&lt;/a&gt; 给出了以下解释&lt;br&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
位域（或称“位段”，bit field）为一种数据结构，可以把数据以位的形式紧凑的储存，并允许程序员对此结构的位进行操作。&lt;br&gt;
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;
&lt;a href="https://en.cppreference.com/w/cpp/language/bit_field"&gt;cppreference&lt;/a&gt; 给出了以下定义&lt;br&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
Declares a class data member with explicit size, in bits. Adjacent bit field members may be packed to share and straddle the individual bytes.&lt;br&gt;
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;
这种数据结构的好处：&lt;br&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;可以使数据单元节省储存空间，当程序需要成千上万个数据单元时，这种方法就显得尤为重要。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;位段可以很方便的访问一个整数值的部分内容从而可以简化程序源代码。&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
而位域这种数据结构的缺点在于，其内存分配与内存对齐的实现方式依赖于具体的机器和系统，在不同的平台可能有不同的结果，这导致了位段在本质上是不可移植的。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgdb7a0f8" class="outline-2"&gt;
&lt;h2 id="orgdb7a0f8"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; 位域的语法&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;identifier&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;optional&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;attr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;optional&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
注意：&lt;br&gt;
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;size的大小不能超过identifier所包含最大比特位个数。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;identifier为空时表示对应的size个数的比特位不使用&lt;br&gt;&lt;/li&gt;
&lt;li&gt;size为0时表示根据前类型强制补齐&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;S1&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// will usually occupy 2 bytes:&lt;/span&gt;
    &lt;span class="c1"&gt;// 3 bits: value of b1&lt;/span&gt;
    &lt;span class="c1"&gt;// 2 bits: unused&lt;/span&gt;
    &lt;span class="c1"&gt;// 6 bits: value of b2&lt;/span&gt;
    &lt;span class="c1"&gt;// 2 bits: value of b3&lt;/span&gt;
    &lt;span class="c1"&gt;// 3 bits: unused&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="nl"&gt;b1&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nl"&gt;b2&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nl"&gt;b3&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;S2&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// will usually occupy 2 bytes:&lt;/span&gt;
    &lt;span class="c1"&gt;// 3 bits: value of b1&lt;/span&gt;
    &lt;span class="c1"&gt;// 5 bits: unused&lt;/span&gt;
    &lt;span class="c1"&gt;// 6 bits: value of b2&lt;/span&gt;
    &lt;span class="c1"&gt;// 2 bits: value of b3&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="nl"&gt;b1&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// start a new byte&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="nl"&gt;b2&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="nl"&gt;b3&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org3897a56" class="outline-3"&gt;
&lt;h3 id="org3897a56"&gt;&lt;span class="section-number-3"&gt;2.1&lt;/span&gt; 在size取0时如何理解&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-1"&gt;
&lt;p&gt;
对于size取0时的各种情况进行了尝试，详细用例如下。思路是使用联合体能比较方便地将内存分布表示出来。&lt;br&gt;
如下所示，定义了如下几种情况。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-orga218d3d" class="outline-4"&gt;
&lt;h4 id="orga218d3d"&gt;&lt;span class="section-number-4"&gt;2.1.1&lt;/span&gt; case1&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-2-1-1"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;union&lt;/span&gt; &lt;span class="n"&gt;un1&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
	&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nl"&gt;nn1&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
	&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
	&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nl"&gt;nn2&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;st&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
对联合体中的结构体位段进行赋值，并将联合体中的内容打印出来。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;union&lt;/span&gt; &lt;span class="n"&gt;un1&lt;/span&gt; &lt;span class="n"&gt;u1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;u1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;st&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;nn1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;u1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;st&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;nn2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"union u1.n1=0x%08x sizeof(un1)=%zu&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;u1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;n1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;un1&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
输出结果为&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;union&lt;/span&gt; &lt;span class="n"&gt;un1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;n1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mh"&gt;0x00000001&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;un1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb64481c" class="outline-4"&gt;
&lt;h4 id="orgb64481c"&gt;&lt;span class="section-number-4"&gt;2.1.2&lt;/span&gt; case2&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-2-1-2"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;union&lt;/span&gt; &lt;span class="n"&gt;un1&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
	&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nl"&gt;nn1&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
	&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
	&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nl"&gt;nn2&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;st&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
输出结果为&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;union&lt;/span&gt; &lt;span class="n"&gt;un1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;n1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mh"&gt;0x00000101&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;un1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgbb3a370" class="outline-4"&gt;
&lt;h4 id="orgbb3a370"&gt;&lt;span class="section-number-4"&gt;2.1.3&lt;/span&gt; case3&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-2-1-3"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;union&lt;/span&gt; &lt;span class="n"&gt;un1&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
	&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nl"&gt;nn1&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
	&lt;span class="kt"&gt;short&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
	&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nl"&gt;nn2&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;st&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
输出结果为&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;union&lt;/span&gt; &lt;span class="n"&gt;un1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;n1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mh"&gt;0x00010001&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;un1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org552881f" class="outline-4"&gt;
&lt;h4 id="org552881f"&gt;&lt;span class="section-number-4"&gt;2.1.4&lt;/span&gt; case4&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-2-1-4"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;union&lt;/span&gt; &lt;span class="n"&gt;un1&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
	&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nl"&gt;nn1&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
	&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
	&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nl"&gt;nn2&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;st&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
输出结果为&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;union&lt;/span&gt; &lt;span class="n"&gt;un1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;n1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mh"&gt;0x00000101&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;un1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org88eb342" class="outline-3"&gt;
&lt;h3 id="org88eb342"&gt;&lt;span class="section-number-3"&gt;2.2&lt;/span&gt; &lt;code&gt;struct&lt;/code&gt; 标识符&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-2"&gt;
&lt;p&gt;
多数例子都是以 &lt;code&gt;struct&lt;/code&gt; 作为位域的组织标识，在C++中能否使用 &lt;code&gt;class&lt;/code&gt; 作为位域的标识符。&lt;br&gt;
经过测试，是可以使用 &lt;code&gt;class&lt;/code&gt; 的，但是需要注意 &lt;code&gt;class&lt;/code&gt; 的默认访问控制属性为 &lt;code&gt;private&lt;/code&gt;&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org33882e6" class="outline-2"&gt;
&lt;h2 id="org33882e6"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; 位域的常见应用场景&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
&lt;b&gt;为什么要使用位域？位域适合那些情况？&lt;/b&gt;&lt;br&gt;
位域的主要使用目的是节省对象的内存使用。在存放一些比较小的数据时，使用位域能够使字节中的每个比特位合理地利用起来，避免内存浪费。&lt;br&gt;
比较典型的应用是描述硬件寄存器。如果有32个一组的寄存器，每个寄存器代表一个比特位，就可以使用位域表示这组寄存器。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgd0a9f97" class="outline-2"&gt;
&lt;h2 id="orgd0a9f97"&gt;&lt;span class="section-number-2"&gt;4&lt;/span&gt; C++中的位操作接口&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;p&gt;
C++中也提供了一套位操作的接口 &lt;code&gt;std::bitset&lt;/code&gt; ，这套接口提供了指定比特位数据的操作接口。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb0f8553" class="outline-2"&gt;
&lt;h2 id="orgb0f8553"&gt;&lt;span class="section-number-2"&gt;5&lt;/span&gt; 参考资料&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-5"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E6%AE%B5"&gt;wikipedia bit-field&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.cppreference.com/w/cpp/language/bit_field"&gt;cppreference bit-field&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://msdn.microsoft.com/zh-cn/library/ewwyfdbe.aspx"&gt;microsoft msdn&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/24933242/when-to-use-bit-fields-in-c"&gt;stackoverflow&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.cppreference.com/w/cpp/utility/bitset"&gt;cppreference std::bitset&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>cpp</category><guid>https://samsonwang.me/posts/bit-field/</guid><pubDate>Wed, 11 Jul 2018 10:03:37 GMT</pubDate></item><item><title>C风格和C++风格的文件操作库函数总结</title><link>https://samsonwang.me/posts/c-style-and-cpp-style-file-api/</link><dc:creator>Samson Wang</dc:creator><description>&lt;p&gt;
由于C++是兼容C的，所以使用C++进行文件操作时，会发现有两套库函数可以使用，它们分别是C风格的和C++风格的。&lt;br&gt;
&lt;/p&gt;

&lt;div id="outline-container-org35582ce" class="outline-2"&gt;
&lt;h2 id="org35582ce"&gt;C风格的文件操作函数&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org35582ce"&gt;
&lt;p&gt;
&lt;b&gt;打开文件，关闭文件&lt;/b&gt;&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;FILE&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;fopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;fclose&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;FILE&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
&lt;b&gt;读取文件，写入文件&lt;/b&gt;&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="nf"&gt;fread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;nmemb&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;FILE&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="nf"&gt;fwrite&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;nmemb&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;FILE&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
关于fread中两个表示大小的参数，在这个 &lt;a href="https://stackoverflow.com/questions/8589425/how-does-fread-really-work"&gt;stackoverflow&lt;/a&gt; 问题中得到了比较好的解答。&lt;br&gt;
&lt;/p&gt;


&lt;p&gt;
&lt;b&gt;改变文件指示器的位置&lt;/b&gt;&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;fseek&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;FILE&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;offset&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;whence&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="nf"&gt;ftell&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;FILE&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;rewind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;FILE&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-orgcbfcfae" class="outline-2"&gt;
&lt;h2 id="orgcbfcfae"&gt;C++风格的文件操作函数&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgcbfcfae"&gt;
&lt;p&gt;
C++将文件操作函数封装为 &lt;code&gt;fstream&lt;/code&gt; 操作类，一个文件实际上就会对应一个 &lt;code&gt;fstream&lt;/code&gt; 对象，一下函数都是 &lt;code&gt;fstream&lt;/code&gt; 的成员函数。&lt;br&gt;
文件打开和关闭&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ios_base&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;openmode&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ios_base&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;in&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;ios_base&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ios_base&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;openmode&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ios_base&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;in&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;ios_base&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;close&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
对于文件的读写可以才采用流运算符重载的方法完成。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="n"&gt;fstream&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fstream&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;ofs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;CRecord&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;objRecord&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="n"&gt;fstream&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fstream&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;ifs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;CRecord&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;objRecord&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org8ccbd3d" class="outline-2"&gt;
&lt;h2 id="org8ccbd3d"&gt;题外话&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org8ccbd3d"&gt;
&lt;p&gt;
在liunx下，可以使用wc命令查看文件中的相关信息。wc命令会打印出该文件的行数、单词数、字符数。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>cpp</category><category>linux</category><guid>https://samsonwang.me/posts/c-style-and-cpp-style-file-api/</guid><pubDate>Wed, 16 May 2018 10:06:45 GMT</pubDate></item><item><title>C++11新特性：基于范围的for循环</title><link>https://samsonwang.me/posts/cpp11-range-based-for-loop/</link><dc:creator>Samson Wang</dc:creator><description>&lt;p&gt;
&lt;b&gt;在C++11中，介绍了一种新的for循环写法，基于范围的for循环。&lt;/b&gt;&lt;br&gt;
与旧的for循环类似，也是用来对遍历容器中的所有元素，新的写法更加简洁方便。可以使用auto自动适配容器中的内容。为了遍历容器时提高效率，在访问容器内部时可以声明为元素的引用，进而避免不必要的对象拷贝。示例代码如下（代码节选自 &lt;a href="http://en.cppreference.com/w/cpp/language/range-for"&gt;cppreferance&lt;/a&gt;）&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nl"&gt;i&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// access by const reference&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="sc"&gt;' '&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="sc"&gt;'\n'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="nl"&gt;i&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// access by value, the type of i is int&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="sc"&gt;' '&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="sc"&gt;'\n'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nl"&gt;n&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt; &lt;span class="c1"&gt;// the initializer may be a braced-init-list&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="sc"&gt;' '&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="sc"&gt;'\n'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nl"&gt;n&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// the initializer may be an array&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="sc"&gt;' '&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="sc"&gt;'\n'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nl"&gt;n&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="sc"&gt;' '&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// the loop variable need not be used&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="sc"&gt;'\n'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
&lt;b&gt;注意 &lt;code&gt;std::map&lt;/code&gt; 的范围for循环遍历的写法&lt;/b&gt;&lt;br&gt;
&lt;code&gt;std::map&lt;/code&gt; 中存放的是 &lt;code&gt;key-value pair&lt;/code&gt; 键值对，所以在遍历的时候每次拿到的是一个 &lt;code&gt;pair&lt;/code&gt; ，在访问其中的元素时，需要注意书写方法。示例代码如下。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;mapDemo&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;auto&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nl"&gt;kvp&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;mapDemo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;kvp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;" - "&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;kvp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description><category>cpp</category><category>cpp11</category><guid>https://samsonwang.me/posts/cpp11-range-based-for-loop/</guid><pubDate>Wed, 18 Apr 2018 01:45:42 GMT</pubDate></item></channel></rss>