<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="/assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Hack Note (Posts about linux)</title><link>https://samsonwang.me/</link><description></description><atom:link href="https://samsonwang.me/tags/category-linux.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2017-2019 &lt;a href="mailto:wangzhilv@gmail.com"&gt;Samson Wang&lt;/a&gt; 
&lt;a rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/"&gt;&lt;img alt="知识共享许可协议" style="padding-bottom:2px" src="https://i.creativecommons.org/l/by-nc/4.0/80x15.png" /&gt;&lt;/a&gt;
</copyright><lastBuildDate>Fri, 25 Jan 2019 07:48:18 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Linux系统errno速查表</title><link>https://samsonwang.me/posts/linux-errno-cheatsheet/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div&gt;&lt;p&gt;
Linux系统errno数字和含义的对应关系，类似的资料很容易就能在网上找到，这里做一个备份方便日后查阅。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://samsonwang.me/posts/linux-errno-cheatsheet/"&gt;Read more…&lt;/a&gt; (5 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>errno</category><category>linux</category><category>not-index</category><guid>https://samsonwang.me/posts/linux-errno-cheatsheet/</guid><pubDate>Wed, 23 Jan 2019 03:23:49 GMT</pubDate></item><item><title>fork和vfork的区别</title><link>https://samsonwang.me/posts/fork-and-vfork/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div&gt;&lt;p&gt;
fork和vfork都是用来创建子进程的系统调用函数，本文主要对比了二者的区别。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://samsonwang.me/posts/fork-and-vfork/"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>fork</category><category>linux</category><category>posix</category><category>process</category><category>vfork</category><guid>https://samsonwang.me/posts/fork-and-vfork/</guid><pubDate>Wed, 16 Jan 2019 01:05:13 GMT</pubDate></item><item><title>[转]Linux 技巧：让进程在后台可靠运行的几种方法</title><link>https://samsonwang.me/posts/linux-run-program-nohup/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div&gt;&lt;p&gt;
我们经常会碰到这样的问题，用 telnet/ssh 登录了远程的 Linux 服务器，运行了一些耗时较长的任务， 结果却由于网络的不稳定导致任务中途失败。如何让命令提交后不受本地关闭终端窗口/网络断开连接的干扰呢？下面举了一些例子， 您可以针对不同的场景选择不同的方式来处理这个问题。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://samsonwang.me/posts/linux-run-program-nohup/"&gt;Read more…&lt;/a&gt; (3 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>linux</category><category>nohup</category><category>sreen</category><guid>https://samsonwang.me/posts/linux-run-program-nohup/</guid><pubDate>Sun, 28 Oct 2018 10:19:42 GMT</pubDate></item><item><title>gdb图形化调试</title><link>https://samsonwang.me/posts/debug-with-gdb-gui/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div&gt;&lt;p&gt;
gdb是linux下很强大的调试工具，它使用命令行进行交互。相比于windows下visual studio的图形化调试界面，gdb的命令行方式操作起来不是很方便，从用户友好度上二者难以相提并论。不过gdb也有许多配套的前端组件，提供了图形化界面展示调试过程中的信息，这样就比传统命令行方式要方便很多。本文介绍了使用图形化的gdb前端让调试变得便捷高效，建议再阅读本文之前先掌握一些gdb的基础知识。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://samsonwang.me/posts/debug-with-gdb-gui/"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>emacs</category><category>gdb</category><category>linux</category><guid>https://samsonwang.me/posts/debug-with-gdb-gui/</guid><pubDate>Thu, 18 Oct 2018 01:45:14 GMT</pubDate></item><item><title>在shell中使用正则表达式</title><link>https://samsonwang.me/posts/using-regexp-in-linux-shell/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div id="outline-container-org54317ff" class="outline-2"&gt;
&lt;h2 id="org54317ff"&gt;引言&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org54317ff"&gt;
&lt;p&gt;
本篇文章主要是针对shell中的 &lt;code&gt;grep&lt;/code&gt; 和 &lt;code&gt;egrep&lt;/code&gt; 的讲解，对于正则表达式的规则本身并没有太多的内容。在阅读本篇文章之前，读者应该对正则表达式有个大致的了解。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org3e69c54" class="outline-2"&gt;
&lt;h2 id="org3e69c54"&gt;&lt;code&gt;grep&lt;/code&gt; 命令&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org3e69c54"&gt;
&lt;p&gt;
&lt;code&gt;grep&lt;/code&gt; 命令是linux终端中最常用的命令之一，它的全称是“global regular expression print”，从字面上理解， &lt;code&gt;grep&lt;/code&gt; 可以用来进行正则表达式匹配。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;常用选项&lt;/b&gt;&lt;br&gt;
使用一些选项命令能够更加方便地进行匹配&lt;br&gt;
&lt;code&gt;-i&lt;/code&gt; 忽略大小写&lt;br&gt;
&lt;code&gt;-v&lt;/code&gt; 进行逆向匹配&lt;br&gt;
&lt;code&gt;-n&lt;/code&gt; 打印行号&lt;br&gt;
&lt;code&gt;--color=auto&lt;/code&gt; 彩色输出结果&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;支持的表达式&lt;/b&gt;&lt;br&gt;
正则表达式有很多规则， &lt;code&gt;grep&lt;/code&gt; 支持的有如下：&lt;br&gt;
在每一行的开始&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;grep &lt;span class="s2"&gt;"^GUN"&lt;/span&gt; GPL-3
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
在每一行的结尾&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;grep &lt;span class="s2"&gt;"and&lt;/span&gt;$&lt;span class="s2"&gt;"&lt;/span&gt; GPL-3
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
匹配任意字符&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;grep &lt;span class="s2"&gt;"..cept"&lt;/span&gt; GPL-3
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
在指定的字符中进行匹配&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;grep &lt;span class="s2"&gt;"t[wo]o"&lt;/span&gt; GPL-3
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
在指定的字符中进行逆向匹配&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;grep &lt;span class="s2"&gt;"[^c]ode"&lt;/span&gt; GPL-3
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
使用范围来指定字符&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;grep &lt;span class="s2"&gt;"^[A-Z]"&lt;/span&gt; GPL-3
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
限定出现的次数为0次或0次以上&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;grep &lt;span class="s2"&gt;"([A-Za-z ]*)"&lt;/span&gt; GPL-3
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org6812903" class="outline-2"&gt;
&lt;h2 id="org6812903"&gt;&lt;code&gt;egrep&lt;/code&gt; 命令&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org6812903"&gt;
&lt;p&gt;
&lt;code&gt;egrep&lt;/code&gt; 的含义为“extended grep”，相对于 &lt;code&gt;grep&lt;/code&gt; 有更多的正则表达式特性。同样，可以在使用 &lt;code&gt;grep&lt;/code&gt; 时增加 &lt;code&gt;-E&lt;/code&gt; 参数获得相同的效果。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;表达式分组&lt;/b&gt;&lt;br&gt;
使用括号能够将表达式进行分组，下面的任何一个都能够实现这个效果&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;grep &lt;span class="s2"&gt;"\(grouping\)"&lt;/span&gt; file.txt
grep -E &lt;span class="s2"&gt;"(grouping)"&lt;/span&gt; file.txt
egrep &lt;span class="s2"&gt;"(grouping)"&lt;/span&gt; file.txt
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
表达式进行中多选一&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;egrep &lt;span class="s2"&gt;"(GPL|General Public License)"&lt;/span&gt; GPL-3
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
匹配的重复次数为0次或0次以上，与 &lt;code&gt;*&lt;/code&gt; 限定符类似，但是 &lt;code&gt;?&lt;/code&gt; 可以作用于一组字符&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;egrep &lt;span class="s2"&gt;"(copy)?right"&lt;/span&gt; GPL-3
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
指定匹配的重复次数&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;egrep &lt;span class="s2"&gt;"[AEIOUaeiou]{3}"&lt;/span&gt; GPL-3
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-orga2a1f1e" class="outline-2"&gt;
&lt;h2 id="orga2a1f1e"&gt;参考资料&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orga2a1f1e"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://www.digitalocean.com/community/tutorials/using-grep-regular-expressions-to-search-for-text-patterns-in-linux"&gt;digital ocean - grep tutorial&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://man7.org/linux/man-pages/man1/grep.1.html"&gt;linux man page&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>egrep</category><category>grep</category><category>liunx</category><category>shell</category><guid>https://samsonwang.me/posts/using-regexp-in-linux-shell/</guid><pubDate>Sun, 16 Sep 2018 01:47:01 GMT</pubDate></item><item><title>shell的输出重定向</title><link>https://samsonwang.me/posts/shell-output-redirections/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div id="outline-container-orgea2387a" class="outline-2"&gt;
&lt;h2 id="orgea2387a"&gt;引言&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgea2387a"&gt;
&lt;p&gt;
在linux中借助shell等命令行工具能够很方便地与操作系统交互，可以在shell中将命令或程序的输入结果重定向到特定地方，很方便地实现一些功能。这个技巧十分实用，使用输出重定向能够极大地简化我们的日常操作。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org642348c" class="outline-2"&gt;
&lt;h2 id="org642348c"&gt;使用尖括号完成重定向&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org642348c"&gt;
&lt;p&gt;
示例如下，运行下面的命令能够把 &lt;code&gt;ls&lt;/code&gt; 命令的运行结果写入到 &lt;code&gt;ls-output.txt&lt;/code&gt; 中。使用 &lt;code&gt;&amp;gt;&lt;/code&gt; 会把程序运行时本该输出到 &lt;code&gt;stdout&lt;/code&gt; 的内容重定向到指定名称的文件中。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ls . &amp;gt; ls-output.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
可以在 &lt;code&gt;&amp;gt;&lt;/code&gt; 左面写上数字和 &lt;code&gt;&amp;amp;&lt;/code&gt; ，用以标识在重定向时的特殊用法。下面会给出一些特殊用法的实例。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf5ae36a" class="outline-3"&gt;
&lt;h3 id="orgf5ae36a"&gt;重定向 &lt;code&gt;stdout&lt;/code&gt; 到指定文件中&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgf5ae36a"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ls . &lt;span class="m"&gt;1&lt;/span&gt;&amp;gt; ls-output.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgd92db54" class="outline-3"&gt;
&lt;h3 id="orgd92db54"&gt;重定向 &lt;code&gt;stderr&lt;/code&gt; 到指定文件中&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgd92db54"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ls . &lt;span class="m"&gt;2&lt;/span&gt;&amp;gt; ls-error.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf2be25d" class="outline-3"&gt;
&lt;h3 id="orgf2be25d"&gt;将 &lt;code&gt;stdout&lt;/code&gt; 和 &lt;code&gt;stdout&lt;/code&gt; 合并再重定向到指定文件中&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgf2be25d"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ls . &lt;span class="m"&gt;2&lt;/span&gt;&amp;gt;&lt;span class="p"&gt;&amp;amp;&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; ls-output-and-error.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
以下命令具有相同的效果&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ls . &lt;span class="p"&gt;&amp;amp;&lt;/span&gt;&amp;gt; ls-output-and-error.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org586789c" class="outline-3"&gt;
&lt;h3 id="org586789c"&gt;将程序的输出丢掉&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org586789c"&gt;
&lt;p&gt;
可以将输出重定向到一个特殊的文件 &lt;code&gt;/dev/null&lt;/code&gt; ，所有写入到这个文件的内容都会被丢弃掉。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;program &amp;gt; /dev/null
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org62840ec" class="outline-3"&gt;
&lt;h3 id="org62840ec"&gt;将输出追加到指定文件尾部&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org62840ec"&gt;
&lt;p&gt;
使用一个尖括号（ &lt;code&gt;&amp;gt;&lt;/code&gt; ）能够将输出重定向到文件中，在写入文件时会覆盖掉其中的内容。如果想保留文件中的原始内容，则可以用两个尖括号（ &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; ），这样就能将输出追加到文件的尾部。示例代码如下：&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nb"&gt;test&lt;/span&gt; &amp;gt;&amp;gt; file-output.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgc04b64b" class="outline-2"&gt;
&lt;h2 id="orgc04b64b"&gt;使用管道完成重定向&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgc04b64b"&gt;
&lt;p&gt;
使用管道符号 &lt;code&gt;|&lt;/code&gt; 能够将一个程序的输出重定向到另一个程序的输入中去。下面的命令会将 &lt;code&gt;ls&lt;/code&gt; 的输出（ &lt;code&gt;stdout&lt;/code&gt; ）重定向到 &lt;code&gt;grep&lt;/code&gt; 的输入（ &lt;code&gt;stdin&lt;/code&gt; ）中去。管道命令在linux中是最常见的用法。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ls &lt;span class="p"&gt;|&lt;/span&gt; grep &amp;lt;pattern&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>linux</category><category>shell</category><guid>https://samsonwang.me/posts/shell-output-redirections/</guid><pubDate>Thu, 26 Jul 2018 02:02:41 GMT</pubDate></item><item><title>GCC的内存原子化操作函数接口</title><link>https://samsonwang.me/posts/gcc-built-in-functions-for-atomic-memory-access/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div id="outline-container-orgdf84179" class="outline-2"&gt;
&lt;h2 id="orgdf84179"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; 原子化操作&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
在并发编程中，一个操作或一组操作是原子操作、可线性化操作、不可分操作或不可中断操作（atomic, linearizable, indivisible, uniterruptible），表示该操作执行时不可被中断的。操作的原子性能够保证操作在执行时免受中断、信号、并发进程线程的影响。另外，原子操作大多只有两种结果，要么成功并改变系统中对应的状态，要么没有相关效果。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
原子化经常由互斥来保证，可以在硬件层面建立一个缓存一致性协议，也可以在软件层面使用信号量或加锁。因此，一个原子操作不是必须实际上马上生效，而操作系统让这个操作看起来是直接发生的，这能够让操作系统保持一致。正是如此，只要不影响性能，用户可以忽略较底层的实现细节。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgd3f6daf" class="outline-2"&gt;
&lt;h2 id="orgd3f6daf"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; 函数接口&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
GCC提供了原子化的操作接口，能够支持长度为1、2、4、8字节的整形变量或指针。&lt;br&gt;
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;
In most cases, these builtins are considered a full barrier. That is, no memory operand will be moved across the operation, either forward or backward. Further, instructions will be issued as necessary to prevent the processor from speculating loads across the operation and from queuing stores after the operation.&lt;br&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
在大多数情况下，这些内建函数是完全内存栅栏（full barrier）的，以上摘自 GCC Manual。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;取值并进行对应操作的接口&lt;/b&gt; 如下所示：&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;__sync_fetch_and_add&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...)&lt;/span&gt;
&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;__sync_fetch_and_sub&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...)&lt;/span&gt;
&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;__sync_fetch_and_or&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...)&lt;/span&gt;
&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;__sync_fetch_and_and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...)&lt;/span&gt;
&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;__sync_fetch_and_xor&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...)&lt;/span&gt;
&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;__sync_fetch_and_nand&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
这些函数接口的执行逻辑如下：会执行名称相对应的运算，并将内存中之前存放的值取出并返回。&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;   &lt;span class="c1"&gt;// nand&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
&lt;b&gt;需要注意的是&lt;/b&gt; ：从GCC 4.4开始 &lt;code&gt;__sync_fetch_and_nand&lt;/code&gt; 是按照 &lt;code&gt;*ptr = ~(*ptr &amp;amp; value)&lt;/code&gt; 实现的，而不是 &lt;code&gt;*ptr = ~*ptr &amp;amp; value&lt;/code&gt;&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;直接操作并返回结果的接口&lt;/b&gt; 如下所示：&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;__sync_add_and_fetch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...)&lt;/span&gt;
&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;__sync_sub_and_fetch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...)&lt;/span&gt;
&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;__sync_or_and_fetch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...)&lt;/span&gt;
&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;__sync_and_and_fetch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...)&lt;/span&gt;
&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;__sync_xor_and_fetch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...)&lt;/span&gt;
&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;__sync_nand_and_fetch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
这些函数接口的执行逻辑如下：&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;   &lt;span class="c1"&gt;// nand&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
&lt;b&gt;需要注意的是&lt;/b&gt; ：从GCC 4.4开始 &lt;code&gt;__sync_nand_and_fetch&lt;/code&gt; 是按照 &lt;code&gt;*ptr = ~(*ptr &amp;amp; value)&lt;/code&gt; 实现的，而不是 &lt;code&gt;*ptr = ~*ptr &amp;amp; value&lt;/code&gt;&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
比较并交换的函数接口&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;__sync_bool_compare_and_swap&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;oldval&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;newval&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...)&lt;/span&gt;
&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;__sync_val_compare_and_swap&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;oldval&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;newval&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgad87b1f" class="outline-2"&gt;
&lt;h2 id="orgad87b1f"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; 内存栅栏（Memory Barrier）&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
在上面的说明中提到了memory barrier的概念，这个概念是CPU指令的一个术语。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
内存栅栏又叫内存屏障，是一种能够让CPU或编译器约束内存操作指令执行顺序的屏蔽指令。这表示在内存栅栏前的指令能够保证执行时先于内存栅栏后的指令。由于大多数现代CPU采用性能优化会导致指令执行变序时，所以内存栅栏是十分必要的。这样的指令变序对于单线程程序一般不会有很大影响，但是在并发编程情况下如果不加以控制就会导致不可预知的结果。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
内存栅栏的典型应用场景就是用于实现多设备之间的共享内存的底层机器码。这些代码包括原始同步机制、多核系统上的无锁数据结构、与计算机硬件交互的设备驱动。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
内存栅栏对于无锁编程来说十分重要的。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;内存栅栏与volatile关键字&lt;/b&gt;&lt;br&gt;
内存栅栏分为读栅栏（read barrier）、写栅栏（write barrier）、获取栅栏（acquire barrier）、释放栅栏（release barrier）等。内存栅栏并不能保证数值的是“最新的”或“新鲜的”，它只能控制内存访问的相对顺序。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
“写栅栏”用于控制写操作的顺序。由于相对于CPU的执行速度来说，向内存中写入顺序是比较慢的，通常会有一个写入请求队列，所以实际的写入操作发生在指令发起之后，队列中指令的顺序可能会被重新排序。写栅栏能够防止指令变序。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
“读栅栏”用于控制读操作的顺序。由于预先执行（CPU会提前将内存中的数据读回来），并且CPU有缓存区（CPU会从缓存中而不是内存中读取数据），读操作可能会出现变序。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
volatile关键字值能通知编译器生成的输出码从内存中重新读取数据，但是不会告诉CPU在如何读取数据、在哪里读取数据。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
“获取栅栏”能够保证特定指令块之前的执行顺序。例如获取读，在向读队列中加入读操作，“获取栅栏”意味着在这条操作之后可以出现指令变序，而这条操作之前不会出现指令变序。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
“释放栅栏”能够保证特定指令块之后的执行顺序。例如释放写，在向写队列中加入写操作，“释放栅栏”意味着在这条写操作之前的指令不会变序到该指令之后，而这条该操作的之后的指令可能会变序到该指令之前。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
获取栅栏和释放栅栏是又叫半栅栏（half barrier），这是因为它们只能防止单方向的指令变序。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-orge476a1c" class="outline-2"&gt;
&lt;h2 id="orge476a1c"&gt;&lt;span class="section-number-2"&gt;4&lt;/span&gt; 操作原子化能够解决多进程访问共享内存的问题吗？&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;p&gt;
原子化操作是对于CPU而言的指令操作，它不关心线程还是进程，它只关心这一系列的指令是不可分割的。所以，进程间可以使用原子操作完成内存的操作同步。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-orgd1a7f9b" class="outline-2"&gt;
&lt;h2 id="orgd1a7f9b"&gt;&lt;span class="section-number-2"&gt;5&lt;/span&gt; 参考资料&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-5"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Linearizability"&gt;Wikipedia - Linearizability&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://gcc.gnu.org/onlinedocs/gcc-4.4.3/gcc/Atomic-Builtins.html"&gt;GNU GCC online docs&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Memory_barrier"&gt;Wikipedia - Memory Barrier&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/1787450/how-do-i-understand-read-memory-barriers-and-volatile"&gt;stackoverflow - memory barrier and volatile&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/8160348/lock-freedom-atomic-operations-across-2-processes-instead-of-threads"&gt;stackoverflow - atomic operation in multi process&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.cppreference.com/w/cpp/atomic"&gt;cppreference - atomic&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>gcc</category><category>linux</category><guid>https://samsonwang.me/posts/gcc-built-in-functions-for-atomic-memory-access/</guid><pubDate>Mon, 02 Jul 2018 09:54:08 GMT</pubDate></item><item><title>在gdb中查看指定内存地址的内容</title><link>https://samsonwang.me/posts/gdb-display-contents-of-memory-address/</link><dc:creator>Samson Wang</dc:creator><description>&lt;div&gt;&lt;p&gt;
调试 C/C++ 程序时，需要打印指定内存地址的内容。我最近调试程序中的序列化模块时，需要将类对象按照指定的格式转化为二进制流，为了验证转化结果，在调试时就需要将指定内存地址中的内容打印出来。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://samsonwang.me/posts/gdb-display-contents-of-memory-address/"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>debugging</category><category>gdb</category><category>linux</category><guid>https://samsonwang.me/posts/gdb-display-contents-of-memory-address/</guid><pubDate>Fri, 29 Jun 2018 08:45:09 GMT</pubDate></item><item><title>查看Linux系统的相关信息</title><link>https://samsonwang.me/posts/check-system-information-on-linux/</link><dc:creator>Samson Wang</dc:creator><description>&lt;p&gt;
查看Linux系统相关信息有助于排查和解决软件和硬件的兼容性问题。系统信息包括硬件信息和软件信息，硬件信息主要有CPU信息、内存信息、PCI信息、USB信息、硬盘信息等等。软件信息主要有系统版本、分区使用状态等等。本文主要介绍了获取当前Linux系统信息的命令。&lt;br&gt;
&lt;/p&gt;

&lt;div id="outline-container-org65c89c6" class="outline-2"&gt;
&lt;h2 id="org65c89c6"&gt;查看系统相关信息&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org65c89c6"&gt;
&lt;p&gt;
&lt;code&gt;uname&lt;/code&gt; 指令提供了查询系统信息的功能，使用该命令能够快速获取操作系统信息概览。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
查看内核名称&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;uname -s
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
查看处理器类型&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;uname -p
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
查看硬件架构&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;uname -i
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
查看内核版本&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;uname -r
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
查看所有系统信息&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;uname -a
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
查看操作系统信息（发行版信息）&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cat /etc/os-release
cat /proc/version
lsb_release -a
hostnamectl
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org08bab69" class="outline-2"&gt;
&lt;h2 id="org08bab69"&gt;查看CPU相关信息&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org08bab69"&gt;
&lt;p&gt;
&lt;code&gt;lscpu&lt;/code&gt; 指令能够查看当前系统中CPU的详细信息，包括型号、主频、构架、大小端等信息。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org65eff1c" class="outline-2"&gt;
&lt;h2 id="org65eff1c"&gt;查看硬盘相关信息&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org65eff1c"&gt;
&lt;p&gt;
&lt;code&gt;lsblk&lt;/code&gt; 指令能够查看块设备（block device）的详细信息，块设备主要指系统中的存储设备如硬盘和闪存。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org6e54be4" class="outline-2"&gt;
&lt;h2 id="org6e54be4"&gt;查看PCI设备的相关信息&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org6e54be4"&gt;
&lt;p&gt;
&lt;code&gt;lspci&lt;/code&gt; 指令能够查看PCI设备的信息，PCI设备包括USB、显卡、串口、网卡等其他外围设备。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
输出树形结果&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;lspci -t
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
输出详细信息&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;lspci -v
lspci -vv
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org3469b5c" class="outline-2"&gt;
&lt;h2 id="org3469b5c"&gt;查看USB设备的相关信息&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org3469b5c"&gt;
&lt;p&gt;
&lt;code&gt;lsusb&lt;/code&gt; 指令能够查看USBS设备的信息。&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org1fb3965" class="outline-2"&gt;
&lt;h2 id="org1fb3965"&gt;查看文件系统相关信息&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org1fb3965"&gt;
&lt;p&gt;
&lt;code&gt;fdisk&lt;/code&gt; 命令能够查看和操作linux系统的分区表。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
查看文件系统信息&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;fdisk -l
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
&lt;code&gt;df&lt;/code&gt; 命令能够查看分区信息和硬盘使用信息&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
使输出信息更容易理解&lt;br&gt;
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;df -h
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgad89fb8" class="outline-2"&gt;
&lt;h2 id="orgad89fb8"&gt;参考资料&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgad89fb8"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://www.tecmint.com/commands-to-collect-system-and-hardware-information-in-linux/"&gt;tecmint.com&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.binarytides.com/linux-commands-hardware-info/"&gt;binarytides.com&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>linux</category><guid>https://samsonwang.me/posts/check-system-information-on-linux/</guid><pubDate>Wed, 20 Jun 2018 02:30:50 GMT</pubDate></item><item><title>Linux常用命令行指令 - top</title><link>https://samsonwang.me/posts/linux-command-examples-top/</link><dc:creator>Samson Wang</dc:creator><description>&lt;p&gt;
linux的top命令能够动态显示当前系统的运行状态。它能够显示操作系统的汇总信息和当前系统上的正在运行的进程列表。&lt;br&gt;
&lt;/p&gt;

&lt;div id="outline-container-org8a09de0" class="outline-2"&gt;
&lt;h2 id="org8a09de0"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; 统计信息说明&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
(可以通过配置文件修改通计信息区的显示格式，下文所描述的都是在默认配置下的显示内容)&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgf11967e" class="outline-3"&gt;
&lt;h3 id="orgf11967e"&gt;&lt;span class="section-number-3"&gt;1.1&lt;/span&gt; 第1行&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-1"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;当前系统时间&lt;br&gt;&lt;/li&gt;
&lt;li&gt;up 当前系统的启动时长&lt;br&gt;&lt;/li&gt;
&lt;li&gt;当前登录的用户数量&lt;br&gt;&lt;/li&gt;
&lt;li&gt;当前系统的平均负载（分别是1min,5min,10min的平均负载）&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
这一行信息也可以通过 &lt;code&gt;uptime&lt;/code&gt; 和 &lt;code&gt;w&lt;/code&gt; 指令获得&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orge7a3995" class="outline-3"&gt;
&lt;h3 id="orge7a3995"&gt;&lt;span class="section-number-3"&gt;1.2&lt;/span&gt; 第2行&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-2"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;总进程数&lt;br&gt;&lt;/li&gt;
&lt;li&gt;正在运行的进程数&lt;br&gt;&lt;/li&gt;
&lt;li&gt;休眠的进程数&lt;br&gt;&lt;/li&gt;
&lt;li&gt;停止的进程数&lt;br&gt;&lt;/li&gt;
&lt;li&gt;僵尸进程数&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org4b0cdee" class="outline-3"&gt;
&lt;h3 id="org4b0cdee"&gt;&lt;span class="section-number-3"&gt;1.3&lt;/span&gt; 第3行&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-3"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;us 用户空间占用CPU百分比&lt;br&gt;&lt;/li&gt;
&lt;li&gt;sy 内核空间占用CPU百分比&lt;br&gt;&lt;/li&gt;
&lt;li&gt;ni 用户进程空间内改变过优先级的进程占用CPU百分比&lt;br&gt;&lt;/li&gt;
&lt;li&gt;id 空闲CPU百分比&lt;br&gt;&lt;/li&gt;
&lt;li&gt;wa 等待输入输出的CPU时间百分比&lt;br&gt;&lt;/li&gt;
&lt;li&gt;hi CPU服务于硬件中断所耗费的时间总额&lt;br&gt;&lt;/li&gt;
&lt;li&gt;si CPU服务软中断所耗费的时间总额&lt;br&gt;&lt;/li&gt;
&lt;li&gt;st Steal time 虚拟机被hypervisor偷去的CPU时间（如果当前处于一个hypervisor下的vm，实际上hypervisor也是要消耗一部分CPU处理时间的）&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org57270ae" class="outline-3"&gt;
&lt;h3 id="org57270ae"&gt;&lt;span class="section-number-3"&gt;1.4&lt;/span&gt; 第4行&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-4"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;物理内存总量&lt;br&gt;&lt;/li&gt;
&lt;li&gt;使用的物理内存总量&lt;br&gt;&lt;/li&gt;
&lt;li&gt;空闲内存总量&lt;br&gt;&lt;/li&gt;
&lt;li&gt;用作内核缓存的内存量&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org28142e0" class="outline-3"&gt;
&lt;h3 id="org28142e0"&gt;&lt;span class="section-number-3"&gt;1.5&lt;/span&gt; 第5行&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-5"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;交换区总量&lt;br&gt;&lt;/li&gt;
&lt;li&gt;使用的交换区总量&lt;br&gt;&lt;/li&gt;
&lt;li&gt;空间交换区总量&lt;br&gt;&lt;/li&gt;
&lt;li&gt;缓冲交换区总量&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org319fa4a" class="outline-2"&gt;
&lt;h2 id="org319fa4a"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; 进程信息&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
在top命令中按f按可以查看显示的列信息，按对应字母来开启/关闭列，大写字母表示开启，小写字母表示关闭。带*号的是默认列。&lt;br&gt;
&lt;/p&gt;

&lt;p&gt;
A: PID = (Process Id) 进程Id；&lt;br&gt;
E: USER = (User Name) 进程所有者的用户名；&lt;br&gt;
H: PR = (Priority) 优先级&lt;br&gt;
I: NI = (Nice value) nice值。负值表示高优先级，正值表示低优先级&lt;br&gt;
O: VIRT = (Virtual Image (kb)) 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES&lt;br&gt;
Q: RES = (Resident size (kb)) 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA&lt;br&gt;
T: SHR = (Shared Mem size (kb)) 共享内存大小，单位kb&lt;br&gt;
W: S = (Process Status) 进程状态。D=不可中断的睡眠状态,R=运行,S=睡眠,T=跟踪/停止,Z=僵尸进程&lt;br&gt;
K: %CPU = (CPU usage) 上次更新到现在的CPU时间占用百分比&lt;br&gt;
N: %MEM = (Memory usage (RES)) 进程使用的物理内存百分比&lt;br&gt;
M: TIME+ = (CPU Time, hundredths) 进程使用的CPU时间总计，单位1/100秒&lt;br&gt;
b: PPID = (Parent Process Pid) 父进程Id&lt;br&gt;
c: RUSER = (Real user name)&lt;br&gt;
d: UID = (User Id) 进程所有者的用户id&lt;br&gt;
f: GROUP = (Group Name) 进程所有者的组名&lt;br&gt;
g: TTY = (Controlling Tty) 启动进程的终端名。不是从终端启动的进程则显示为 ?&lt;br&gt;
j: P = (Last used cpu (SMP)) 最后使用的CPU，仅在多CPU环境下有意义&lt;br&gt;
p: SWAP = (Swapped size (kb)) 进程使用的虚拟内存中，被换出的大小，单位kb&lt;br&gt;
l: TIME = (CPU Time) 进程使用的CPU时间总计，单位秒&lt;br&gt;
r: CODE = (Code size (kb)) 可执行代码占用的物理内存大小，单位kb&lt;br&gt;
s: DATA = (Data+Stack size (kb)) 可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb&lt;br&gt;
u: nFLT = (Page Fault count) 页面错误次数&lt;br&gt;
v: nDRT = (Dirty Pages count) 最后一次写入到现在，被修改过的页面数&lt;br&gt;
y: WCHAN = (Sleeping in Function) 若该进程在睡眠，则显示睡眠中的系统函数名&lt;br&gt;
z: Flags = (Task Flags &amp;lt;sched.h&amp;gt;) 任务标志，参考 sched.h&lt;br&gt;
X: COMMAND = (Command name/line) 命令名/命令行&lt;br&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-orgafcd868" class="outline-2"&gt;
&lt;h2 id="orgafcd868"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; 参考资料&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://www.tecmint.com/12-top-command-examples-in-linux/"&gt;tecmint.com&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.csdn.net/sanshiqiduer/article/details/1933625"&gt;csdn blog&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>linux</category><guid>https://samsonwang.me/posts/linux-command-examples-top/</guid><pubDate>Thu, 14 Jun 2018 03:26:53 GMT</pubDate></item></channel></rss>