<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="Personal handnote on software development">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Hack Note (old posts, page 16) | Hack Note</title>
<link href="https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet">
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link href="/assets/css/code.css" rel="stylesheet" type="text/css">
<link href="/assets/css/highlight.css" rel="stylesheet" type="text/css">
<link href="/assets/css/colorbox.css" rel="stylesheet" type="text/css">
<link href="/assets/css/cerulean.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="en" href="/rss.xml">
<link rel="canonical" href="http://samsonwang.me/index-16.html">
<link rel="icon" href="/favicon.ico" sizes="64x64">
<link rel="prev" href="/index-17.html" type="text/html">
<link rel="next" href="/index-15.html" type="text/html">
<!--[if lt IE 9]><script src="https://html5shim.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->
<nav class="navbar navbar-inverse navbar-fixed-top"><div class="container">
  <!-- This keeps the margins nice -->

    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="http://samsonwang.me/">

        <span id="blog-title">Hack Note</span>
      </a>
    </div>

    <!-- /.navbar-header -->
    <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
      <ul class="nav navbar-nav">
<li>
<a href="/archive/">Archives</a>
                </li>
<li>
<a href="/tags/">Tags</a>
                </li>
<li>
<a href="/listings/">Listings</a>
                </li>
<li>
<a href="/galleries/">Galleries</a>
                </li>
<li>
<a href="/rss.xml">RSS Feed</a>

        
      </li>
</ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!-- /.navbar-collapse -->
  </div>
<!-- /.container -->
</nav><!-- End of Menubar --><div class="container" id="content" role="main">
  <div class="body-content">
    <!--Body content-->
    <div class="row">

      <div class="col-sm-9">
        
        


  



  


<div class="postindex">
  <article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/debug-with-gdb-gui/" class="u-url">gdb图形化调试</a></h1>
      <div class="metadata">


        <div class="date">
          <a href="/posts/debug-with-gdb-gui/" rel="bookmark">
            <time class="published dt-published" datetime="2018-07-05T16:45:14+08:00" title="2018-07-05 16:45">2018-07-05 16:45
            </time></a>
        </div>

          <div class="comment">
            
        
    <a href="/posts/debug-with-gdb-gui/#disqus_thread" data-disqus-identifier="cache/posts/debug-with-gdb-gui.html">Comments</a>


          </div>

      </div>
    </header><div class="e-content entry-content">
      <div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">前言</h2>
<div class="outline-text-2" id="text-1">
<p>
在linux程序的调试时，使用命令行交互界面是不方便的，本文主要讨论的是如何让调试变得便捷高效，建议再阅读本文之前先掌握一些gdb调试的基础知识。<br></p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">使用gdb内部集成的TUI</h2>
<div class="outline-text-2" id="text-2">
<p>
gdb提供了TUI作为图形化的调试界面，能够将调试过程中的代码显示出来、将寄存器信息和各种临时变量信息打印到屏幕上。<br></p>

<div class="highlight"><pre><span></span>layout src  # 显示源代码窗口
layout asm  # 显示反汇编窗口
layout regs  # 增加寄存器窗口
layout split  # 显示源代码和反汇编窗口
ctrl + l  # 刷新窗口
refresh  # 刷新窗口
focus cmd  # 聚焦到 cmd 窗口
focus asm  # 聚焦到 asm 窗口
focus src  # 聚焦到 src 窗口
focus regs  # 聚焦到 regs 窗口
tui reg next  # 显示下一组寄存器
tui reg prev  # 显示上一组寄存器
</pre></div>


<p>
参考资料<br><a href="https://ylhao.github.io/2018/05/15/gdb%E8%87%AA%E6%9F%A5%E6%89%8B%E5%86%8C/">https://ylhao.github.io/2018/05/15/gdb%E8%87%AA%E6%9F%A5%E6%89%8B%E5%86%8C/</a><br></p>
</div>
</div>


<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">使用第三方的cgdb</h2>
<div class="outline-text-2" id="text-3">
<p>
cgdb<br></p>
</div>
</div>


<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">使用EMACS + gud mode</h2>
</div>
    </div>
  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/gcc-built-in-functions-for-atomic-memory-access/" class="u-url">GCC的内存原子化操作函数接口</a></h1>
      <div class="metadata">


        <div class="date">
          <a href="/posts/gcc-built-in-functions-for-atomic-memory-access/" rel="bookmark">
            <time class="published dt-published" datetime="2018-07-02T17:54:08+08:00" title="2018-07-02 17:54">2018-07-02 17:54
            </time></a>
        </div>

          <div class="comment">
            
        
    <a href="/posts/gcc-built-in-functions-for-atomic-memory-access/#disqus_thread" data-disqus-identifier="cache/posts/gcc-built-in-functions-for-atomic-memory-access.html">Comments</a>


          </div>

      </div>
    </header><div class="e-content entry-content">
      <div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">
<span class="section-number-2">1</span> 原子化操作</h2>
<div class="outline-text-2" id="text-1">
<p>
在并发编程中，一个操作或一组操作是原子操作、可线性化操作、不可分操作或不可中断操作（atomic, linearizable, indivisible, uniterruptible），表示该操作执行时不可被中断的。操作的原子性能够保证操作在执行时免受中断、信号、并发进程线程的影响。另外，原子操作大多只有两种结果，要么成功并改变系统中对应的状态，要么没有相关效果。<br></p>

<p>
原子化经常由互斥来保证，可以在硬件层面建立一个缓存一致性协议，也可以在软件层面使用信号量或加锁。因此，一个原子操作不是必须实际上马上生效，而操作系统让这个操作看起来是直接发生的，这能够让操作系统保持一致。正是如此，只要不影响性能，用户可以忽略较底层的实现细节。<br></p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">
<span class="section-number-2">2</span> 函数接口</h2>
<div class="outline-text-2" id="text-2">
<p>
GCC提供了原子化的操作接口，能够支持长度为1、2、4、8字节的整形变量或指针。<br></p>

<blockquote>
<p>
In most cases, these builtins are considered a full barrier. That is, no memory operand will be moved across the operation, either forward or backward. Further, instructions will be issued as necessary to prevent the processor from speculating loads across the operation and from queuing stores after the operation.<br></p>
</blockquote>
<p>
在大多数情况下，这些内建函数是完全内存栅栏（full barrier）的，以上摘自 GCC Manual。<br></p>

<p>
<b>取值并进行对应操作的接口</b> 如下所示：<br></p>
<div class="highlight"><pre><span></span><span class="n">type</span> <span class="n">__sync_fetch_and_add</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">type</span> <span class="n">__sync_fetch_and_sub</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">type</span> <span class="n">__sync_fetch_and_or</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">type</span> <span class="n">__sync_fetch_and_and</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">type</span> <span class="n">__sync_fetch_and_xor</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">type</span> <span class="n">__sync_fetch_and_nand</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
<p>
这些函数接口的执行逻辑如下：会执行名称相对应的运算，并将内存中之前存放的值取出并返回。<br></p>
<div class="highlight"><pre><span></span><span class="p">{</span> <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span> <span class="o">*</span><span class="n">ptr</span> <span class="n">op</span><span class="o">=</span> <span class="n">value</span><span class="p">;</span> <span class="k">return</span> <span class="n">tmp</span><span class="p">;</span> <span class="p">}</span>
<span class="p">{</span> <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">value</span><span class="p">);</span> <span class="k">return</span> <span class="n">tmp</span><span class="p">;</span> <span class="p">}</span>   <span class="c1">// nand</span>
</pre></div>
<p>
<b>需要注意的是</b> ：从GCC 4.4开始 <code>__sync_fetch_and_nand</code> 是按照 <code>*ptr = ~(*ptr &amp; value)</code> 实现的，而不是 <code>*ptr = ~*ptr &amp; value</code><br></p>

<p>
<b>直接操作并返回结果的接口</b> 如下所示：<br></p>
<div class="highlight"><pre><span></span><span class="n">type</span> <span class="n">__sync_add_and_fetch</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">type</span> <span class="n">__sync_sub_and_fetch</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">type</span> <span class="n">__sync_or_and_fetch</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">type</span> <span class="n">__sync_and_and_fetch</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">type</span> <span class="n">__sync_xor_and_fetch</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">type</span> <span class="n">__sync_nand_and_fetch</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
<p>
这些函数接口的执行逻辑如下：<br></p>
<div class="highlight"><pre><span></span><span class="p">{</span> <span class="o">*</span><span class="n">ptr</span> <span class="n">op</span><span class="o">=</span> <span class="n">value</span><span class="p">;</span> <span class="k">return</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span> <span class="p">}</span>
<span class="p">{</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="o">*</span><span class="n">ptr</span> <span class="o">&amp;</span> <span class="n">value</span><span class="p">);</span> <span class="k">return</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span> <span class="p">}</span>   <span class="c1">// nand</span>
</pre></div>
<p>
<b>需要注意的是</b> ：从GCC 4.4开始 <code>__sync_nand_and_fetch</code> 是按照 <code>*ptr = ~(*ptr &amp; value)</code> 实现的，而不是 <code>*ptr = ~*ptr &amp; value</code><br></p>

<p>
比较并交换的函数接口<br></p>
<div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="n">__sync_bool_compare_and_swap</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">oldval</span> <span class="n">type</span> <span class="n">newval</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">type</span> <span class="n">__sync_val_compare_and_swap</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">oldval</span> <span class="n">type</span> <span class="n">newval</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">
<span class="section-number-2">3</span> 内存栅栏（Memory Barrier）</h2>
<div class="outline-text-2" id="text-3">
<p>
在上面的说明中提到了memory barrier的概念，这个概念是CPU指令的一个术语。<br></p>

<p>
内存栅栏又叫内存屏障，是一种能够让CPU或编译器约束内存操作指令执行顺序的屏蔽指令。这表示在内存栅栏前的指令能够保证执行时先于内存栅栏后的指令。由于大多数现代CPU采用性能优化会导致指令执行变序时，所以内存栅栏是十分必要的。这样的指令变序对于单线程程序一般不会有很大影响，但是在并发编程情况下如果不加以控制就会导致不可预知的结果。<br></p>

<p>
内存栅栏的典型应用场景就是用于实现多设备之间的共享内存的底层机器码。这些代码包括原始同步机制、多核系统上的无锁数据结构、与计算机硬件交互的设备驱动。<br></p>

<p>
内存栅栏对于无锁编程来说十分重要的。<br></p>

<p>
<b>内存栅栏与volatile关键字</b><br>
内存栅栏分为读栅栏（read barrier）、写栅栏（write barrier）、获取栅栏（acquire barrier）、释放栅栏（release barrier）等。内存栅栏并不能保证数值的是“最新的”或“新鲜的”，它只能控制内存访问的相对顺序。<br></p>

<p>
“写栅栏”用于控制写操作的顺序。由于相对于CPU的执行速度来说，向内存中写入顺序是比较慢的，通常会有一个写入请求队列，所以实际的写入操作发生在指令发起之后，队列中指令的顺序可能会被重新排序。写栅栏能够防止指令变序。<br></p>

<p>
“读栅栏”用于控制读操作的顺序。由于预先执行（CPU会提前将内存中的数据读回来），并且CPU有缓存区（CPU会从缓存中而不是内存中读取数据），读操作可能会出现变序。<br></p>

<p>
volatile关键字值能通知编译器生成的输出码从内存中重新读取数据，但是不会告诉CPU在如何读取数据、在哪里读取数据。<br></p>

<p>
“获取栅栏”能够保证特定指令块之前的执行顺序。例如获取读，在向读队列中加入读操作，“获取栅栏”意味着在这条操作之后可以出现指令变序，而这条操作之前不会出现指令变序。<br></p>

<p>
“释放栅栏”能够保证特定指令块之后的执行顺序。例如释放写，在向写队列中加入写操作，“释放栅栏”意味着在这条写操作之前的指令不会变序到该指令之后，而这条该操作的之后的指令可能会变序到该指令之前。<br></p>

<p>
获取栅栏和释放栅栏是又叫半栅栏（half barrier），这是因为它们只能防止单方向的指令变序。<br></p>
</div>
</div>


<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">
<span class="section-number-2">4</span> 操作原子化能够解决多进程访问共享内存的问题吗？</h2>
<div class="outline-text-2" id="text-4">
<p>
原子化操作是对于CPU而言的指令操作，它不关心线程还是进程，它只关心这一系列的指令是不可分割的。所以，进程间可以使用原子操作完成内存的操作同步。<br></p>
</div>
</div>


<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">
<span class="section-number-2">5</span> 参考资料</h2>
<div class="outline-text-2" id="text-5">
<ul class="org-ul">
<li>
<a href="https://en.wikipedia.org/wiki/Linearizability">Wikipedia - Linearizability</a><br>
</li>
<li>
<a href="https://gcc.gnu.org/onlinedocs/gcc-4.4.3/gcc/Atomic-Builtins.html">GNU GCC online docs</a><br>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Memory_barrier">Wikipedia - Memory Barrier</a><br>
</li>
<li>
<a href="https://stackoverflow.com/questions/1787450/how-do-i-understand-read-memory-barriers-and-volatile">stackoverflow - memory barrier and volatile</a><br>
</li>
<li>
<a href="https://stackoverflow.com/questions/8160348/lock-freedom-atomic-operations-across-2-processes-instead-of-threads">stackoverflow - atomic operation in multi process</a><br>
</li>
<li>
<a href="https://en.cppreference.com/w/cpp/atomic">cppreference - atomic</a><br>
</li>
</ul>
</div>
</div>
    </div>
  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/gdb-display-contents-of-memory-address/" class="u-url">在gdb中查看指定内存地址的内容</a></h1>
      <div class="metadata">


        <div class="date">
          <a href="/posts/gdb-display-contents-of-memory-address/" rel="bookmark">
            <time class="published dt-published" datetime="2018-06-29T16:45:09+08:00" title="2018-06-29 16:45">2018-06-29 16:45
            </time></a>
        </div>

          <div class="comment">
            
        
    <a href="/posts/gdb-display-contents-of-memory-address/#disqus_thread" data-disqus-identifier="cache/posts/gdb-display-contents-of-memory-address.html">Comments</a>


          </div>

      </div>
    </header><div class="e-content entry-content">
      <div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">
<span class="section-number-2">1</span> 引言</h2>
<div class="outline-text-2" id="text-1">
<p>
调试 C/C++ 程序时，需要打印指定内存地址的内容。我最近调试程序中的序列化模块时，需要将类对象按照指定的格式转化为二进制流，为了验证转化结果，在调试时就需要将指定内存地址中的内容打印出来。<br></p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">
<span class="section-number-2">2</span> 指令语法</h2>
<div class="outline-text-2" id="text-2">
<p>
在gdb模式下，使用 <code>x</code> （ <code>examine</code> 的缩写）指令能够将指令内存地址中的信息打印出来。指令的语法如下。<br></p>
<div class="highlight"><pre><span></span>x/nfu addr
x addr
</pre></div>
<p>
其中 <code>n</code> 、 <code>f</code> 、 <code>u</code> 都是可选参数， <code>n</code> 表示重复次数， <code>f</code> 表示显示格式（format）， <code>u</code> 表示显示单元大小(unix size)。<br></p>

<p>
<code>f</code> <b>可以取如下值</b> ：<br>
x 按十六进制格式显示变量<br>
d 按十进制格式显示变量<br>
o 按八进制格式显示变量<br>
t 按二进制格式显示变量<br></p>

<p>
<code>u</code> <b>可以取如下值</b> ：<br>
b 表示单字节（byte）<br>
h 表示双字节（halfword）<br>
w 表示四字节(word)<br>
g 表示八字节(giant word)<br></p>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">
<span class="section-number-2">3</span> 示例</h2>
<div class="outline-text-2" id="text-3">
<p>
以下指令会以16进制格式显示addr开始的100字节信息<br></p>
<div class="highlight"><pre><span></span>x/100xb addr
</pre></div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">
<span class="section-number-2">4</span> 参考资料</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li>
<a href="ftp://ftp.gnu.org/old-gnu/Manuals/gdb/html_chapter/gdb_9.html#SEC56">GDB manual(gnu.org)</a><br>
</li>
<li>
<a href="https://sourceware.org/gdb/onlinedocs/gdb/Memory.html">GDB manual(sourceware.org)</a><br>
</li>
</ul>
</div>
</div>
    </div>
  </article>
</div>



        
       <script>var disqus_shortname="samsonwang-me";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script>
</div>

      <div class="col-sm-3 sidebar">
       
<div class="sidebar-module sidebar-module-inset">
  <h4>About Me</h4>
  
<div class="sidebar-aboutme">
<p>Zeal for coding, C++ developer.</p>
<p>Focus on linux server dev.</p>
<p>I use EMACS, and I am learning python.</p>
<p>View my code on <a href="https://github.com/samsonwang"> Github</a></p>
</div>

</div>

       
<div class="sidebar-module">
  <h4>Categories</h4>
  
<ol class="list-unstyled sidebar-category">
<li>
<a href="/tags/category_cpp/">cpp</a>
</li>
<li>
<a href="/tags/category_emacs/">emacs</a>
</li>
<li>
<a href="/tags/category_linux/">linux</a>
</li>
<li>
<a href="/tags/category_windows/">windows</a>
</li>
</ol>
</div>

      </div>
<!--.sidebar-->
    </div>
<!--.row-->

    

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="/index-17.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="/index-15.html" rel="next">Older posts</a>
            </li>
        </ul></nav><!--End of body content--><footer id="footer"><div class="text-center">
<p>Contents © 2017-2018 <a href="mailto:wangzhilv@gmail.com">Samson Wang</a>
 - Powered by <a href="https://getnikola.com/" rel="nofollow">Nikola</a>
 - Hosted on <a href="https://pages.github.com/" rel="nofollow">Github Pages</a>
 - 
<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/"><img alt="知识共享许可协议" style="border-width:0; vertical-align:text-top;" src="https://i.creativecommons.org/l/by-nc/4.0/80x15.png"></a>
</p>
</div>

      
    </footer>
</div>
</div>

<div id="scroll-top" title="back to top">
  <div id="scroll-top-arrow"></div>
  <div id="scroll-top-stick"></div>
</div>


            <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><script src="https://cdn.bootcss.com/jquery_lazyload/1.9.7/jquery.lazyload.min.js"></script><script src="https://cdn.bootcss.com/jquery.colorbox/1.6.4/jquery.colorbox-min.js"></script><script src="https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/assets/js/moment-with-locales.min.js"></script><script src="/assets/js/fancydates.js"></script><script src="/assets/js/cerulean.js"></script><script>
    $('a.image-reference:not(.islink) img:not(.islink)').parent().colorbox({rel:"gal",maxWidth:"100%",maxHeight:"100%",scalePhotos:true});
  </script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(2, "YYYY-MM-DD HH:mm");
  </script><!-- end fancy dates --><!-- Baidu Analytics --><script>
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?7ec47c52179b8ca4f9aee81282bd7b20";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>
</body>
</html>
