<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns#" lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta http-equiv="x-ua-compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Hack Note (old posts, page 6) | Hack Note</title>
<meta name="description" content="Personal handnote on software development">
<meta name="theme-color" content="#04519b">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" href="/rss.xml">
<link href="/assets/css/minima.min.css" rel="stylesheet" type="text/css">
<link rel="canonical" href="https://blog.wangzhl.com/index-6.html">
<link rel="icon" href="/favicon.ico" sizes="64x64">
<link rel="prev" href="/index-5.html" type="text/html">
<link rel="next" href="/index-7.html" type="text/html">
</head>
<body>
  <header class="site-header nav-custom"><div class="wrapper">
      <a class="site-title" rel="author" href="/">Hack Note</a>
      <nav class="site-nav"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger">
          <span class="menu-icon">
            <svg viewbox="0 0 18 15" width="18px" height="15px"><use href="/assets/svg/theme.svg#menu-icon"></use></svg></span>
        </label>
        <div class="trigger">
          
            <a class="page-link" href="/">Home</a>
            <a class="page-link" href="/archive/">Archive</a>
            <a class="page-link" href="/tags/">Tags</a>
            <a class="page-link" href="/about/">About</a>

        </div>
      </nav>
</div>
  </header><main class="page-content" aria-label="Content"><div class="wrapper">

    

    


  



  


<div class="home">
  <ul class="post-list">
<li>
    <span class="post-meta">Oct 17, 2018</span>
    <h3>
      <a class="post-link" href="/posts/algorithm-weekly-next-permutation/">每周算法：下一个组合</a>
    </h3>

    <p>
leetcode算法题第31道，难度为medium。这道题考察题意理解的准确性和思路的全面性，对于题目所包含规律的总结也很重要。<br></p>

  </li>


  <li>
    <span class="post-meta">Oct 11, 2018</span>
    <h3>
      <a class="post-link" href="/posts/algorithm-weekly-divide-two-integers/">每周算法：两整数相除</a>
    </h3>

    <p>
leetcode算法题第29道，难度为medium。从题目描述上来看，这道题考察两数相除的计算，貌似很简单，但如果仔细研究下来，就会发现这道题所考察的知识很综合。<br></p>

  </li>


  <li>
    <span class="post-meta">Oct 10, 2018</span>
    <h3>
      <a class="post-link" href="/posts/emacs-directory-variables/">在EMACS中对目录进行独立配置</a>
    </h3>

    <p>
如果你曾经同时维护多个软件项目，每个软件项目的代码风格都有各自的偏好。举个常见的例子，项目A要求使用 <code>tab</code> 进行缩进，而项目B要求使用空格进行缩进，虽然这样的代码风格问题看起来无关紧要，但这确实是代码编写中实实在在的问题。本文无意于讨论两者风格的优劣，而是想介绍在EMACS中优雅地解决这个问题的方法。<br></p>

  </li>


  <li>
    <span class="post-meta">Oct 09, 2018</span>
    <h3>
      <a class="post-link" href="/posts/algorithm-weekly-remove-duplicates-from-sorted-array/">每周算法：删去有序数组中的重复元素</a>
    </h3>

    <p>
leetcode算法题第26道，难度为easy，这是非常基础的一道题。<br></p>

  </li>


  <li>
    <span class="post-meta">Oct 04, 2018</span>
    <h3>
      <a class="post-link" href="/posts/algorithm-weekly-swap-nodes-in-pairs/">每周算法：调换链表中节点</a>
    </h3>

    <p>
leetcode算法第24题，难度为medium。将链表中的节点成对翻转，考察链表结构的理解和节点的操作。<br></p>

  </li>


  <li>
    <span class="post-meta">Sep 30, 2018</span>
    <h3>
      <a class="post-link" href="/posts/algorithm-weekly-generate-parentheses/">每周算法：生成有效的括号组合</a>
    </h3>

    <p>
leetcode 算法题第22道，难度为medium，对指定数量的括号进行排列组合，列举出其中有效的结果。对括号的处理通常出现在表达式分析中，这道题目是了解括号表达式特性的很好切入点。<br></p>

  </li>


  <li>
    <span class="post-meta">Sep 27, 2018</span>
    <h3>
      <a class="post-link" href="/posts/router-modem-and-switch/">路由、调制解调器和交换机</a>
    </h3>

    <p>
路由、调制解调器和交换机，这三个是我们经常使用的网络设备。它们在网络中的作用是什么？它们工作在网络模型的哪一层？本篇文章将带你了解他们的原理与和区别。<br></p>

  </li>


  <li>
    <span class="post-meta">Sep 26, 2018</span>
    <h3>
      <a class="post-link" href="/posts/algorithm-weekly-remove-nth-node-from-end-of-list/">每周算法：删去单向链表倒数第n个节点</a>
    </h3>

    <p>
leetcode算法题第19道，难度为medium，考察链表的基本操作。<br></p>

  </li>


  <li>
    <span class="post-meta">Sep 24, 2018</span>
    <h3>
      <a class="post-link" href="/posts/internet-protocol/">IP协议（RFC791）</a>
    </h3>

    <p>
本文是IPv4协议的摘要和笔记，IPv4协议格式由RFC791规定，RFC791协议的原文可以在 <a href="https://tools.ietf.org/html/rfc791">这里</a> 找到。<br></p>

  </li>


  <li>
    <span class="post-meta">Sep 21, 2018</span>
    <h3>
      <a class="post-link" href="/posts/network-protocol-suite/">网络通信协议</a>
    </h3>

    <p>
本文总结了两种常见的网络模型，OSI模型和TCP/IP模型，并比较了二者之间的区别。<br></p>

  </li>


  <li>
    <span class="post-meta">Sep 21, 2018</span>
    <h3>
      <a class="post-link" href="/posts/algorithm-weekly-four-sum/">每周算法：四数之和</a>
    </h3>

    <div id="outline-container-org5591d77" class="outline-2">
<h2 id="org5591d77">Description</h2>
<div class="outline-text-2" id="text-org5591d77">
<p>
Given an array <code>nums</code> of n integers and an integer <code>target</code> , are there elements <i>a</i>, <i>b</i>, <i>c</i>, and <i>d</i> in <code>nums</code> such that <i>a</i> + <i>b</i> + <i>c</i> + <i>d</i> = <code>target</code> ? Find all unique quadruplets in the array which gives the sum of <code>target</code> .<br></p>

<p>
<b>Note:</b><br>
The solution set must not contain duplicate quadruplets.<br></p>

<p>
<b>Example:</b><br></p>
<pre class="example">
Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.

A solution set is:
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]
</pre>
</div>
</div>

<div id="outline-container-org6fe5b13" class="outline-2">
<h2 id="org6fe5b13">Solution</h2>
<div class="outline-text-2" id="text-org6fe5b13">
</div>
<div id="outline-container-org68b84be" class="outline-3">
<h3 id="org68b84be">Apporach 1 暴力解法</h3>
<div class="outline-text-3" id="text-org68b84be">
<p>
将所有的组合穷举出来，与目标进行逐一比对，将满足条件的组合收集起来，就能得到结果。需要注意的是去除结果中的重复项。<br></p>
<div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">fourSum</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">nums</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">target</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">set</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">ans</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">k</span><span class="o">=</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">m</span><span class="o">=</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">nums</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">target</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">			</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">t</span><span class="p">({</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="w"> </span><span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="w"> </span><span class="n">nums</span><span class="p">[</span><span class="n">m</span><span class="p">]});</span><span class="w"></span>
<span class="w">			</span><span class="n">sort</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">t</span><span class="p">.</span><span class="n">end</span><span class="p">());</span><span class="w"></span>
<span class="w">			</span><span class="n">ans</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="w"></span>
<span class="w">		    </span><span class="p">}</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>
<span class="w">	    </span><span class="p">}</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">ans</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">ans</span><span class="p">.</span><span class="n">end</span><span class="p">());</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>

<div id="outline-container-orga6468b5" class="outline-3">
<h3 id="orga6468b5">Approach 2 拓展3sum算法</h3>
<div class="outline-text-3" id="text-orga6468b5">
<p>
这道题的与之前的 <a href="/posts/algorithm-weekly-three-sum/" class="post-url">3 sum</a> 十分类似，通过简单的拓展就能得到该问题的解法。<br></p>
<div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">fourSum</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">nums</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">target</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">ans</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="n">n1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="n">target_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">n1</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">&lt;</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	    </span><span class="kt">int</span><span class="w"> </span><span class="n">n2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="w"></span>
<span class="w">	    </span><span class="kt">int</span><span class="w"> </span><span class="n">target_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">target_1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">n2</span><span class="p">;</span><span class="w"></span>

<span class="w">	    </span><span class="kt">int</span><span class="w"> </span><span class="n">front</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">	    </span><span class="kt">int</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">	    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">front</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">end</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="kt">int</span><span class="w"> </span><span class="n">n3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nums</span><span class="p">[</span><span class="n">front</span><span class="p">];</span><span class="w"></span>
<span class="w">		</span><span class="kt">int</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">nums</span><span class="p">[</span><span class="n">end</span><span class="p">];</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sum</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">target_2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		    </span><span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="p">({</span><span class="n">n1</span><span class="p">,</span><span class="w"> </span><span class="n">n2</span><span class="p">,</span><span class="w"> </span><span class="n">n3</span><span class="p">,</span><span class="w"> </span><span class="n">nums</span><span class="p">[</span><span class="n">end</span><span class="p">]}));</span><span class="w"></span>
<span class="w">		    </span><span class="k">do</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">++</span><span class="n">front</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="p">(</span><span class="n">front</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">nums</span><span class="p">[</span><span class="n">front</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">n3</span><span class="p">);</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>
<span class="w">		</span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sum</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">target_2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		    </span><span class="o">--</span><span class="n">end</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>
<span class="w">		</span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		    </span><span class="o">++</span><span class="n">front</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>
<span class="w">	    </span><span class="p">}</span><span class="w"></span>
<span class="w">	    </span><span class="k">do</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="o">&lt;</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">n2</span><span class="p">);</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="w">	</span><span class="k">do</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">n1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ans</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>

<div id="outline-container-orgfe8573c" class="outline-3">
<h3 id="orgfe8573c">Approach 3 优化的拓展3sum算法</h3>
<div class="outline-text-3" id="text-orgfe8573c">
<p>
在 approach 2 的基础上，增加一些边界条件判断，能够很大程度上提升算法的速度。下面的代码截取自leetcode，通过增加边界条件的判断，可以明显缩短代码的运行耗时。其中注释的代码是令一种较慢边界条件的判断方法，该代码的作者进一步优化了边界条件的判断逻辑。可以说，这种解法就是压榨算法的性能。这种优化方法是值得思考和学习的。<br></p>
<div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">fourSum</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">nums</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">target</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">res</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">sort</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">len</span><span class="mi">-3</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="c1">//avoid duplicate</span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="mi">-1</span><span class="p">])</span><span class="w"> </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="c1">// if (nums[i] + nums[i+1] + nums[i+2] + nums[i+3] &gt; target) break;</span>
<span class="w">	</span><span class="c1">// if (nums[i] + nums[len-3] + nums[len-2] + nums[len-1] &lt; target) continue;</span>
<span class="w">	</span><span class="c1">//version3: less tight pruning</span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">target</span><span class="p">)</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w">  </span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">nums</span><span class="p">[</span><span class="n">len</span><span class="mi">-1</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">target</span><span class="p">)</span><span class="w"> </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">len</span><span class="mi">-2</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="mi">-1</span><span class="p">])</span><span class="w"> </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">	    </span><span class="c1">// if (nums[i] + nums[j] + nums[j+1] + nums[j+2] &gt; target) break;</span>
<span class="w">	    </span><span class="c1">// if (nums[i] + nums[j] + nums[len-2] + nums[len-1] &lt; target) continue;</span>
<span class="w">	    </span><span class="c1">//version3: less tight pruning</span>
<span class="w">	    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="o">*</span><span class="w"> </span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">target</span><span class="p">)</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">	    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">nums</span><span class="p">[</span><span class="n">len</span><span class="mi">-1</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">target</span><span class="p">)</span><span class="w"> </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">	    </span><span class="c1">//now the problems becomes 3 sum problem and only two other elements only to be considered</span>
<span class="w">	    </span><span class="kt">int</span><span class="w"> </span><span class="n">left</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">len</span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="w">	    </span><span class="kt">int</span><span class="w"> </span><span class="n">sofar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="w"></span>
<span class="w">	    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sofar</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">target</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">		    </span><span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">({</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="w"> </span><span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">],</span><span class="w"> </span><span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]}));</span><span class="w"></span>
<span class="w">		    </span><span class="c1">//how to skip the duplicate left and right</span>
<span class="w">		    </span><span class="c1">//version1: my own version</span>
<span class="w">		    </span><span class="c1">//  left++;</span>
<span class="w">		    </span><span class="c1">//  right--;</span>
<span class="w">		    </span><span class="c1">//  while (left &lt; right &amp;&amp; nums[left-1] == nums[left])  ++left;</span>
<span class="w">		    </span><span class="c1">// while (right &gt; left &amp;&amp; nums[right+1] == nums[right]) --right;</span>
<span class="w">		    </span><span class="c1">//version2: refer others</span>
<span class="w">		    </span><span class="k">do</span><span class="p">{</span><span class="n">left</span><span class="o">++</span><span class="p">;}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="mi">-1</span><span class="p">]);</span><span class="w"></span>
<span class="w">		    </span><span class="k">do</span><span class="p">{</span><span class="n">right</span><span class="o">--</span><span class="p">;}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">right</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span><span class="w"></span>
<span class="w">		</span><span class="p">}</span><span class="w"></span>
<span class="w">		</span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sofar</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">target</span><span class="p">)</span><span class="w"> </span><span class="n">left</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">		</span><span class="k">else</span><span class="w"> </span><span class="n">right</span><span class="o">--</span><span class="p">;</span><span class="w"></span>
<span class="w">	    </span><span class="p">}</span><span class="w"></span>
<span class="w">	</span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>

  </li>


  <li>
    <span class="post-meta">Sep 19, 2018</span>
    <h3>
      <a class="post-link" href="/posts/breadth-first-search/">广度优先搜索</a>
    </h3>

    <div id="outline-container-orgcbff138" class="outline-2">
<h2 id="orgcbff138">引言</h2>
<div class="outline-text-2" id="text-orgcbff138">
<p>
在求解 <a href="/posts/algorithm-weekly-letter-combinations-of-a-phone-number/" class="post-url">leetcode 17</a> 时，我遇到了BFS（广度优先搜索）这个概念。在深入了解后发现，BFS是图（graph）的一个知识点，我对这一知识点进行展开学习，并将找到的资料汇总起来。本文主要整理了图和广度优先搜索的相关知识点。<br></p>
</div>
</div>

<div id="outline-container-org802ca0c" class="outline-2">
<h2 id="org802ca0c">图的存储方式</h2>
<div class="outline-text-2" id="text-org802ca0c">
<p>
研究图就需要使用计算机语言对其进行描述。图的存储结构除了要存储图中各个顶点的本身的信息外，同时还要存储顶点与顶点之间的所有关系（边的信息）。因此，图的结构比较复杂，很难以数据元素在存储区中的物理位置来表示元素之间的关系，但也正是由于其任意的特性，故物理表示方法很多。常用的图的存储结构有邻接矩阵、邻接表、十字链表和邻接多重表。<br></p>
</div>

<div id="outline-container-orgb75e986" class="outline-3">
<h3 id="orgb75e986">相邻矩阵（adjacency martix）</h3>
<div class="outline-text-3" id="text-orgb75e986">
<p>
对于一个具有 <code>n</code> 个顶点的图，可以使用 <code>n*n</code> 的矩阵（二维数组）来表示它们间的邻接关系。下图中，矩阵 <code>A(i，j)=1</code> 表示图中存在一条边 <code>(Vi，Vj)</code> ，而 <code>A(i，j)=0</code> 表示图中不存在边 <code>(Vi，Vj)</code> 。实际编程时，当图为不带权图时，可以在二维数组中存放bool值， <code>A(i，j)=true</code> 表示存在边 <code>(Vi，Vj)</code> ， <code>A(i，j)=false</code> 表示不存在边 <code>(Vi，Vj)</code> ；当图带权值时，则可以直接在二维数组中存放权值， <code>A(i，j)=null</code> 表示不存在边 <code>(Vi，Vj)</code> 。<br></p>

<p>
<img src="/assets/images/spinner.svg" data-src="/images/post-breadth-first-search-1.jpg" alt="图的相邻矩阵表示方法"><br></p>

<p>
左图所示的是无向图的邻接矩阵表示法，可以观察到，矩阵延对角线对称，即 <code>A(i，j)=A(j，i)</code> 。无向图邻接矩阵的第 <code>i</code> 行或第 <code>i</code> 列非零元素的个数其实就是第 <code>i</code> 个顶点的度。这表示无向图邻接矩阵存在一定的数据冗余。<br></p>

<p>
右图所示的是有向图邻接矩阵表示法，矩阵并不延对角线对称， <code>A(i，j)=1</code> 表示顶点 <code>Vi</code> 邻接到顶点 <code>Vj</code> ； <code>A(j，i)=1</code> 则表示顶点 <code>Vi</code> 邻接自顶点 <code>Vj</code> 。两者并不象无向图邻接矩阵那样表示相同的意思。有向图邻接矩阵的第 <code>i</code> 行非零元素的个数其实就是第 <code>i</code> 个顶点的出度，而第 <code>i</code> 列非零元素的个数是第 <code>i</code> 个顶点的入度，即第 <code>i</code> 个顶点的度是第 <code>i</code> 行和第 <code>i</code> 列非零元素个数之和。<br></p>

<p>
由于存在 <code>n</code> 个顶点的图需要 <code>n^2</code> 个数组元素进行存储，当图为稀疏图时，使用邻接矩阵存储方法将出现大量零元素，照成极大地空间浪费，这时应该使用邻接表表示法存储图中的数据。<br></p>
</div>
</div>

<div id="outline-container-orgb6393dd" class="outline-3">
<h3 id="orgb6393dd">邻接表（adjacency list）</h3>
<div class="outline-text-3" id="text-orgb6393dd">
<p>
邻接表（adjacency list）是一种常用的表示图的数据结构。邻接表是许多链表的集合，每个链表描述了一个顶点（ <code>vectex</code> ）的相邻元素（ <code>Neighbor</code> ）。更形象地讲，邻接表是一个二维容器，第一维描述某个点，第二维描述这个点所对应的边集们。<br>
图的邻接矩阵存储方法跟树的孩子链表示法相类似，是一种顺序分配和链式分配相结合的存储结构。邻接表由表头结点和表结点两部分组成，其中图中每个顶点均对应一个存储在数组中的表头结点。如这个表头结点所对应的顶点存在相邻顶点，则把相邻顶点依次存放于表头结点所指向的单向链表中。如下图所示，表结点存放的是邻接顶点在数组中的索引。对于无向图来说，使用邻接表进行存储也会出现数据冗余，表头结点 <code>A</code> 所指链表中存在一个指向 <code>C</code> 的表结点的同时，表头结点 <code>C</code> 所指链表也会存在一个指向 <code>A</code> 的表结点。<br><img src="/assets/images/spinner.svg" data-src="/images/post-breadth-first-search-2.jpg" alt="图的相邻表表示方法"><br></p>

<p>
有向图的邻接表有出边表和入边表（又称逆邻接表）之分。出边表的表结点存放的是从表头结点出发的有向边所指的尾顶点；入边表的表结点存放的则是指向表头结点的某个头顶点。如下图所示，图(b)和(c)分别为有向图(a)的出边表和入边表。<br><img src="/assets/images/spinner.svg" data-src="/images/post-breadth-first-search-3.jpg" alt="有向图的相邻表表示方法"><br></p>

<p>
以上所讨论的邻接表所表示的都是不带权的图，如果要表示带权图，可以在表结点中增加一个存放权的字段，其效果如下图所示。<br><img src="/assets/images/spinner.svg" data-src="/images/post-breadth-first-search-4.jpg" alt="加权图的相邻表表示方法"><br>
观察上图可以发现，当删除存储表头结点的数组中的某一元素，有可能使部分表头结点索引号的改变，从而导致大面积修改表结点的情况发生。可以在表结点中直接存放指向表头结点的指针以解决这个问题（在链表中存放类实例即是存放指针，但必须要保证表头结点是类而不是结构体）。在实际创建邻接表时，甚至可以使用链表代替数组存放表头结点或使用顺序表存代替链表存放表结点。<br></p>

<p>
本节所有的图片摘自 <a href="https://www.cnblogs.com/abatei/archive/2008/06/06/1215114.html">cnblogs.com - abatei</a><br></p>
</div>
</div>
</div>

<div id="outline-container-org1e3eeb3" class="outline-2">
<h2 id="org1e3eeb3">图的遍历</h2>
<div class="outline-text-2" id="text-org1e3eeb3">
<p>
和树的遍历类似，在此，我们希望从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫做图的遍历(traversing graph)。如果只访问图的顶点而不关注边的信息，那么图的遍历十分简单，使用一个 <code>foreach</code> 语句遍历存放顶点信息的数组即可。但如果为了实现特定算法，就需要根据边的信息按照一定顺序进行遍历。图的遍历算法是求解图的连通性问题、拓扑排序和求关键路径等算法的基础。<br></p>

<p>
图的遍历要比树的遍历复杂得多，由于图的任一顶点都可能和其余顶点相邻接，故在访问了某顶点之后，可能顺着某条边又访问到了已访问过的顶点，因此，在图的遍历过程中，必须记下每个访问过的顶点，以免同一个顶点被访问多次。为此给顶点附设访问标志 <code>visited</code> ，其初值为 <code>false</code> ，一旦某个顶点被访问，则其 <code>visited</code> 标志置为 <code>true</code> 。<br></p>

<p>
图的遍历方法有两种：一种是深度优先搜索遍历（depth first search 简称DFS），另一种是广度优先搜索遍历（breadth first search 简称BFS）。<br></p>
</div>
</div>

<div id="outline-container-orgef6bba8" class="outline-2">
<h2 id="orgef6bba8">广度优先搜索（breadth first search）</h2>
<div class="outline-text-2" id="text-orgef6bba8">
<p>
图的广度优先搜索遍历算法是一个分层遍历的过程，和二叉树的广度优先搜索遍历类同。它从图的某一顶点 <code>Vi</code> 出发，访问此顶点后，依次访问 <code>Vi</code> 的各个未曾访问过的邻接点，然后分别从这些邻接点出发，直至图中所有已有已被访问的顶点的邻接点都被访问到。对于无向连通图，若顶点 <code>Vi</code> 为初始访问的顶点，则广度优先搜索遍历顺序如下所示。<br><img src="/assets/images/spinner.svg" data-src="/images/post-breadth-first-search-5.jpg" alt="图的广度优先搜索遍历"><br></p>

<p>
广度优先搜索的伪代码如下：<br></p>
<pre class="example">
BFS (G, s)  // Where G is the graph and s is the source node
  let Q be queue.
  Q.enqueue( s )  // Inserting s in queue until all its neighbour vertices are marked.

  mark s as visited.

  while ( Q is not empty )
    // Removing that vertex from queue, whose neighbour will be visited now
    v  =  Q.dequeue( )

    // processing all the neighbours of v
    for all neighbours w of v in Graph G
      if w is not visited
        Q.enqueue( w )  // Stores w in Q to further visit its neighbour
        mark w as visited.
</pre>

<p>
<b>时间复杂度</b><br>
BFS的时间复杂度为 <code>O(V+E)</code> ，其中 <code>V</code> 是节点的数量， <code>E</code> 是边的数量。<br></p>

<p>
<b>BFS的应用场景</b><br></p>
<ul class="org-ul">
<li>最短路径问题<br>
</li>
<li>P2P网络，网络广播<br>
</li>
<li>GPS导航系统<br>
</li>
<li>搜索引擎的网络爬虫<br>
</li>
</ul>
</div>
</div>


<div id="outline-container-org63f294a" class="outline-2">
<h2 id="org63f294a">参考资料</h2>
<div class="outline-text-2" id="text-org63f294a">
<ul class="org-ul">
<li>
<a href="https://www.hackerearth.com/zh/practice/algorithms/graphs/breadth-first-search/tutorial/">hackerearth.com - breath first search tutorial</a><br>
</li>
<li>
<a href="http://www.cnblogs.com/abatei/archive/2010/02/25/1215114.html">cnblogs - 图的遍历</a><br>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Adjacency_matrix">wikipedia - adjacency matrix</a><br>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Adjacency_list">wikipedia - adjacency list</a><br>
</li>
<li>
<a href="https://baike.baidu.com/item/%E9%82%BB%E6%8E%A5%E8%A1%A8">百度百科 - 邻接表</a><br>
</li>
<li>
<a href="https://www.geeksforgeeks.org/applications-of-breadth-first-traversal/">geeksforgeeks - application of BFS</a><br>
</li>
</ul>
</div>
</div>

  </li>

</ul>
</div>




    

  <ul class="index-pager hidden-print">
<li class="previous">
        <a href="/index-7.html" rel="next">&lt; Older posts</a>
    </li>
    <li class="next">
        <a href="/index-5.html" rel="prev">Newer posts &gt;</a>
    </li>
  </ul>
</div>
  </main><footer class="site-footer h-card"><div class="wrapper">
      <div class="footer-col-wrapper">

        <div class="footer-col">
          <p class="site-desc">Personal handnote on software development</p>
        </div>

        <div class="footer-col">
          <div class="p-name">Samson Wang</div>
          <div class="copyright">Copyright 2023, all rights reserved.</div>
          <div class="social-links">
            <ul class="social-media-list">
<li><a rel="me" href="/rss.xml">
                <svg class="svg-icon grey"><use href="/assets/svg/social-icons.svg#rss"></use></svg></a></li>
              <li><a rel="nofollow" href="https://github.com/samsonwang">
                <svg class="svg-icon grey"><use href="/assets/svg/social-icons.svg#github"></use></svg></a></li>
              <li><a rel="nofollow" href="https://twitter.com/samsonwangcn">
                <svg class="svg-icon grey"><use href="/assets/svg/social-icons.svg#twitter"></use></svg></a></li>
              <li><a rel="nofollow" href="https://facebook.com/samsonwangcn">
                 <svg class="svg-icon grey"><use href="/assets/svg/social-icons.svg#facebook"></use></svg></a></li>
            </ul>
</div>

        </div>

      </div>

    </div>

  </footer><div id="scroll-top" title="back to top">
  <div id="scroll-top-arrow"></div>
  <div id="scroll-top-stick"></div>
</div>


      <script src="/assets/js/lazyload.min.js"></script><script src="/assets/js/minima.min.js"></script><!-- google adsense --><script data-ad-client="ca-pub-6303134192857919" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- Google Analytics - Global site tag (gtag.js) --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-108507797-1"></script><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-108507797-1');
</script><!-- baidu tongji --><script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?1dcffb5494ab56e69005c957d7320ad1";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>
</body>
</html>
