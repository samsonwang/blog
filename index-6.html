<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#" lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="Personal handnote on software development">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Hack Note (old posts, page 6) | Hack Note</title>
<link href="/assets/css/bootstrap.min.css" rel="stylesheet" type="text/css">
<link href="/assets/css/font-awesome.min.css" rel="stylesheet" type="text/css">
<link href="/assets/css/code.css" rel="stylesheet" type="text/css">
<link href="/assets/css/colorbox.css" rel="stylesheet" type="text/css">
<link href="/assets/css/highlight.css" rel="stylesheet" type="text/css">
<link href="/assets/css/cerulean.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="en" href="/rss.xml">
<link rel="canonical" href="https://samsonwang.me/index-6.html">
<link rel="icon" href="/favicon.ico" sizes="64x64">
<link rel="prev" href="/index-5.html" type="text/html">
<link rel="next" href="/index-7.html" type="text/html">
<!--[if lt IE 9]><script src="/assets/js/html5.js"></script><![endif]-->
</head>
<body class="preload">
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->
<nav id="top-nav" class="navbar navbar-expand-md fixed-top mb-4 navbar-dark bg-dark"><div class="container">   <!-- This keeps the margins nice -->
    <a class="navbar-brand" href="https://samsonwang.me/">

      <span id="blog-title">Hack Note</span>
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div class="collapse navbar-collapse" id="bs-navbar">
      <ul class="navbar-nav ml-auto">
<li class="nav-item">
<a href="/archive/" class="nav-link">Archives</a>
                </li>
<li class="nav-item">
<a href="/tags/" class="nav-link">Tags</a>
                </li>
<li class="nav-item">
<a href="/rss.xml" class="nav-link">RSS Feed</a>

        
      </li>
</ul>
<ul class="navbar-nav navbar-right"></ul>
</div>
<!-- /.navbar-collapse -->
  </div>
<!-- /.container -->
</nav><!-- End of Menubar --><div class="container" id="content" role="main">
  <div class="body-content">
    <!--Body content-->
    <div class="row">

      <div class="col-lg-9 col-md-9 col-sm-12 col-xs-12">
        
        


  



  


<div class="postindex">


  <article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/linux-command-examples-tcpdump/" class="u-url">Linux常用命令行指令 - tcpdump</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-03-25T23:34:53+08:00" itemprop="datePublished" title="2018-03-25 23:34">Mar 25 2018  (23:34)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/linux-command-examples-tcpdump/#disqus_thread" data-disqus-identifier="cache/archives/2018/linux-command-examples-tcpdump.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/linux/" rel="tag">linux</a></li>
        <li><a class="tag p-category" href="/tags/network/" rel="tag">network</a></li>
        <li><a class="tag p-category" href="/tags/shell/" rel="tag">shell</a></li>
        <li><a class="tag p-category" href="/tags/tcpdump/" rel="tag">tcpdump</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <p>
tcpdump常用于网络抓包，能够将抓取的包保存下来，这样就能进一步深入分析。抓包保存的文件可以使用tcpdump进行查看，也可以借助第三方软件（如wireshark）进行辅助分析。<br></p>

<div id="outline-container-orgb195ffd" class="outline-2">
<h2 id="orgb195ffd">1. 抓取指定网络设备上的包</h2>
<div class="outline-text-2" id="text-orgb195ffd">
<p>
抓取网卡eth0上的包<br></p>
<div class="highlight"><pre><span></span>tcpdump -i eth0
</pre></div>
</div>
</div>
<div id="outline-container-org196e9d1" class="outline-2">
<h2 id="org196e9d1">2. 限制抓包的数量</h2>
<div class="outline-text-2" id="text-org196e9d1">
<p>
只抓取5个包<br></p>
<div class="highlight"><pre><span></span>tcpdump -c 5 -i eth0
</pre></div>
</div>
</div>
<div id="outline-container-orgdfd431f" class="outline-2">
<h2 id="orgdfd431f">3. 将抓取的包以ASCII的方式打印出来</h2>
<div class="outline-text-2" id="text-orgdfd431f">
<div class="highlight"><pre><span></span>tcpdump -A -i eth0
</pre></div>
</div>
</div>
<div id="outline-container-org9d8fe9d" class="outline-2">
<h2 id="org9d8fe9d">4. 将抓取的包以十六进制的方式打印出来</h2>
<div class="outline-text-2" id="text-org9d8fe9d">
<div class="highlight"><pre><span></span>tcpdump -XX -i eth0
</pre></div>
</div>
</div>
<div id="outline-container-org261de2b" class="outline-2">
<h2 id="org261de2b">5. 对抓取到的包上打出更方便阅读的时间戳</h2>
<div class="outline-text-2" id="text-org261de2b">
<p>
增加 <code>-t</code> 参数能够将抓取到的包中的时间以方便阅读的形式打印出来，使用 <code>-tttt</code> 参数能够将包中的时间戳以更详细的方式打印出来。<br></p>
<div class="highlight"><pre><span></span>tcpdump -t -i eth0
tcpdump -tttt -i eth0
</pre></div>
</div>
</div>
<div id="outline-container-orgaf886b6" class="outline-2">
<h2 id="orgaf886b6">6. 将抓取的包写入到文件中</h2>
<div class="outline-text-2" id="text-orgaf886b6">
<div class="highlight"><pre><span></span>tcpdump -w netdump.pcap -i eth0
</pre></div>
</div>
</div>
<div id="outline-container-org81dbc50" class="outline-2">
<h2 id="org81dbc50">7. 读取抓到的包</h2>
<div class="outline-text-2" id="text-org81dbc50">
<div class="highlight"><pre><span></span>tcpdump -r netdump.pcap
</pre></div>
</div>
</div>
<div id="outline-container-org3ce8d35" class="outline-2">
<h2 id="org3ce8d35">8. 在抓到的包中显示ip地址</h2>
<div class="outline-text-2" id="text-org3ce8d35">
<p>
增加 <code>-n</code> 参数不会解析主机名，增加 <code>-nn</code> 参数不会解析主机名和端口名<br></p>
<div class="highlight"><pre><span></span>tcpdump -n -i eth0
tcpdump -nn -i eth0
</pre></div>
</div>
</div>
<div id="outline-container-org508ac97" class="outline-2">
<h2 id="org508ac97">9. 以绝对值显示包的ISN号</h2>
<div class="outline-text-2" id="text-org508ac97">
<div class="highlight"><pre><span></span>tcpdump -S -i eth0
</pre></div>
</div>
</div>
<div id="outline-container-orgad75b21" class="outline-2">
<h2 id="orgad75b21">10. 对抓取到的包显示更详细的信息</h2>
<div class="outline-text-2" id="text-orgad75b21">
<p>
参数 <code>-v</code> 是verbose的缩写，以下命令表示对抓取到的包显示更详细的信息。<br></p>
<div class="highlight"><pre><span></span>tcpdump -v -i eth0
tcpdump -vv -i eth0
tcpdump -vvv -i eth0
</pre></div>
</div>
</div>
<div id="outline-container-orgf0f6f90" class="outline-2">
<h2 id="orgf0f6f90">11. 对抓到的包进行协议类型过滤</h2>
<div class="outline-text-2" id="text-orgf0f6f90">
<p>
支持的协议类型有：fddi, tr, wlan, ip, ip6, arp, rarp, decnet, tcp, udp<br>
以下命令只会抓取网卡eth0上的arp包<br></p>
<div class="highlight"><pre><span></span>tcpdump -i eth0 arp
</pre></div>
</div>
</div>
<div id="outline-container-org4656ca7" class="outline-2">
<h2 id="org4656ca7">12. 在抓包时对包进行大小过滤</h2>
<div class="outline-text-2" id="text-org4656ca7">
<p>
下面的命令会分别抓取大于1024字节和小于1024字节的包<br></p>
<div class="highlight"><pre><span></span>tcpdump -i eth0 greater 1024
tcpdump -i eth0 less 1024
</pre></div>
</div>
</div>
<div id="outline-container-org5dd4856" class="outline-2">
<h2 id="org5dd4856">13. 抓取指定端口上的包</h2>
<div class="outline-text-2" id="text-org5dd4856">
<div class="highlight"><pre><span></span>tcpdump -i eth0 port 22
</pre></div>
</div>
</div>
<div id="outline-container-orgf8c49a2" class="outline-2">
<h2 id="orgf8c49a2">14. 抓取发往指定目的和端口上包</h2>
<div class="outline-text-2" id="text-orgf8c49a2">
<p>
可以使用 <code>and</code> 和 <code>or</code> 对过滤条件进行组合以实现精确的抓包。<br></p>
<div class="highlight"><pre><span></span>tcpdump -w net_dump.pcap -i eth0 dst 10.181.140.216 and port 22
</pre></div>
</div>
</div>

<div id="outline-container-orgb638f54" class="outline-2">
<h2 id="orgb638f54">常用tcpdump命令示例</h2>
<div class="outline-text-2" id="text-orgb638f54">
<div class="highlight"><pre><span></span>tcpdump –i any 'port 8888'
tcpdump –i any 'tcp port 8888'
tcpdump –i any 'tcp src port 8888'
tcpdump –i any 'tcp src port 8888 and udp dst port 9999'
tcpdump -i any 'src host 127.0.0.1 and tcp src port 12345' -XX -nn -vv
</pre></div>
</div>
</div>

<div id="outline-container-org7e330db" class="outline-2">
<h2 id="org7e330db">参考资料</h2>
<div class="outline-text-2" id="text-org7e330db">
<ul class="org-ul">
<li>
<a href="https://danielmiessler.com/study/tcpdump/">danielmiessler.com tcpdump</a><br>
</li>
<li>
<a href="https://www.thegeekstuff.com/2010/08/tcpdump-command-examples/">thegeekstuff.com tcpdump</a><br>
</li>
</ul>
</div>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/linux-command-examples-nc/" class="u-url">Linux常用命令行指令 - nc</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-03-24T10:01:10+08:00" itemprop="datePublished" title="2018-03-24 10:01">Mar 24 2018  (10:01)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/linux-command-examples-nc/#disqus_thread" data-disqus-identifier="cache/archives/2018/linux-command-examples-nc.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/linux/" rel="tag">linux</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <p>
<code>nc</code> 命令是 <code>netcat</code> 的缩写，能够使用TCP或UDP协议读写网络连接中的数据，是一个方便可靠的调试工具。<br></p>

<div id="outline-container-org4799ce1" class="outline-2">
<h2 id="org4799ce1">1. 基本 <code>C/S</code> 模型</h2>
<div class="outline-text-2" id="text-org4799ce1">
<p>
作为服务端建立监听<br></p>
<div class="highlight"><pre><span></span>nc -l 127.0.0.1 8060
</pre></div>
<p>
作为客户端连接端口<br></p>
<div class="highlight"><pre><span></span>nc 172.0.0.1 8060
</pre></div>
<p>
但是需要注意的是，该服务端只允许一个客户端连接进来。<br><code>nc</code> 会默认以TCP协议运行，可以增加 <code>-u</code> 参数转换为UDP协议。<br></p>
</div>
</div>

<div id="outline-container-org21cef61" class="outline-2">
<h2 id="org21cef61">2. 文件传输</h2>
<div class="outline-text-2" id="text-org21cef61">
<p>
模拟客户端向服务端传输文件的示例代码如下，同理，也可以模拟服务端向客户端发送文件。<br></p>
<div class="highlight"><pre><span></span>nc -l 1234  &gt; filename.out
nc 127.0.0.1 1234 &lt; fielname.in
</pre></div>
</div>
</div>

<div id="outline-container-org48c0215" class="outline-2">
<h2 id="org48c0215">3. 连接远程系统</h2>
<div class="outline-text-2" id="text-org48c0215">
<p>
已连接http服务器为例，在作为客户端连接以后，可以向服务器发送 <code>GET /HTTP/1.1</code> 来获取网站的主页。<br>
示例代码如下<br></p>
<div class="highlight"><pre><span></span>print "GET /HTTP/1.0 \r\n"| nc host.example.com 80
</pre></div>
</div>
</div>

<div id="outline-container-orgd6b48d3" class="outline-2">
<h2 id="orgd6b48d3">4. 简易代理</h2>
<div class="outline-text-2" id="text-orgd6b48d3">
<p>
将nc命令嵌套使用，可以将一个端口中的数据转发到目的ip和端口。<br></p>
<div class="highlight"><pre><span></span>ncat -l 8080 | ncat 192.168.1.200 80
</pre></div>
<p>
通过上面的命令能够将本机8080端口的数据转发到192.168.1.200的80端口上，但是这样是单向的。可以建立 <code>fifo</code> 实现数据的双向传输。<br></p>
<div class="highlight"><pre><span></span>mkfifo ./fifo_temp
ncat -l 8080 0&lt;fifo_temp | ncat 192.168.1.200 80 1&gt;fifo_temp
</pre></div>
</div>
</div>

<div id="outline-container-orgf69c718" class="outline-2">
<h2 id="orgf69c718">5. 参考资料</h2>
<div class="outline-text-2" id="text-orgf69c718">
<ul class="org-ul">
<li>
<a href="https://www.linuxtechi.com/nc-ncat-command-examples-linux-systems/">linuxtech</a><br>
</li>
<li>
<a href="https://www.thegeekstuff.com/2012/04/nc-command-examples/?utm_source=feedburner">thegeekstuff</a><br>
</li>
<li>
<a href="https://www.computerhope.com/unix/nc.htm">computerhope</a><br>
</li>
</ul>
</div>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/linux-command-examples-lsof/" class="u-url">Linux常用命令行指令 - lsof</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-03-21T20:28:34+08:00" itemprop="datePublished" title="2018-03-21 20:28">Mar 21 2018  (20:28)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/linux-command-examples-lsof/#disqus_thread" data-disqus-identifier="cache/archives/2018/linux-command-examples-lsof.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/linux/" rel="tag">linux</a></li>
        <li><a class="tag p-category" href="/tags/shell/" rel="tag">shell</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <p>
lsof是list open files的简称，用于列出系统中所有打开的文件。由于在linux系统下，所有 对象都是文件，所以这个指令十分有用。<br></p>

<p>
下面就给出了几种常见的用法，需要注意的是有些指令需要root权限执行。<br></p>

<div id="outline-container-org10bdefa" class="outline-2">
<h2 id="org10bdefa">1. 查看打开指定文件的进程</h2>
<div class="outline-text-2" id="text-org10bdefa">
<div class="highlight"><pre><span></span>lsof /var/syslog.log
</pre></div>
</div>
</div>

<div id="outline-container-orgcd1136d" class="outline-2">
<h2 id="orgcd1136d">2. 查看指定目录下打开的文件</h2>
<div class="outline-text-2" id="text-orgcd1136d">
<div class="highlight"><pre><span></span>lsof +D /home/
</pre></div>
</div>
</div>

<div id="outline-container-org96f5ee7" class="outline-2">
<h2 id="org96f5ee7">3. 查看以指定进程名所有打开的文件</h2>
<div class="outline-text-2" id="text-org96f5ee7">
<p>
使用 <code>-c</code> 命令能够查看指定进程名使用的文件，允许在一个命令行指令中使用多个 <code>-c</code> 参数。<br></p>
<div class="highlight"><pre><span></span>lsof -c procname
</pre></div>
</div>
</div>

<div id="outline-container-orgb712026" class="outline-2">
<h2 id="orgb712026">4. 查看使用指定挂载点的进程</h2>
<div class="outline-text-2" id="text-orgb712026">
<p>
在停止挂载某个目录时，系统会告诉我们“设备资源繁忙”，所以我们需要找出使用挂载点的程序，终止这些进程，解除目录的占用状态。<br></p>
<div class="highlight"><pre><span></span>lsof /home
</pre></div>
<p>
或<br></p>
<div class="highlight"><pre><span></span>lsof +D /home/
</pre></div>
</div>
</div>

<div id="outline-container-org1848233" class="outline-2">
<h2 id="org1848233">5. 查看指定用户打开的文件</h2>
<div class="outline-text-2" id="text-org1848233">
<div class="highlight"><pre><span></span>lsof -u username
</pre></div>
<p>
另外还可以进行反向过滤，在输出中不显示指定用户的文件，语法如下。<br></p>
<div class="highlight"><pre><span></span>lsof -u ^username
</pre></div>
</div>
</div>

<div id="outline-container-org887167b" class="outline-2">
<h2 id="org887167b">6. 查看指定进程打开的文件</h2>
<div class="outline-text-2" id="text-org887167b">
<div class="highlight"><pre><span></span>lsof -p pid
</pre></div>
</div>
</div>

<div id="outline-container-org4ef3842" class="outline-2">
<h2 id="org4ef3842">7. 终止属于某个用户的所有进程</h2>
<div class="outline-text-2" id="text-org4ef3842">
<div class="highlight"><pre><span></span>kill `lsof -t -u username`
</pre></div>
<p>
相似的，可以使用 <code>-t</code> 参数打印使用某个文件的进程id。<br></p>
<div class="highlight"><pre><span></span>lsof -t /var/log
</pre></div>
</div>
</div>

<div id="outline-container-org6987d53" class="outline-2">
<h2 id="org6987d53">8. 让结果同时满足多个选项</h2>
<div class="outline-text-2" id="text-org6987d53">
<p>
默认情况下，多个参数是以或（or）进行操作的，可以使用 <code>-a</code> 选项让结果同时满足多个参数。<br></p>
<div class="highlight"><pre><span></span>lsof -a -u username -c procname
</pre></div>
</div>
</div>

<div id="outline-container-org59f9ef8" class="outline-2">
<h2 id="org59f9ef8">9. 让命令重复执行</h2>
<div class="outline-text-2" id="text-org59f9ef8">
<p>
可以使用 <code>-r</code> 参数让命令重复执行。以下命令会每隔5s执行一次，每次的执行结果会用 “====” 分割开。<br></p>
<div class="highlight"><pre><span></span>lsof -u username -c procname -a -r5
</pre></div>
</div>
</div>

<div id="outline-container-org20f1bb1" class="outline-2">
<h2 id="org20f1bb1">10. 列出所有的网络连接</h2>
<div class="outline-text-2" id="text-org20f1bb1">
<div class="highlight"><pre><span></span>lsof -i
</pre></div>
<p>
让结果中的ip地址和端口号显示数字而不是英文别名<br></p>
<div class="highlight"><pre><span></span>lsof -i -Pn
</pre></div>
<p>
显示所有的 <code>AF_UNIX</code> socket<br></p>
<div class="highlight"><pre><span></span>lsof -U
</pre></div>
</div>
</div>

<div id="outline-container-org923dcac" class="outline-2">
<h2 id="org923dcac">11. 列出指定进程使用的网络连接</h2>
<div class="outline-text-2" id="text-org923dcac">
<div class="highlight"><pre><span></span>lsof -i -a -p pid
</pre></div>
</div>
</div>

<div id="outline-container-org27485a8" class="outline-2">
<h2 id="org27485a8">12. 查看指定端口上的监听</h2>
<div class="outline-text-2" id="text-org27485a8">
<div class="highlight"><pre><span></span>lsof -i :portid
</pre></div>
</div>
</div>

<div id="outline-container-orged90a5b" class="outline-2">
<h2 id="orged90a5b">13. 列出所有tcp和udp连接</h2>
<div class="outline-text-2" id="text-orged90a5b">
<div class="highlight"><pre><span></span>lsof -i tcp; lsof -i udp
</pre></div>
</div>
</div>

<div id="outline-container-org0e04d97" class="outline-2">
<h2 id="org0e04d97">14. 列出所有的网络文件系统</h2>
<div class="outline-text-2" id="text-org0e04d97">
<p>
网络文件系统（network file system）<br></p>
<div class="highlight"><pre><span></span>lsof -N -u username
</pre></div>
</div>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/differences-among-overload-override-and-hide/" class="u-url">重载、覆盖和隐藏的区别</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-03-19T21:51:03+08:00" itemprop="datePublished" title="2018-03-19 21:51">Mar 19 2018  (21:51)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/differences-among-overload-override-and-hide/#disqus_thread" data-disqus-identifier="cache/archives/2018/differences-among-overload-override-and-hide.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/cpp/" rel="tag">cpp</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <p>
<b>重载（overload）</b> ：就是函数或者方法有相同的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。<br>
多个重载函数在调用的时候根据函数的参数来区别不同的函数。<br>
关键点：函数名相同，参数表不同<br></p>

<p>
<b>覆盖（override）</b> ：是指在派生类中重新对基类中的虚函数重新实现，即函数名和参数都一样，只是函数的实现体不一样。<br>
关键词：派生类中，虚函数，函数名和参数表完全相同<br></p>

<p>
<b>隐藏（hide）</b> ：派生类中的函数把基类中相同名字的函数屏蔽掉了。<br>
隐藏一词可以这么理解:在调用一个类的成员函数的时候,编译器会沿着类的继承链逐级的向上查找函数的定义,如果找到了那么就停止查找了,所以如果一个派生类和一个基类都有同一个同名(暂且不论参数是否相同)的函数,而编译器最终选择了在派生类中的函数,那么我们就说这个派生类的成员函数"隐藏"了基类的成员函数,也就是说它阻止了编译器继续向上查找函数的定义.<br></p>


<p>
关于这三种情况的示例代码如下<br></p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream.h&gt;</span><span class="cp"></span>
<span class="k">class</span> <span class="nc">Base</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Base::f(float) "</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">g</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Base::g(float) "</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">h</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Base::h(float) "</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Derived::f(float) "</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">g</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Derived::g(int) "</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">h</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Derived::h(float) "</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>

<p>
从以上代码能够看出：<br>
（1）函数Derived::f(float)覆盖了Base::f(float)。<br>
（2）函数Derived::g(int)隐藏了Base::g(float)，而不是重载。<br>
（3）函数Derived::h(float)隐藏了Base::h(float)，而不是覆盖。<br></p>

<p>
考虑代码在运行时的结果：<br></p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">Derived</span>  <span class="n">d</span><span class="p">;</span>
  <span class="n">Base</span> <span class="o">*</span><span class="n">pb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">;</span>
  <span class="n">Derived</span> <span class="o">*</span><span class="n">pd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">;</span>

  <span class="c1">// Good : behavior depends solely on type of the object</span>
  <span class="n">pb</span><span class="o">-&gt;</span><span class="n">f</span><span class="p">(</span><span class="mf">3.14f</span><span class="p">);</span> <span class="c1">// Derived::f(float) 3.14</span>
  <span class="n">pd</span><span class="o">-&gt;</span><span class="n">f</span><span class="p">(</span><span class="mf">3.14f</span><span class="p">);</span> <span class="c1">// Derived::f(float) 3.14</span>

  <span class="c1">// Bad : behavior depends on type of the pointer</span>
  <span class="n">pb</span><span class="o">-&gt;</span><span class="n">g</span><span class="p">(</span><span class="mf">3.14f</span><span class="p">);</span> <span class="c1">// Base::g(float) 3.14</span>
  <span class="n">pd</span><span class="o">-&gt;</span><span class="n">g</span><span class="p">(</span><span class="mf">3.14f</span><span class="p">);</span> <span class="c1">// Derived::g(int) 3        (surprise!)</span>

  <span class="c1">// Bad : behavior depends on type of the pointer</span>
  <span class="n">pb</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">(</span><span class="mf">3.14f</span><span class="p">);</span> <span class="c1">// Base::h(float) 3.14      (surprise!)</span>
  <span class="n">pd</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">(</span><span class="mf">3.14f</span><span class="p">);</span> <span class="c1">// Derived::h(float) 3.14</span>
<span class="p">}</span>
</pre></div>

<p>
在第一种调用中，函数的行为取决于指针所指向的对象。在第二第三种调用中，函数的行为取决于指针的类型。所以说，隐藏破坏了面向对象编程中多态这一特性，会使得开发人员产生混乱。<br></p>


<p>
<b>函数接口设计注意要点</b><br>
在设计基类的函数接口时，不要出现既是虚函数，又对该虚函数进行了重载的情况。这样会对派生类的多态函数实现造成不便。<br>
示例代码如下<br></p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Base</span>
<span class="p">{</span>
  <span class="k">virtual</span> <span class="n">foo</span><span class="p">();</span>
  <span class="k">virtual</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span>
<span class="p">{</span>
  <span class="k">virtual</span> <span class="n">foo</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
<p>
从以上代码能够看出：<br></p>
<ol class="org-ol">
<li>
<code>Derived::foo()</code> 与 <code>Base::foo()</code> 构成了多态关系<br>
</li>
<li>
<code>Derived::foo()</code> 隐藏了 <code>Base::foo(int)</code><br>
</li>
</ol>
<p>
所以，如果派生类希望实现 <code>foo()</code> 函数的多态，也就必须实现 <code>foo(int)</code> 的多态，否则就会出现隐藏。<br>
如果在现有代码中已经发生了上述 <code>Base</code> 的情况，在不改变原有代码的情况下，可以使用在派生类中使用这样的语法 <code>using Base::foo;</code> ，这会将基类中所有的名为 <code>foo</code> 的函数引入到派生类中来。<br></p>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/qt-chinese-encoding/" class="u-url">关于Qt中使用中文编码的一些问题</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-02-28T09:34:08+08:00" itemprop="datePublished" title="2018-02-28 09:34">Feb 28 2018  (09:34)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/qt-chinese-encoding/#disqus_thread" data-disqus-identifier="cache/archives/2018/qt-chinese-encoding.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/qt/" rel="tag">qt</a></li>
        <li><a class="tag p-category" href="/tags/visual-studio/" rel="tag">visual studio</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <p>
Qt库作为一个开源库，并且支持多语言。在开发时需要考虑字符编码问题。<br>
我现在的使用Qt开发环境为VS2012+Qt5.1.1，所以一下所讨论的也是基于这个版本而言的。目前Qt5已经将 <code>tr()</code> 删掉了。<br></p>

<p>
<b>在windows下使用Qt库进行开发</b><br>
有两种主流开发环境:<br></p>
<ol class="org-ol">
<li>使用Qt Creator作为开发环境<br>
</li>
<li>使用Visual Studio + Visual Assist + Qt Visual Studio Addon作为开发环境<br>
</li>
</ol>
<p>
目前我使用的就是第二种开发环境，鉴于在Windows平台下没有哪个开发环境能与Visual Studio相媲美。<br></p>

<p>
<b>使用VS开发Qt程序时需要注意源文件的编码格式</b><br>
Qt5官方推荐的源文件编码格式为UTF-8，QString内部的编码格式就是UTF-8，使用QtCreator创建的源文件的编码格式也是UTF-8 without BOM。<br>
但是VS在中文操作系统上，如果不进行特殊的设置，默认创建的含有中文的源文件编码格式为gb3212。这样的原始字符串就是gb2312格式的，在使用时需要进行特殊转换，这样显示在界面上才不会乱码。<br>
推荐使用一下两种方法解决gb2312编码问题：<br></p>
<ul class="org-ul">
<li>
<code>QString::fromLocale8Bit()</code> 会将gb2312编码的字符串转换为UTF-8格式以便存放在QString中。<br>
</li>
<li>
<code>QStringLiteral()</code> 是一个宏定义，会在编译期将字符串实例化，对静态字符串使用这个字符串也是一个提高效率的方法(因为减少了运行时的内存申请开销)。<br>
</li>
</ul>
<p>
<b>在VS中使用utf-8 with BOM的源文件格式</b><br>
如果使用了utf-8 with BOM的源文件格式，VS会将其中的字符串转换为gb2312编码的中文，这样是为了兼容旧版本的编译器。<br>
可以使用编译选项让VS编译器不进行这项转换，这样就可以直接使用字符串 <code>char*</code> 初始化QString了。<br></p>
<ul class="org-ul">
<li>微软在VS2010中提供了 <code>#pragma execution_character_set("utf-8")</code> 这样的编译选项，能够防止编译器进行文件编码转换，保证字符串保留utf-8格式。<br>
</li>
<li>VS2012 并不支持以上编译选项，VS2012将这个特性取消了<br>
</li>
<li>VS2015 可以使用 <code>/utf-8</code> 让编译器能够识别 utf-8 without BOM格式的文件，并保留utf-8的字符串编码。<br>
</li>
</ul>
<p>
<b>C++11的编码格式支持</b><br>
对于支持C++11标准的编译器，可以采用如下的写法产生utf-8格式的字符串。<br></p>
<div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">szMsg</span> <span class="o">=</span> <span class="sa">u8</span><span class="s">"字符串"</span><span class="p">;</span>
</pre></div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/use-git-with-socks5-proxy/" class="u-url">为git设置socks5代理</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-02-08T09:26:07+08:00" itemprop="datePublished" title="2018-02-08 09:26">Feb 08 2018  (09:26)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/use-git-with-socks5-proxy/#disqus_thread" data-disqus-identifier="cache/archives/2018/use-git-with-socks5-proxy.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/git/" rel="tag">git</a></li>
        <li><a class="tag p-category" href="/tags/socks5/" rel="tag">socks5</a></li>
        <li><a class="tag p-category" href="/tags/vpn/" rel="tag">vpn</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <p>
在某些时候，为了绕过网络封锁，在使用git时需要借助代理完成相关网络操作。<br></p>

<div id="outline-container-org8e1ed95" class="outline-2">
<h2 id="org8e1ed95">一个可用的VPN代理是先决条件</h2>
<div class="outline-text-2" id="text-org8e1ed95">
<p>
关于VPN的架设就不在此讨论了。<br></p>
</div>
</div>

<div id="outline-container-orge03c8e9" class="outline-2">
<h2 id="orge03c8e9">将repo的链接由ssh改为为https</h2>
<div class="outline-text-2" id="text-orge03c8e9">
<p>
已经使用https的repo跳过此步骤。<br>
本教程需要通过https（http）的方式使用代理，所以如果现有的repo是使用ssh方式clone到本地的，需要修改其为https方式。<br>
需要修改 <code>repo_name/.git/config</code> 中的url配置，将其中的git格式改为https格式。使用文本编辑工具将其打开进行修改，以github为例，需要将 <code>git@github.com:user_name/repo_name.git</code> 改为 <code>https://github.com/user_name/repo_name.git</code> 。<br>
可以使用sed指令完成替换。<br></p>
<div class="highlight"><pre><span></span>sed -i 's/git@github.com:/git:\/\/github.com\//' ./.git/config
</pre></div>
</div>
</div>

<div id="outline-container-org3d70c54" class="outline-2">
<h2 id="org3d70c54">设置git使用代理</h2>
<div class="outline-text-2" id="text-org3d70c54">
<p>
将git配置为使用socks5代理，以socks5的ip和端口是 <code>127.0.0.1:1080</code> 为例。<br></p>
<div class="highlight"><pre><span></span>git config --global http.proxy 'socks5://127.0.0.1:1080'
git config --global https.proxy 'socks5://127.0.0.1:1080'
</pre></div>
</div>
</div>

<div id="outline-container-org74420bb" class="outline-2">
<h2 id="org74420bb">将登录信息缓存下来</h2>
<div class="outline-text-2" id="text-org74420bb">
<p>
使用https时，在向远程仓库进行推送（git push）时会要求验证用户名和密码，由于每次都输入验证信息是十分繁琐的，考虑将验证信息缓存下来。<br></p>
<div class="highlight"><pre><span></span>git config --global credential.helper cache
</pre></div>
<p>
git默认会将密码缓存15分钟，在这期间进行的操作是不需要再次进行密码验证的，可以使用下面命令修改缓存的时长。<br></p>
<div class="highlight"><pre><span></span>git config --global credential.helper "cache --timeout=3600"
</pre></div>
</div>
</div>

<div id="outline-container-org96e002f" class="outline-2">
<h2 id="org96e002f">将登陆信息保存下来</h2>
<div class="outline-text-2" id="text-org96e002f">
<p>
也可以考虑将用户名和密码永久保存下来，这样就不需要再次进行密码验证了。<br><b>注意:</b> 使用这种配置会将明文的账户和密码保存在 <code>~/.git-cretidentials</code> 文件中，所以仅推荐在个人电脑中使用这个配置。<br></p>
<div class="highlight"><pre><span></span>git config --global credential.helper store
</pre></div>
</div>
</div>

<div id="outline-container-orgf6271fa" class="outline-2">
<h2 id="orgf6271fa">参考资料</h2>
<div class="outline-text-2" id="text-orgf6271fa">
<ul class="org-ul">
<li>
<a href="https://stackoverflow.com/questions/5343068/is-there-a-way-to-skip-password-typing-when-using-https-on-github">stackoverflow question</a><br>
</li>
</ul>
<p>
（全文完）<br></p>
</div>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/cpp-development-framework-on-windows/" class="u-url">windows平台下的C++开发框架</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-02-07T22:56:21+08:00" itemprop="datePublished" title="2018-02-07 22:56">Feb 07 2018  (22:56)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/cpp-development-framework-on-windows/#disqus_thread" data-disqus-identifier="cache/archives/2018/cpp-development-framework-on-windows.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/atl/" rel="tag">atl</a></li>
        <li><a class="tag p-category" href="/tags/cpp/" rel="tag">cpp</a></li>
        <li><a class="tag p-category" href="/tags/mfc/" rel="tag">mfc</a></li>
        <li><a class="tag p-category" href="/tags/win32/" rel="tag">win32</a></li>
        <li><a class="tag p-category" href="/tags/windows/" rel="tag">windows</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <p>
在开发windows应用程序时，经常会遇到win32、mfc、atl的函数。下面就对三种API（或者说是开发框架）进行了总结。<br></p>

<div id="outline-container-org972f43d" class="outline-2">
<h2 id="org972f43d">Win32开发框架</h2>
<div class="outline-text-2" id="text-org972f43d">
<p>
win32开发框架是最基础的函数接口，更接近操作系统底层。<br>
使用Win32接口的优点是程序的依赖最小，生成的可执行文件的体积也最小。<br></p>
</div>
</div>

<div id="outline-container-org757a855" class="outline-2">
<h2 id="org757a855">MFC开发框架</h2>
<div class="outline-text-2" id="text-org757a855">
<p>
MFC是Microsoft Foundation Class的缩写，将win32的相关接口按照OOP的思想封装了起来，目的是提供一个快速开发原生应用的框架。<br>
使用MFC开发的程序体型略显臃肿，而且MFC也比较陈旧了，并不推荐使用MFC进行开发。<br></p>
</div>
</div>

<div id="outline-container-orgcd972d8" class="outline-2">
<h2 id="orgcd972d8">ATL开发框架</h2>
<div class="outline-text-2" id="text-orgcd972d8">
<p>
ATL是Active Template Library的缩写，是针对COM组件的开发实现的一套开发框架。ATL简化了ActiveX COM组件的开发。<br></p>
</div>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/emacs-search-string-in-directory-recursively/" class="u-url">使用emacs在目录中递归搜索字符串</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-02-06T21:28:14+08:00" itemprop="datePublished" title="2018-02-06 21:28">Feb 06 2018  (21:28)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/emacs-search-string-in-directory-recursively/#disqus_thread" data-disqus-identifier="cache/archives/2018/emacs-search-string-in-directory-recursively.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/emacs/" rel="tag">emacs</a></li>
        <li><a class="tag p-category" href="/tags/grep/" rel="tag">grep</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <p>
对文件中的字符串搜索是开发中经常遇到的情景，下面就对常见的搜索字符串的方式进行了总结。<br></p>

<p>
<b>对当前buffer进行搜索（单个文件）</b><br><code>C-s</code> 向后搜索<br><code>C-r</code> 向后搜索<br><code>M-s o</code> 使用occur对当前buffer中的指定关键字进行统计<br>
在安装了helm以后可以使用 <code>helm-occur</code> 完成当前buffer的搜索<br></p>

<p>
<b>对目录中的指定文件进行搜索（一个目录下的多个文件）</b><br><code>C-x d</code> 进入dired模式，在dired模式中使用 <code>M-x &lt;dired-do-find-regexp&gt;</code> (快捷键 <code>A</code> )对标记的文件进行搜索。<br></p>

<p>
<b>对目录中的所有文件进行递归搜索（一个目录下的所有文件和所有子目录中的文件）</b><br><code>M-x &lt;rgrep&gt;</code> 能够对一个目录下所有的文件进行正则表达式匹配<br></p>

<p>
<b>注意事项</b><br>
在windows平台上使用grep和find指令时，需要借助仿linux环境中的程序完成，如cygwin中的程序。<br>
需要将程序的路径添加到系统环境变量path中，并且为了覆盖windows系统自带的find命令，需要将该路径放在系统find路径之前。<br>
tips： 对于安装了 <code>git bash</code> 的同学，直接将其中的 <code>mingw64\bin</code> 的绝对路径加入系统path中即可。<br></p>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/shadowsock-server-setup-guide/" class="u-url">ss服务器的配置指南</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-02-05T22:57:35+08:00" itemprop="datePublished" title="2018-02-05 22:57">Feb 05 2018  (22:57)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/shadowsock-server-setup-guide/#disqus_thread" data-disqus-identifier="cache/archives/2018/shadowsock-server-setup-guide.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/linux/" rel="tag">linux</a></li>
        <li><a class="tag p-category" href="/tags/shadowsocks/" rel="tag">shadowsocks</a></li>
        <li><a class="tag p-category" href="/tags/vpn/" rel="tag">vpn</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <p>
租一个服务器自己搭建梯子是科学上网方便稳定快捷的好方法。<br>
本文主要是自己部署vpn服务端的笔记，作为备忘留存下来。<br></p>

<div id="outline-container-org796c8a1" class="outline-2">
<h2 id="org796c8a1">安装ss服务程序</h2>
<div class="outline-text-2" id="text-org796c8a1">
<p>
安装环境为CentOS7, 需要使用python的包管理工具pip完成对ss-server的安装。<br></p>
<div class="highlight"><pre><span></span>sudo yum install m2crypto python-setuptools
sudo easy_install pip
sudo pip install shadowsocks
</pre></div>
</div>
</div>

<div id="outline-container-orgac18f93" class="outline-2">
<h2 id="orgac18f93">配置ss服务器</h2>
<div class="outline-text-2" id="text-orgac18f93">
<p>
<b>配置文件示例</b> : <a href="/listings/shadowsocks.json.html">shadowsocks.json</a><br>
这份配置中使用了多个端口作供ss-server使用<br></p>
<div class="highlight"><pre><span></span>{
    "server":"your-server-ip",
    "local_address":"127.0.0.1",
    "local_port":1080,
    "port_password":
    {
	"32366":"shadowsocks",
	"32367":"shadowsocks",
	"32368":"shadowsocks",
	"32369":"shadowsocks",
	"52369":"shadowsocks"
    },
    "timeout":300,
    "method":"aes-256-cfb",
    "fast_open": false
}
</pre></div>


<p>
<b>启动脚本示例</b> : <a href="/listings/ss.sh.html">ss.sh</a><br>
直接在命令行直接输入指令也能够完成ss服务的启动和停止，使用脚本只是为了方便一些。<br></p>
<div class="highlight"><pre><span></span>#!/bin/bash
ss_start()
{
  ssserver -c /root/shadowsocks/shadowsocks.json -d start
}
ss_stop()
{
  ssserver -c /root/shadowsocks/shadowsocks.json -d stop
}
# shell script main
if [ "$#" -eq "0" ]; then
  ss_start
else
  case "$1" in
  start)
    ss_start
    exit;;
  stop)
    ss_stop
    exit;;
  esac
fi
</pre></div>

<p>
<b>增加系统启动项</b><br>
可以将启动脚本加入系统启动项，这样就能够保证在每次reboot后，服务都能自动开启。<br></p>
</div>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/git-cheatsheet/" class="u-url">常用git操作备忘</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-01-19T12:39:16+08:00" itemprop="datePublished" title="2018-01-19 12:39">Jan 19 2018  (12:39)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/git-cheatsheet/#disqus_thread" data-disqus-identifier="cache/archives/2018/git-cheatsheet.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/cheatsheet/" rel="tag">cheatsheet</a></li>
        <li><a class="tag p-category" href="/tags/git/" rel="tag">git</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <p>
update: 2018-02-15<br></p>

<p>
对常用指令进行总结，方便以后遇到相同情况时查阅。<br></p>
<div id="outline-container-org300d646" class="outline-2">
<h2 id="org300d646">1 撤销与回退相关</h2>
<div class="outline-text-2" id="text-org300d646">
</div>
<div id="outline-container-org4efd944" class="outline-3">
<h3 id="org4efd944">1.1 修正最近的提交消息</h3>
<div class="outline-text-3" id="text-org4efd944">
<p>
<b>情景</b> ：在最近的一次提交（ <code>git commit</code> ）中输入的信息有误，并且这次提交没有被推送（ <code>git push</code> ）到远程仓库。<br><b>方法</b> ： <code>git commit --amend</code> 或 <code>git commit --amend -m "correct_message"</code><br><b>说明</b> ： <code>git commit --amend</code> 会使用一个新的提交更新并替换最近的一次提交，如果有在临时区域（staged）的修改，也会合并提交；如果有新的提交信息，则会一并提交。<br></p>
</div>
</div>

<div id="outline-container-org9903880" class="outline-3">
<h3 id="org9903880">1.2 撤销本地变更</h3>
<div class="outline-text-3" id="text-org9903880">
<p>
<b>情景</b> ：当无意中修改了一个文件，想要回退这个文件的修改时。<br><b>方法</b> ： <code>git checkout -- &lt;filename&gt;</code><br><b>说明</b> ：这条指令会把该文件回退到某个git记录中的版本，git默认会回退到 <code>HEAD</code> 版本。<br></p>
</div>
</div>

<div id="outline-container-org8e5d905" class="outline-3">
<h3 id="org8e5d905">1.3 重置本地修改</h3>
<div class="outline-text-3" id="text-org8e5d905">
<p>
<b>情景</b> ：已经进行了多次提交，但是没有推送到版本库中，希望撤销这些提交。<br><b>方法</b> ： <code>git reset &lt;last good SHA&gt;</code> 或 <code>git reset --hard &lt;last good SHA&gt;</code><br><b>说明</b> ： <code>git reset</code> 会把本地代码恢复到没有提交（ <code>git commit</code> ）的状态，做出的修改会保留。 <code>git reset --hard</code> 会把这些修改丢弃掉。<br></p>
</div>
</div>

<div id="outline-container-org96264d3" class="outline-3">
<h3 id="org96264d3">1.4 恢复被重置的本地修改</h3>
<div class="outline-text-3" id="text-org96264d3">
<p>
<b>情景</b> ：在按照1.3中操作后，想恢复重置以前的状态。<br><b>方法</b> ： <code>git reflog</code> 后执行 <code>git reset</code> 或 <code>git checkout</code><br><b>说明</b> ： <code>git reflog</code> 会呈现所有提交过的历史，是一个十分实用的功能。<br></p>
</div>
</div>
</div>

<div id="outline-container-org24112ca" class="outline-2">
<h2 id="org24112ca">2 分支操作相关</h2>
<div class="outline-text-2" id="text-org24112ca">
</div>
<div id="outline-container-orge03aa56" class="outline-3">
<h3 id="orge03aa56">2.1 创建一个本地分支并推送到远端</h3>
<div class="outline-text-3" id="text-orge03aa56">
<p>
<b>方法</b> ：<br></p>
<div class="highlight"><pre><span></span>git branch branch_name
git push origin branch_name
</pre></div>
</div>
</div>

<div id="outline-container-orgb6c102c" class="outline-3">
<h3 id="orgb6c102c">2.2 在本地创建一个远程分支</h3>
<div class="outline-text-3" id="text-orgb6c102c">
<p>
<b>方法</b> ：<br></p>
<div class="highlight"><pre><span></span>git fetch origin
git checkout -b  branch_name origin/branch_name
</pre></div>
</div>
</div>

<div id="outline-container-org4eed36f" class="outline-3">
<h3 id="org4eed36f">2.3 在分支上进行进度迁移</h3>
<div class="outline-text-3" id="text-org4eed36f">
<p>
<b>情景</b> ： 进行了几次提交后，发现自己正在错误的分支上干活。<br><b>方法</b> ：<br></p>
<div class="highlight"><pre><span></span>git branch feature
git reset --hard origin/master
git checkout feature
</pre></div>
<p>
<b>原理</b> ： 使用feature分支复制了当前分支，将当前分支回退到初始状态，在feature分支上接着干活。<br></p>
</div>
</div>
</div>


<div id="outline-container-org4a2a1fe" class="outline-2">
<h2 id="org4a2a1fe">3 git submodule 相关操作</h2>
<div class="outline-text-2" id="text-org4a2a1fe">
</div>
<div id="outline-container-org232ace2" class="outline-3">
<h3 id="org232ace2">3.1 向当前repo中增加一个submodule</h3>
<div class="outline-text-3" id="text-org232ace2">
<div class="highlight"><pre><span></span>git submoudle add &lt;module url&gt; &lt;local path&gt;
</pre></div>
</div>
</div>

<div id="outline-container-orgb4847e7" class="outline-3">
<h3 id="orgb4847e7">3.2 初始化submodule</h3>
<div class="outline-text-3" id="text-orgb4847e7">
<p>
在将一个具有submodule的repo拉取到本地以后需要对submodule进行初始化<br></p>
<div class="highlight"><pre><span></span>git submodule init
</pre></div>
</div>
</div>

<div id="outline-container-orga615ce6" class="outline-3">
<h3 id="orga615ce6">3.3 更新submodule</h3>
<div class="outline-text-3" id="text-orga615ce6">
<p>
在开发中可以直接进入submodule的目录对每一个submodule执行更新操作，也可以使用命令统一完成submodule的更新操作。<br></p>
<div class="highlight"><pre><span></span>git submodule update
</pre></div>
</div>
</div>

<div id="outline-container-org6866352" class="outline-3">
<h3 id="org6866352">3.4 删掉submodule</h3>
<div class="outline-text-3" id="text-org6866352">
<p>
对于不需要的submodule，可以将其删掉。<br></p>
<div class="highlight"><pre><span></span>git submodule rm &lt;local/path&gt;
</pre></div>
</div>
</div>
</div>

<div id="outline-container-org09357ce" class="outline-2">
<h2 id="org09357ce">终端配置</h2>
<div class="outline-text-2" id="text-org09357ce">
<p>
使用命令简称方便操作<br></p>
<div class="highlight"><pre><span></span># git related
alias g='git status --short -b'
alias ga='git add'
alias gb='git branch'
alias gc='git commit -m'
alias gd='git diff'
alias gco='git checkout'
alias gps='git push'
alias gpl='git pull'
</pre></div>
</div>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/emacs-find-replace-string-in-directory/" class="u-url">使用emacs查找替换指定目录所有文件中字符串</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-01-17T10:18:46+08:00" itemprop="datePublished" title="2018-01-17 10:18">Jan 17 2018  (10:18)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/emacs-find-replace-string-in-directory/#disqus_thread" data-disqus-identifier="cache/archives/2018/emacs-find-replace-string-in-directory.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/dired/" rel="tag">dired</a></li>
        <li><a class="tag p-category" href="/tags/emacs/" rel="tag">emacs</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <p>
本文主要介绍在emacs中对一个目录中的很多文件进行字符串查找和替换操作的方法。参考了 <a href="http://ergoemacs.org/emacs/blog.html">XahLee</a> 的教程后，在此记录做个备份。<br></p>
<div id="outline-container-org177dae4" class="outline-2">
<h2 id="org177dae4">操作步骤</h2>
<div class="outline-text-2" id="text-org177dae4">
<p>
<b>进入dired模式</b> ： 我的快捷键配置为 <code>C-x d</code>, 也可以使用 <code>M-x &lt;dired&gt;</code> .<br><b>标记需要查找的文件</b> ： 在进入dired模式后，对需要操作的文件或目录进行操作。<br></p>
<ul class="org-ul">
<li>
<code>m</code> 对光标所在的文件或目录进行标记<br>
</li>
<li>
<code>u</code> 对光标所在的文件或目录取消标记<br>
</li>
<li>
<code>U</code> 取消所有标记<br>
</li>
</ul>
<p>
可以通过 <code>M-x &lt;dired-mark-files-regexp&gt;</code> 使用正则表达式完成批量文件增加标记。<br><b>批量查找</b> ： 使用 <code>M-x &lt;dired-do-query-replace-regexp&gt;</code> 进行查找替换。在有 <code>grep</code> 的支持时（linux环境下或windows环境中增加了类似cygwin的程序），也可以使用 <code>&lt;dired-do-find-regexp-and-replace&gt;</code> 进行文本查找替换。<br><b>查找结果</b> ： 在查找结果中使用如下快捷键完成操作<br></p>
<ul class="org-ul">
<li>
<code>y</code> 对当前记录执行替换操作<br>
</li>
<li>
<code>n</code> 跳过当前记录<br>
</li>
<li>
<code>C-g</code> 停止本次查找替换操作<br>
</li>
<li>
<code>!</code> 同意本文件中的查找替换操作<br>
</li>
<li>
<code>N</code> 跳过本文件中的查找替换操作<br>
</li>
<li>
<code>Y</code> 同意本次所有的查找替换操作<br>
</li>
</ul>
</div>
</div>

<div id="outline-container-org94339ea" class="outline-2">
<h2 id="org94339ea">相关技巧</h2>
<div class="outline-text-2" id="text-org94339ea">
<p>
如果需要批量查找(不进行替换)，可以在dired模式中 <code>M-x &lt;dired-do-search&gt;</code> 进行查找，对于查找结果使用 <code>M-x tags-loop-continue</code> 进行逐条浏览。<br></p>
</div>
</div>
    </div>

  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/stl-iterator-invalidate/" class="u-url">STL容器的迭代器失效问题</a></h1>
      <div class="metadata">
        

        
  <div class="date blur-1">
    <time class="published dt-published" datetime="2018-01-10T22:06:04+08:00" itemprop="datePublished" title="2018-01-10 22:06">Jan 10 2018  (22:06)
    </time>
</div>

        
    <div class="comment blur-1">
      
        
    <a href="/posts/stl-iterator-invalidate/#disqus_thread" data-disqus-identifier="cache/archives/2018/stl-iterator-invalidate.html">Comments</a>


    </div>

        
    <div class="tags blur-2">
    <ul itemprop="keywords">
<li><a class="tag p-category" href="/tags/cpp/" rel="tag">cpp</a></li>
        <li><a class="tag p-category" href="/tags/stl/" rel="tag">STL</a></li>
        <li><a class="tag p-category" href="/tags/syntax/" rel="tag">syntax</a></li>
    </ul>
</div>

      </div>
    </header><div class="p-summary entry-summary">
      <div id="outline-container-orgaae8363" class="outline-2">
<h2 id="orgaae8363">1 引言</h2>
<div class="outline-text-2" id="text-orgaae8363">
<p>
常见的STL容器都能使用迭代器访问容器内元素，迭代器相同于一个指向容器内元素的指针，可以通过移动迭代器实现遍历容器。<br>
但是在使用迭代器时需要考虑STL容器的失效问题；迭代器失效主要出现在对容器进行了增删操作之后，迭代器不再指向原本的元素。<br>
这时如果再通过迭代器访问容器就有可能出现异常。<br></p>
</div>
</div>

<div id="outline-container-org3118cb2" class="outline-2">
<h2 id="org3118cb2">2 map容器</h2>
<div class="outline-text-2" id="text-org3118cb2">
<p>
<b>内部数据结构</b> ：红黑树<br><b>插入操作</b> ：插入操作会申请新的节点空间，然后加入都红黑树中，原来的迭代器指向的内存空间都未改变，故不会出现迭代器失效。<br><b>删除操作</b> ：删除操作只会引起被删除节点的迭代器失效。<br></p>
</div>
</div>

<div id="outline-container-org6169ae1" class="outline-2">
<h2 id="org6169ae1">3 vector容器</h2>
<div class="outline-text-2" id="text-org6169ae1">
<p>
<b>内部数据结构</b> ：数组(一段连续内存空间)<br><b>插入操作</b> ：由于vector使用的是一段有长度限制的连续空间，插入( <code>push_back</code> / <code>insert</code> )操作在vector中加入新的元素时需要分情况考虑。<br></p>
<ul class="org-ul">
<li>当vector中元素总数仍不大于capacity，这时插入位置后的元素都被依次移动到下一个位置，所以插入位置之后的迭代器都会失效。<br>
</li>
<li>当vector中元素总数大于capacity，这个时候会重新开辟更大的内存空间，将原来的vector中的内容复制到新的vector中，回收原先vector的内存空间。由于新的vector的地址已完全改变，所以原先的所有迭代器都会失效。<br>
</li>
</ul>
<p>
<b>删除操作</b> ：删除( <code>pop_back</code> / <code>erase</code> )操作在vector中删除元素，删除位置后的元素都被依次复制到前一个位置，所以删除位置之后的迭代器都会失效。<br>
示例代码：<br></p>
</div>
</div>

<div id="outline-container-org2147e9c" class="outline-2">
<h2 id="org2147e9c">4 list容器</h2>
<div class="outline-text-2" id="text-org2147e9c">
<p>
<b>内部数据结构</b> ：双向环状链表<br><b>插入操作</b> ：插入操作会申请新的节点空间，然后加入到链表中，原来的迭代器指向的内存空间都未改变，故不会出现迭代器失效。<br><b>删除操作</b> ：删除操作只会引起被删除节点的迭代器失效。<br></p>
</div>
</div>

<div id="outline-container-org9ff98b5" class="outline-2">
<h2 id="org9ff98b5">5 小结</h2>
<div class="outline-text-2" id="text-org9ff98b5">
<p>
在操作STL容器时，对容器增删（ <code>erase</code> / <code>insert</code> ）之后应该注意接收返回值，这样可以有效避免迭代器失效的产生。<br>
对容器进行遍历删除操作时，另一种语法技巧是在 <code>erase</code> 接口中对迭代器进行后自增（it++），这种写法也能够保证遍历正常进行。理解这种写法需要参考运算符重载的相关知识，后自增操作会产生一个临时变量用于函数返回。<br></p>
</div>
</div>
    </div>

  </article>
</div>



        
       <script>var disqus_shortname="samsonwang-me";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script>
</div>

      <div class="col-lg-3 col-md-3 col-sm-12 col-xs-12 sidebar">
       
<div class="sidebar-module sidebar-module-inset">
  <h4>About Me</h4>
  
        <div class="sidebar-aboutme">
        <p>Zeal for coding, C++ developer. Focus on linux server dev. I use EMACS, and I am learning python.</p>
        <p>View my code on <a href="https://github.com/samsonwang"> Github</a></p>
</div>
</div>

       
<div class="sidebar-module">
  <h4>Categories</h4>
  
        <ol class="list-unstyled sidebar-category">
<li>
<a href="/tags/category-cpp/">cpp</a>
        </li>
<li>
<a href="/tags/category-emacs/">emacs</a>
        </li>
<li>
<a href="/tags/category-linux/">linux</a>
        </li>
<li>
<a href="/tags/category-windows/">windows</a>
        </li>
</ol>
</div>

      </div>
<!--.sidebar-->
    </div>
<!--.row-->

    

        <nav class="postindexpager"><ul class="pager">
<li class="next">
                <a href="/index-5.html" rel="prev">Newer posts</a>
            </li>
            <li class="previous">
                <a href="/index-7.html" rel="next">Older posts</a>
            </li>
        </ul></nav><!--End of body content--><footer id="footer"><div class="text-center">
<p>Contents © 2017-2019 <a href="mailto:wangzhilv@gmail.com">Samson Wang</a>
 - Powered by <a href="https://getnikola.com/" rel="nofollow">Nikola</a>
 - Hosted on <a href="https://pages.github.com/" rel="nofollow">Github Pages</a>
 - 
<a rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/"><img alt="知识共享许可协议" style="padding-bottom:2px" src="https://i.creativecommons.org/l/by-nc/4.0/80x15.png"></a>
</p>
</div>

      
    </footer>
</div>
</div>

<div id="scroll-top" title="back to top">
  <div id="scroll-top-arrow"></div>
  <div id="scroll-top-stick"></div>
</div>


            <script src="/assets/js/jquery.min.js"></script><script src="/assets/js/jquery.colorbox-min.js"></script><script src="/assets/js/jquery.lazyload.min.js"></script><script src="/assets/js/popper.min.js"></script><script src="/assets/js/bootstrap.min.js"></script><script src="/assets/js/moment-with-locales.min.js"></script><script src="/assets/js/fancydates.js"></script><script src="/assets/js/cerulean.js"></script><!-- fancy dates --><script>
  moment.locale("en");
  fancydates(0, "YYYY-MM-DD HH:mm");
</script><!-- end fancy dates --><!-- Baidu Analytics --><script>
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?7ec47c52179b8ca4f9aee81282bd7b20";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>
</body>
</html>
