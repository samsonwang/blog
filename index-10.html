<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns#" lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta http-equiv="x-ua-compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Hack Note (old posts, page 10) | Hack Note</title>
<meta name="description" content="Personal handnote on software development">
<meta name="theme-color" content="#04519b">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" href="/rss.xml">
<link href="/assets/css/minima.min.css" rel="stylesheet" type="text/css">
<link rel="canonical" href="https://blog.wangzhl.com/index-10.html">
<link rel="icon" href="/favicon.ico" sizes="64x64">
<link rel="prev" href="/index-9.html" type="text/html">
<link rel="next" href="/index-11.html" type="text/html">
</head>
<body>
  <header class="site-header nav-custom"><div class="wrapper">
      <a class="site-title" rel="author" href="/">Hack Note</a>
      <nav class="site-nav"><input type="checkbox" id="nav-trigger" class="nav-trigger"><label for="nav-trigger">
          <span class="menu-icon">
            <svg viewbox="0 0 18 15" width="18px" height="15px"><use href="/assets/svg/theme.svg#menu-icon"></use></svg></span>
        </label>
        <div class="trigger">
          
            <a class="page-link" href="/">Home</a>
            <a class="page-link" href="/archive/">Archive</a>
            <a class="page-link" href="/tags/">Tags</a>
            <a class="page-link" href="/about/">About</a>

        </div>
      </nav>
</div>
  </header><main class="page-content" aria-label="Content"><div class="wrapper">

    

    


  



  


<div class="home">
  <ul class="post-list">
<li>
    <span class="post-meta">Jun 07, 2018</span>
    <h3>
      <a class="post-link" href="/posts/cloud-server-security/">云服务器安全相关配置</a>
    </h3>

    <p>
我所租用的云服务器操作系统为CentOS Linux，在使用云服务器的过程中为了保证服务器的安全，进行了一些简单的配置，这样能够增加服务器被破解的难度。<br></p>

  </li>


  <li>
    <span class="post-meta">May 16, 2018</span>
    <h3>
      <a class="post-link" href="/posts/c-style-and-cpp-style-file-api/">C风格和C++风格的文件操作库函数总结</a>
    </h3>

    <p>
由于C++是兼容C的，所以使用C++进行文件操作时，会发现有两套库函数可以使用，它们分别是C风格的和C++风格的。<br></p>

<div id="outline-container-org7f978ca" class="outline-2">
<h2 id="org7f978ca">C风格的文件操作函数</h2>
<div class="outline-text-2" id="text-org7f978ca">
<p>
<b>打开文件，关闭文件</b><br></p>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="nf">fopen</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">path</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">mode</span><span class="p">);</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">fclose</span><span class="p">(</span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">fp</span><span class="p">);</span><span class="w"></span>
</pre></div>

<p>
<b>读取文件，写入文件</b><br></p>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="kt">size_t</span><span class="w"> </span><span class="nf">fread</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">nmemb</span><span class="p">,</span><span class="w"> </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
<span class="kt">size_t</span><span class="w"> </span><span class="nf">fwrite</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">nmemb</span><span class="p">,</span><span class="w"> </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>
关于fread中两个表示大小的参数，在这个 <a href="https://stackoverflow.com/questions/8589425/how-does-fread-really-work">stackoverflow</a> 问题中得到了比较好的解答。<br></p>


<p>
<b>改变文件指示器的位置</b><br></p>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">fseek</span><span class="p">(</span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">whence</span><span class="p">);</span><span class="w"></span>
<span class="kt">long</span><span class="w"> </span><span class="nf">ftell</span><span class="p">(</span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">rewind</span><span class="p">(</span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</div>


<div id="outline-container-orgeca4970" class="outline-2">
<h2 id="orgeca4970">C++风格的文件操作函数</h2>
<div class="outline-text-2" id="text-orgeca4970">
<p>
C++将文件操作函数封装为 <code>fstream</code> 操作类，一个文件实际上就会对应一个 <code>fstream</code> 对象，一下函数都是 <code>fstream</code> 的成员函数。<br>
文件打开和关闭<br></p>
<div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">open</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="n">ios_base</span><span class="o">::</span><span class="n">openmode</span><span class="w"> </span><span class="n">mode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ios_base</span><span class="o">::</span><span class="n">in</span><span class="o">|</span><span class="n">ios_base</span><span class="o">::</span><span class="n">out</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">open</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="n">ios_base</span><span class="o">::</span><span class="n">openmode</span><span class="w"> </span><span class="n">mode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ios_base</span><span class="o">::</span><span class="n">in</span><span class="o">|</span><span class="n">ios_base</span><span class="o">::</span><span class="n">out</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">close</span><span class="p">();</span><span class="w"></span>
</pre></div>

<p>
对于文件的读写可以才采用流运算符重载的方法完成。<br></p>
<div class="highlight"><pre><span></span><span class="k">friend</span><span class="w"> </span><span class="n">fstream</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">fstream</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ofs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">CRecord</span><span class="o">&amp;</span><span class="w"> </span><span class="n">objRecord</span><span class="p">);</span><span class="w"></span>
<span class="k">friend</span><span class="w"> </span><span class="n">fstream</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">fstream</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ifs</span><span class="p">,</span><span class="w"> </span><span class="n">CRecord</span><span class="o">&amp;</span><span class="w"> </span><span class="n">objRecord</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</div>


<div id="outline-container-orgfa5880d" class="outline-2">
<h2 id="orgfa5880d">题外话</h2>
<div class="outline-text-2" id="text-orgfa5880d">
<p>
在liunx下，可以使用wc命令查看文件中的相关信息。wc命令会打印出该文件的行数、单词数、字符数。<br></p>
</div>
</div>

  </li>


  <li>
    <span class="post-meta">May 11, 2018</span>
    <h3>
      <a class="post-link" href="/posts/endianness-and-union-type/">字节序与union类型</a>
    </h3>

    <div id="outline-container-orgb429afc" class="outline-2">
<h2 id="orgb429afc">字节序是什么</h2>
<div class="outline-text-2" id="text-orgb429afc">
<p>
字节序是指在数据传输时，高位字节存储在内存中的较高位地址还是较低位地址。字节序分为大端字节序和小端字节序，两种字节序不能混用。<br></p>

<ul class="org-ul">
<li>大端字节序 ：高位字节保存在较低位地址的内存中<br>
</li>
<li>小端字节序 ：高位字节保存在较高位地址的内存中<br>
</li>
</ul>
<p>
以 <code>int n = 0x12345678;</code> 为例，大端字节序内存中的存储的顺序为 <code>0x12 0x34 0x56 0x78</code> ，小端字节序内存中的存储顺序为 <code>0x78 0x56 0x34 0x12</code> 。很明显可以看出大端字节序更符合人类的阅读习惯。<br></p>

<ul class="org-ul">
<li>常见的大端系统CPU：IBM z/Atchitecture<br>
</li>
<li>常见的小端系统CPU：intel x86<br>
</li>
</ul>
<p>
网络字节序使用的大端字节序，常用网络协议如IPv4、IPv6、TCP和UDP协议都是使用大端字节序进行数据传输的。<br></p>
</div>
</div>



<div id="outline-container-orgfdb94c6" class="outline-2">
<h2 id="orgfdb94c6">提供字节序转换功能的函数接口</h2>
<div class="outline-text-2" id="text-orgfdb94c6">
<p>
在网络通信接口中提供了转换主机字节序和网络字节序之间的函数接口，如下所示。<br></p>
<div class="highlight"><pre><span></span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">htonl</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">hostlong</span><span class="p">);</span><span class="w"></span>
<span class="kt">uint16_t</span><span class="w"> </span><span class="nf">htons</span><span class="p">(</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">hostshort</span><span class="p">);</span><span class="w"></span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="nf">ntohl</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">netlong</span><span class="p">);</span><span class="w"></span>
<span class="kt">uint16_t</span><span class="w"> </span><span class="nf">ntohs</span><span class="p">(</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">netshort</span><span class="p">);</span><span class="w"></span>
</pre></div>

<p>
有些时候，我们需要手动转换内存字节流，可以使用以下接口帮助实现指定字节序的转换。<br></p>

<p>
小端字节序的函数实现如下：<br></p>
<div class="highlight"><pre><span></span><span class="c1">// small endian</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="w"> </span><span class="nf">SE_GetStreamU16</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">pTemp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="p">(</span><span class="n">pTemp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">pTemp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">SE_GetStreamU32</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">pTemp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="p">(</span><span class="n">pTemp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"></span>
<span class="w">			 </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">pTemp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"></span>
<span class="w">			 </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">pTemp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"></span>
<span class="w">			 </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">pTemp</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">24</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">SE_SetStreamU16</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">pTemp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">pTemp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">pTemp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">SE_SetStreamU32</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">pTemp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">pTemp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">pTemp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">pTemp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">16</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">pTemp</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">24</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<p>
大端字节序的函数实现如下：<br></p>
<div class="highlight"><pre><span></span><span class="c1">// big endian</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="w"> </span><span class="nf">BE_GetStreamU16</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">pTemp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="p">(</span><span class="n">pTemp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">pTemp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">BE_GetStreamU32</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">pTemp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="p">(</span><span class="n">pTemp</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"></span>
<span class="w">			 </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">pTemp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"></span>
<span class="w">			 </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">pTemp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"></span>
<span class="w">			 </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">pTemp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">24</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">BE_SetStreamU16</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">pTemp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">pTemp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">pTemp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">BE_SetStreamU32</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">pTemp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">pTemp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">24</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">pTemp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">16</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">pTemp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">pTemp</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>



<div id="outline-container-orgfc3caa8" class="outline-2">
<h2 id="orgfc3caa8">查看当前系统的字节序</h2>
<div class="outline-text-2" id="text-orgfc3caa8">
<p>
通过 <code>lscpu</code> 命令，能得到cpu的大端和小端信息。<br></p>
<div class="highlight"><pre><span></span>lscpu <span class="p">|</span> grep -i endian
</pre></div>

<p>
通过常用shell命令，在大端系统中会输出0，在小端系统中会输出1。<br></p>
<div class="highlight"><pre><span></span><span class="nb">echo</span> -n I <span class="p">|</span> od -to2 <span class="p">|</span> head -n1 <span class="p">|</span> cut -f2 -d<span class="s2">" "</span> <span class="p">|</span> cut -c6
</pre></div>

<p>
借助python进行判断。<br></p>
<div class="highlight"><pre><span></span>python -c <span class="s2">"import sys; print(sys.byteorder)"</span>
<span class="c1"># or</span>
python -c <span class="s2">"import sys;sys.exit(0 if sys.byteorder=='big' else 1)"</span>
</pre></div>

<p>
借助linux的ELF进行判断，查看第6个字节，小端系统中为1，大端系统中为2。<br></p>
<div class="highlight"><pre><span></span>xxd -c <span class="m">1</span> -l <span class="m">6</span> /bin/bash
<span class="c1"># or</span>
hexdump -n <span class="m">6</span> -C /bin/bash
</pre></div>

<p>
可以使用union类型验证字节序，以下示例代码在不同的字节序下会有不同的输出。<br></p>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;inttypes.h&gt;</span><span class="cp"></span>

<span class="k">typedef</span><span class="w"> </span><span class="k">union</span><span class="w"> </span><span class="nc">un</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">ch</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">un</span><span class="p">;</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">un</span><span class="w"> </span><span class="n">u</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">u</span><span class="p">.</span><span class="n">ch</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">u</span><span class="p">.</span><span class="n">ch</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">u</span><span class="p">.</span><span class="n">ch</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">u</span><span class="p">.</span><span class="n">ch</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">"u.x=0x%x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">u</span><span class="p">.</span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>


<div id="outline-container-org546b154" class="outline-2">
<h2 id="org546b154">参考资料</h2>
<div class="outline-text-2" id="text-org546b154">
<ul class="org-ul">
<li>
<a href="https://en.wikipedia.org/wiki/Endianness">wikipedia.com - endianness</a><br>
</li>
<li>
<a href="https://serverfault.com/questions/163487/how-to-tell-if-a-linux-system-is-big-endian-or-little-endian">serverfault.com - how to check endian</a><br>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">wikipedia.com - ELF format</a><br>
</li>
</ul>
<p>
（全文完）<br></p>
</div>
</div>

  </li>


  <li>
    <span class="post-meta">May 05, 2018</span>
    <h3>
      <a class="post-link" href="/posts/python-logging-with-function-name/">在Python日志中输出文件名和函数名</a>
    </h3>

    <p>
Python内置了日志模块，在默认情况下输出的日志是不带文件名和函数名的，这样在排查问题时，遇到相似的日志就变得容易混淆，可以通过设置将输出的日志中带有文件名和函数名。参考了stackoverflow的回答，详细代码如下。<br></p>

<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">logging</span>
<span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">'root'</span><span class="p">)</span>
<span class="n">LOG_FORMAT</span> <span class="o">=</span> <span class="s2">"</span><span class="si">%(filename)s</span><span class="s2">:</span><span class="si">%(lineno)s</span><span class="s2"> </span><span class="si">%(funcName)s</span><span class="s2">() </span><span class="si">%(message)s</span><span class="s2">"</span>
<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="n">LOG_FORMAT</span><span class="p">)</span>
<span class="n">log</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
</pre></div>

<p>
<b>参考资料</b><br><a href="https://stackoverflow.com/questions/10973362/python-logging-function-name-file-name-line-number-using-a-single-file">stackoverflow</a><br></p>

  </li>


  <li>
    <span class="post-meta">Apr 27, 2018</span>
    <h3>
      <a class="post-link" href="/posts/linux-command-examples-xargs/">Linux常用命令行指令 - xargs</a>
    </h3>

    <div id="outline-container-org8fb8121" class="outline-2">
<h2 id="org8fb8121">基础用法</h2>
<div class="outline-text-2" id="text-org8fb8121">
<p>
<code>xargs</code> 指令默认情况下从 <code>stdin</code> 中读取信息，按照空格分或换行区分开，并且执行输入的命令（默认的命令是 <code>/bin/echo</code> ）。命令可以通过 <code>xargs</code> 的参数指定执行一次或多次，命令的执行参数为自身初始参数追加上由 <code>stdin</code> 读到的内容，命令在执行时会忽略空行。<br></p>

<blockquote>
<p>
xargs reads items from the standard input, delimited by blanks (which can be protected with double or single quotes or a backslash) or newlines, and executes the command (default is /bin/echo) one or more times with any initial-arguments followed by items read from standard input. Blank lines on the standard input are ignored.<br></p>
</blockquote>

<p>
在命令行输入 <code>xargs</code> 命令，输入 “a b c d” 后按回车，再按 <code>ctrl+d</code> 完成本次输入，则 <code>xargs</code> 的默认 <code>echo</code> 命令会将接收到的字符串打印出来，效果如下所示。<br></p>
<div class="highlight"><pre><span></span># xargs
a b c d
a b c d
</pre></div>

<p>
<code>xargs</code> 单独使用时功能比较单一，但是它与其他指令一起使用十分强大。<br></p>
</div>
</div>

<div id="outline-container-org1942bb8" class="outline-2">
<h2 id="org1942bb8">
<code>xargs</code> 与 <code>find</code> 组合使用</h2>
<div class="outline-text-2" id="text-org1942bb8">
<p>
常见的使用方法是使用 <code>find</code> 指令找到指定的文件，组合以 <code>xargs</code> 指令实现对指定文件的操作。<br></p>
<div class="highlight"><pre><span></span>find . -name "demo_" | xargs file -i
</pre></div>
<p>
由于 <code>xargs</code> 是使用空格作为各个参数的分隔符，如果遇到的文件名中含有空格，则并不能按照预期处理。这时，可以使用 <code>find</code> 指令的 <code>-print0</code> 将含有空格的文件名转化为字符串，再结合 <code>xargs</code> 的 <code>-0</code> 参数就能完成文件名中含有空格的处理，改进后的命令如下。<br></p>
<div class="highlight"><pre><span></span>find . -name "demo_" -print0 | xargs -0 file -i
</pre></div>
</div>
</div>

<div id="outline-container-org9df945c" class="outline-2">
<h2 id="org9df945c">
<code>xargs</code> 与 <code>grep</code> 组合使用</h2>
<div class="outline-text-2" id="text-org9df945c">
<p>
常用命令如下，能够实现对指定规则文件的搜索匹配。<br></p>
<div class="highlight"><pre><span></span>find . -name "*.log" | xargs grep error
</pre></div>
</div>
</div>

<div id="outline-container-orgff825ef" class="outline-2">
<h2 id="orgff825ef">使用 <code>-n</code> 参数让 <code>xargs</code> 的命令重复执行</h2>
<div class="outline-text-2" id="text-orgff825ef">
<p>
如果想用 <code>find</code> 指令完成多个匹配规则的搜索，则可以使用 <code>-n</code> 参数将 <code>xargs</code> 的内容分割成多个。<br>
下面的命令会执行3次 <code>find</code> 命令， <code>xargs</code> 会将接收的到的内容按照单词数为“1”分割，分3次传送给 <code>find</code> 指令。<br></p>
<div class="highlight"><pre><span></span>echo "*.c" "*.cpp" "*.h" | xargs -n 1 find . -name
</pre></div>
</div>
</div>

<div id="outline-container-org112680e" class="outline-2">
<h2 id="org112680e">使用 <code>-t</code> 参数让 <code>xargs</code> 打印将要执行的命令</h2>
<div class="outline-text-2" id="text-org112680e">
<p>
让 <code>xargs</code> 将指令的命令打印出来主要是方便查看命令执行情况，也方便在出现错误时进行调试。<br></p>
<div class="highlight"><pre><span></span>find . -name *.log | xargs -t rm -f
</pre></div>
</div>
</div>

<div id="outline-container-orge034b01" class="outline-2">
<h2 id="orge034b01">使用 <code>-p</code> 参数让 <code>xargs</code> 在执行命令前询问用户</h2>
<div class="outline-text-2" id="text-orge034b01">
<p>
增加 <code>-p</code> 参数后， <code>xargs</code> 在每次执行命令前会将指令打印出来并询问用户，只有用户输入 “y” 时才会真正执行该条命令。<br></p>
<div class="highlight"><pre><span></span>echo "*.c" "*.cpp" "*.h" | xargs -n 1 -p find . -name
</pre></div>
</div>
</div>

<div id="outline-container-org3801bb9" class="outline-2">
<h2 id="org3801bb9">使用 <code>-I</code> 参数让 <code>xargs</code> 进行参数替换</h2>
<div class="outline-text-2" id="text-org3801bb9">
<p>
<code>xargs</code> 默认会将读取到的内容追加在指令命令后面作为参数，使用 <code>-I</code> 参数能够控制命令参数的组合方式。<br>
以下命令会将当前目录中的可执行文件移动到bin文件夹下。<br></p>
<div class="highlight"><pre><span></span>find . -executable -type f -print0 | xargs -0 -I {} mv {} ./bin
</pre></div>
</div>
</div>

<div id="outline-container-org2a14f31" class="outline-2">
<h2 id="org2a14f31">参考资料</h2>
<div class="outline-text-2" id="text-org2a14f31">
<ol class="org-ol">
<li>
<a href="http://man7.org/linux/man-pages/man1/xargs.1.html">http://man7.org/linux/man-pages/man1/xargs.1.html</a><br>
</li>
<li>
<a href="https://www.howtoforge.com/tutorial/linux-xargs-command/">https://www.howtoforge.com/tutorial/linux-xargs-command/</a><br>
</li>
<li>
<a href="https://www.thegeekstuff.com/2013/12/xargs-examples">https://www.thegeekstuff.com/2013/12/xargs-examples</a><br>
</li>
</ol>
<p>
（全文完）<br></p>
</div>
</div>

  </li>


  <li>
    <span class="post-meta">Apr 25, 2018</span>
    <h3>
      <a class="post-link" href="/posts/linux-command-examples-ipcs/">Linux常用命令行指令 - ipcs</a>
    </h3>

    <p>
<code>IPC</code> 是 <code>inter process communication</code> 的缩写，这项技术能够让进程间相互通信。<br>
Q：每个进程都有自己的地址空间和独立的用户空间，那么进程间是如何通信的呢？<br>
A：内核，也就是操作系统的心脏，它能够访问整个操作系统的内存。我们可以要求内核分配一块用于进程间交互的空间。<br></p>

<div id="outline-container-org796548e" class="outline-2">
<h2 id="org796548e">几种进程间通信的方法</h2>
<div class="outline-text-2" id="text-org796548e">
<p>
进程间通信的方法有很多，有些支持同机器上进程的信息交互，有些支持跨机器的进程交互。<br></p>
<ul class="org-ul">
<li>
<b>管道</b> ： pipes，管道提供了进程间交换信息的方法。<br>
</li>
<li>
<b>共享内存</b> ： shared memory，一个进程创建一块其他进程能够访问的内存空间，多个进程可以通过共享内存进行数据交换。<br>
</li>
<li>
<b>消息队列</b> ： message queue，消息队列是一个固定结构、有序的内存段，多个进程可以存放和取回数据。<br>
</li>
<li>
<b>信号量</b> ： semaphores，信号量提供了多进程访问同一资源的同步机制，信号量不负责传递数据，它协调对共享资源的访问。<br>
</li>
</ul>
</div>
</div>

<div id="outline-container-org385350c" class="outline-2">
<h2 id="org385350c">常用ipcs指令</h2>
<div class="outline-text-2" id="text-org385350c">
<p>
<b>列出所有的IPC设备</b><br></p>
<div class="highlight"><pre><span></span>ipcs -a
</pre></div>

<p>
<b>列出所有的消息队列</b><br></p>
<div class="highlight"><pre><span></span>ipcs -q
</pre></div>

<p>
<b>列出所有的信号量</b><br></p>
<div class="highlight"><pre><span></span>ipcs -s
</pre></div>

<p>
<b>列出所有的共享内存</b><br></p>
<div class="highlight"><pre><span></span>ipcs -m
</pre></div>

<p>
<b>获取与IPC设备信息</b><br></p>
<div class="highlight"><pre><span></span>ipcs -q -i msq_id
</pre></div>

<p>
<b>列出IPC设备的限制</b><br></p>
<div class="highlight"><pre><span></span>ipcs -l
</pre></div>

<p>
<b>列出IPC设备的创建者和拥有者</b><br></p>
<div class="highlight"><pre><span></span>ipcs -m -c
</pre></div>

<p>
<b>列出最近使用IPC设备的进程id</b><br></p>
<div class="highlight"><pre><span></span>ipcs -m -p
</pre></div>

<p>
<b>列出IPC设备的最后访问时间</b><br></p>
<div class="highlight"><pre><span></span>ipcs -s -t
</pre></div>

<p>
<b>列出IPC设备的当前使用状态</b><br></p>
<div class="highlight"><pre><span></span>ipcs -u
</pre></div>
</div>
</div>

  </li>


  <li>
    <span class="post-meta">Apr 20, 2018</span>
    <h3>
      <a class="post-link" href="/posts/debug-with-gdb-on-multi-thread-programs/">使用gdb调试多线程程序</a>
    </h3>

    <div id="outline-container-orgf9c53de" class="outline-2">
<h2 id="orgf9c53de">查看当前线程信息</h2>
<div class="outline-text-2" id="text-orgf9c53de">
<p>
<b>将进程中的各个线程信息显示出来</b><br></p>
<div class="highlight"><pre><span></span>(gdb) info threads
</pre></div>

<p>
<b>切换到指定进程</b><br></p>
<div class="highlight"><pre><span></span>(gdb) thread tid
</pre></div>

<p>
<b>向指定的线程发送自定的指令</b><br></p>
<div class="highlight"><pre><span></span>(gdb) thread apply tid/all args
</pre></div>
<p>
常用的指定是查看所有线程的调用堆栈 <code>thread apply all bt</code> ，这个指令与 <code>pstack</code> 命令有些相似。<br></p>

<p>
<b>gdb默认会自动捕捉新产生线程</b><br>
会在产生一个新的线程时会显示出LWP的字样提示用户，LWP = light weight process<br>
可以设置gdb是否提示线程相关的事件<br></p>
<div class="highlight"><pre><span></span>(gdb) set print thread-events on/off
(gdb) show print thread-events
</pre></div>
</div>
</div>

<div id="outline-container-orgc166daa" class="outline-2">
<h2 id="orgc166daa">为指定的线程设置断点</h2>
<div class="outline-text-2" id="text-orgc166daa">
<p>
含有多线程的程序，可以为单独的线程设置断点<br></p>
<div class="highlight"><pre><span></span>(gdb) break linespec thread tid
</pre></div>

<p>
任何时候当你的程序在GDB模式下停止的时候，包括当前调试线程的所有线程都会停下来，不会对继续对当前进程造成更改。这时你可以在线程间进行切换，查看整个进程的执行状况。<br></p>
<blockquote>
<p>
Whenever your program stops under GDB for any reason, all threads of execution stop, not just the current thread. This allows you to examine the overall state of the program, including switching between threads, without worrying that things may change underfoot.<br></p>
</blockquote>
</div>
</div>

<div id="outline-container-org745a25a" class="outline-2">
<h2 id="org745a25a">防止gdb自动切换线程</h2>
<div class="outline-text-2" id="text-org745a25a">
<p>
在调试gdb程序时，在单步执行时，会出现线程间跳转切换，这样对跟踪代码执行状态十分不方便。<br>
可以通过设置 <code>scheduler-locking</code> 让gdb在所调试的线程中运行，防止线程的自动切换。<br></p>
<div class="highlight"><pre><span></span>(gdb) set scheduler-locking step
</pre></div>
<p>
可以执行以下命令查看当前 <code>scheduler-locking</code> 的设置<br></p>
<div class="highlight"><pre><span></span>(gdb) show scheduler-locking
</pre></div>
<p>
<code>scheduler-locking</code> 有三种模式<br></p>
<ol class="org-ol">
<li>
<code>off</code> 任何线程在任何时候都能执行<br>
</li>
<li>
<code>on</code> 只有当前线程能够执行<br>
</li>
<li>
<code>step</code> 为单步执行优化的模式，比较适合一般的调试<br>
</li>
</ol>
<blockquote>
<p>
Set the scheduler locking mode. If it is off, then there is no locking and any thread may run at any time. If on, then only the current thread may run when the inferior is resumed. The step mode optimizes for single-stepping. It stops other threads from "seizing the prompt" by preempting the current thread while you are stepping. Other threads will only rarely (or never) get a chance to run when you step. They are more likely to run when you `next' over a function call, and they are completely free to run when you use commands like `continue', `until', or `finish'. However, unless another thread hits a breakpoint during its timeslice, they will never steal the GDB prompt away from the thread that you are debugging.<br></p>
</blockquote>
</div>
</div>


<div id="outline-container-org278a3e1" class="outline-2">
<h2 id="org278a3e1">参考资料</h2>
<div class="outline-text-2" id="text-org278a3e1">
<ol class="org-ol">
<li>
<a href="https://ftp.gnu.org/old-gnu/Manuals/gdb/html_node/gdb_39.html">gnu manual 1</a><br>
</li>
<li>
<a href="https://ftp.gnu.org/old-gnu/Manuals/gdb/html_node/gdb_24.html">gun manual 2</a><br>
</li>
<li>
<a href="https://sourceware.org/gdb/onlinedocs/gdb/Threads.html">sourceware gdb onlinedocs</a><br>
</li>
<li>
<a href="http://www.drdobbs.com/cpp/multithreaded-debugging-techniques/199200938?pgno=1">drdobbs.com</a><br>
</li>
</ol>
</div>
</div>

  </li>


  <li>
    <span class="post-meta">Apr 19, 2018</span>
    <h3>
      <a class="post-link" href="/posts/gdb-ignore-received-signal/">在gdb调试时忽略系统信号（signal）</a>
    </h3>

    <p>
在gdb调试程序时，默认情况下gdb在收到信号时会中断程序的运行，并将收到的信号显示出来。这时，可以选择输入 <code>c</code> (continue)让程序继续运行。如果程序会重复收到这信号，会非常影响调试效率。可以通过配置忽略指定的系统信号。<br></p>

<p>
查看当前系统信号的处理信息的指令如下。<br></p>
<div class="highlight"><pre><span></span>(gdb) info signal
</pre></div>

<p>
以调试网络程序为例，进程会经常收到 <code>SIGPIPE</code> 消息，对于网络进程的 <code>SIGPIPE</code> 消息在程序中会由自身处理，可以使用以下指令让gdb不再提示 <code>SIGPIPE</code> 信号。<br></p>
<div class="highlight"><pre><span></span>(gdb) handle SIGPIPE nostop noprint
</pre></div>
<p>
其中， <code>nostop</code> 表示在收到信号时不再中断程序的运行， <code>noprint</code> 表示在收到信号时不再将收到的信号打印到gdb调试界面，这两个参数可以分开使用。<br></p>

<p>
参考资料： <a href="ftp://ftp.gnu.org/old-gnu/Manuals/gdb/html_node/gdb_38.html">gnu gdb manual</a><br></p>

<p>
（全文完）<br></p>

  </li>


  <li>
    <span class="post-meta">Apr 18, 2018</span>
    <h3>
      <a class="post-link" href="/posts/cpp11-range-based-for-loop/">C++11新特性：基于范围的for循环</a>
    </h3>

    <p>
<b>在C++11中，介绍了一种新的for循环写法，基于范围的for循环。</b><br>
与旧的for循环类似，也是用来对遍历容器中的所有元素，新的写法更加简洁方便。可以使用auto自动适配容器中的内容。为了遍历容器时提高效率，在访问容器内部时可以声明为元素的引用，进而避免不必要的对象拷贝。示例代码如下（代码节选自 <a href="http://en.cppreference.com/w/cpp/language/range-for">cppreferance</a>）<br></p>
<div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">};</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="c1">// access by const reference</span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">' '</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">'\n'</span><span class="p">;</span><span class="w"></span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="c1">// access by value, the type of i is int</span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">' '</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">'\n'</span><span class="p">;</span><span class="w"></span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">})</span><span class="w"> </span><span class="c1">// the initializer may be a braced-init-list</span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">' '</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">'\n'</span><span class="p">;</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">};</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="c1">// the initializer may be an array</span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">' '</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">'\n'</span><span class="p">;</span><span class="w"></span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">' '</span><span class="p">;</span><span class="w"> </span><span class="c1">// the loop variable need not be used</span>
<span class="p">}</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">'\n'</span><span class="p">;</span><span class="w"></span>
</pre></div>

<p>
<b>注意 <code>std::map</code> 的范围for循环遍历的写法</b><br><code>std::map</code> 中存放的是 <code>key-value pair</code> 键值对，所以在遍历的时候每次拿到的是一个 <code>pair</code> ，在访问其中的元素时，需要注意书写方法。示例代码如下。<br></p>
<div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">mapDemo</span><span class="p">;</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">kvp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">mapDemo</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">kvp</span><span class="p">.</span><span class="n">first</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">" - "</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">kvp</span><span class="p">.</span><span class="n">second</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

  </li>


  <li>
    <span class="post-meta">Apr 17, 2018</span>
    <h3>
      <a class="post-link" href="/posts/linux-command-examples-scp/">Linux常用命令行指令 - scp</a>
    </h3>

    <p>
<code>scp</code> 命令代表的是 secure copy，与 <code>cp</code> 命令的本地拷贝十分相似，主要区别就在于 <code>scp</code> 的路径可以是一个远程机器的路径。使用 <code>scp</code> 进行文件拷贝时，文件的传输时加密的。<br></p>
<div class="highlight"><pre><span></span>cp source_path dest_path
</pre></div>

<div id="outline-container-org3782b7c" class="outline-2">
<h2 id="org3782b7c">从远程机器向本地拷贝</h2>
<div class="outline-text-2" id="text-org3782b7c">
<p>
以下命令会把 <code>host</code> 主机上的 <code>src_path</code> 文件拷贝到本地 <code>dest_path</code> 目录中。<br></p>
<div class="highlight"><pre><span></span>scp user@host:src_path dest_path
</pre></div>
</div>
</div>

<div id="outline-container-orgeac951d" class="outline-2">
<h2 id="orgeac951d">从本地向远程机器拷贝</h2>
<div class="outline-text-2" id="text-orgeac951d">
<p>
以下命令会把本地 <code>src_path</code> 的文件拷贝打 <code>host</code> 主机上的 <code>dest_path</code> 路径上。<br></p>
<div class="highlight"><pre><span></span>scp src_path user@host:dest_path
</pre></div>
</div>
</div>

<div id="outline-container-orge8813f7" class="outline-2">
<h2 id="orge8813f7">拷贝目录下的所有文件</h2>
<div class="outline-text-2" id="text-orge8813f7">
<p>
可以使用 <code>-r</code> 参数完成目录的递归拷贝， <code>r</code> 代表 <code>recursive</code> 递归。<br></p>
<div class="highlight"><pre><span></span>scp -r user@host:/src_path dest_path
</pre></div>
</div>
</div>

<div id="outline-container-org60e576c" class="outline-2">
<h2 id="org60e576c">在拷贝时限制带宽</h2>
<div class="outline-text-2" id="text-org60e576c">
<p>
可以使用 <code>-l</code> 参数限制传输的带宽， <code>l</code> 代表 <code>limit</code> 限制，限制带宽的单位是 <code>kbps</code> 。<br>
命令会在将拷贝传输的速度限制为 100kbps。<br></p>
<div class="highlight"><pre><span></span>scp -l 100 src_path dest_path
</pre></div>
</div>
</div>

  </li>


  <li>
    <span class="post-meta">Apr 16, 2018</span>
    <h3>
      <a class="post-link" href="/posts/cpp11-automatic-deduction-and-decltype/">C++11新特性：自动类型推导</a>
    </h3>

    <div id="outline-container-org4fa8740" class="outline-2">
<h2 id="org4fa8740">关键字 <code>auto</code> 用于自动类型推导</h2>
<div class="outline-text-2" id="text-org4fa8740">
<div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w">     </span><span class="c1">// int</span>
<span class="k">auto</span><span class="w"> </span><span class="n">c</span><span class="o">=</span><span class="sc">'a'</span><span class="p">;</span><span class="w">   </span><span class="c1">// char</span>
<span class="k">auto</span><span class="w"> </span><span class="n">d</span><span class="o">=</span><span class="mf">0.5</span><span class="p">;</span><span class="w">   </span><span class="c1">// double</span>
</pre></div>

<p>
自动类型推导主要用于声明比较复杂的变量，或者变量是在泛型编程（模板）中自动生成出来的。<br></p>
<div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vecNumbers</span><span class="p">;</span><span class="w"></span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">const_iterator</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vecNumbers</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"></span>
<span class="k">auto</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vecNumbers</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
</div>

<div id="outline-container-orgccf3f7f" class="outline-2">
<h2 id="orgccf3f7f">
<code>auto</code> 类型推导并不会指定 <code>const</code> 和 <code>volatile</code> 属性</h2>
<div class="outline-text-2" id="text-orgccf3f7f">
<p>
如果需要限定声明的变量为 <code>const</code> 和 <code>volatile</code> 属性，需要额外提供相应的关键字限定。因为编译器并不能推断出声明的变量是否具有常值属性和易失属性。<br></p>
<div class="highlight"><pre><span></span><span class="k">volatile</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">num</span><span class="o">=</span><span class="mi">5</span><span class="p">;</span><span class="w">           </span><span class="c1">// volatile int</span>
<span class="k">auto</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">var</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span><span class="w">  </span><span class="c1">//const valatile bool</span>
<span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ch</span><span class="o">=</span><span class="sc">'a'</span><span class="p">;</span><span class="w">             </span><span class="c1">// const char</span>
</pre></div>
</div>
</div>

<div id="outline-container-org6d6c747" class="outline-2">
<h2 id="org6d6c747">关键字 <code>decltype</code> 用于获取一个对量的类型</h2>
<div class="outline-text-2" id="text-org6d6c747">
<p>
使用 <code>decltype</code> 存储一个对象或表达式的类型， <code>decltype</code> 可以看做是 <code>auto</code> 的补充。<br></p>
<div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vecNumbers</span><span class="p">;</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="k">decltype</span><span class="p">(</span><span class="n">vecNumbers</span><span class="p">.</span><span class="n">begin</span><span class="p">())</span><span class="w"> </span><span class="n">Iterator</span><span class="p">;</span><span class="w"></span>
<span class="n">Iterator</span><span class="w"> </span><span class="n">it2</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</div>

<div id="outline-container-orgd9726b1" class="outline-2">
<h2 id="orgd9726b1">函数返回值类型推导</h2>
<div class="outline-text-2" id="text-orgd9726b1">
<p>
在C++11中可以使用 <code>auto</code> 和 <code>decltype</code> 完成函数返回类型的推导。<br>
旧的函数声明格式 <code>return_type func_name(param_type param, ...);</code><br>
新的函数声明格式示例如下，以下函数接收 <code>bool</code> 作为函数的参数，并返回 <code>bool</code> 类型的结果。<br></p>
<div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">func_name</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">bParam</span><span class="p">)</span><span class="o">-&gt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">bParam</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">bParam</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>
函数返回值类型推导在模板泛型编程中非常有用，模板函数能够定义一个通用的返回类型，返回值类型会根据 <code>decltype</code> 自动推导。<br>
新的函数声明格式更易于维护，因为返回值并没有作为硬编码写入源文件中，但这样做可能会牺牲代码的可读性。<br></p>
<div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">auto</span><span class="w"> </span><span class="n">get_end</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="k">decltype</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vecNumbers</span><span class="p">;</span><span class="w"></span>
<span class="k">auto</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_end</span><span class="p">(</span><span class="n">vecNumbers</span><span class="p">);</span><span class="w">      </span><span class="c1">// returns iterator</span>

<span class="k">const</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vecNumbers2</span><span class="p">;</span><span class="w"></span>
<span class="k">auto</span><span class="w"> </span><span class="n">it2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_enm</span><span class="p">(</span><span class="n">vecNumbers2</span><span class="p">);</span><span class="w">    </span><span class="c1">// returns const_iterator</span>
</pre></div>
</div>
</div>

  </li>


  <li>
    <span class="post-meta">Apr 11, 2018</span>
    <h3>
      <a class="post-link" href="/posts/fifo-pipe-unix-domain-socket/">Linux下的FIFO、pipe、unix domain socket漫谈</a>
    </h3>

    <p>
在做Linux开发时，经常会接触 <code>管道</code> 、 <code>AF_UNIX</code> 等相关词汇，为了弄清他们之间的关系，查阅了一些资料，将结果整理并记录下来。<br></p>

  </li>

</ul>
</div>




    

  <ul class="index-pager hidden-print">
<li class="previous">
        <a href="/index-11.html" rel="next">&lt; Older posts</a>
    </li>
    <li class="next">
        <a href="/index-9.html" rel="prev">Newer posts &gt;</a>
    </li>
  </ul>
</div>
  </main><footer class="site-footer h-card"><div class="wrapper">
      <div class="footer-col-wrapper">

        <div class="footer-col">
          <p class="site-desc">Personal handnote on software development</p>
        </div>

        <div class="footer-col">
          <div class="p-name">Samson Wang</div>
          <div class="copyright">Copyright 2023, all rights reserved.</div>
          <div class="social-links">
            <ul class="social-media-list">
<li><a rel="me" href="/rss.xml">
                <svg class="svg-icon grey"><use href="/assets/svg/social-icons.svg#rss"></use></svg></a></li>
              <li><a rel="nofollow" href="https://github.com/samsonwang">
                <svg class="svg-icon grey"><use href="/assets/svg/social-icons.svg#github"></use></svg></a></li>
              <li><a rel="nofollow" href="https://twitter.com/samsonwangcn">
                <svg class="svg-icon grey"><use href="/assets/svg/social-icons.svg#twitter"></use></svg></a></li>
              <li><a rel="nofollow" href="https://facebook.com/samsonwangcn">
                 <svg class="svg-icon grey"><use href="/assets/svg/social-icons.svg#facebook"></use></svg></a></li>
            </ul>
</div>

        </div>

      </div>

    </div>

  </footer><div id="scroll-top" title="back to top">
  <div id="scroll-top-arrow"></div>
  <div id="scroll-top-stick"></div>
</div>


      <script src="/assets/js/lazyload.min.js"></script><script src="/assets/js/minima.min.js"></script><!-- google adsense --><script data-ad-client="ca-pub-6303134192857919" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- Google Analytics - Global site tag (gtag.js) --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-108507797-1"></script><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-108507797-1');
</script>
</body>
</html>
