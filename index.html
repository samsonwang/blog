<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="Constraint &amp; Focus">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Hack Note</title>
<link href="/assets/css/bootstrap.min.css" rel="stylesheet" type="text/css">
<link href="/assets/css/font-awesome.min.css" rel="stylesheet" type="text/css">
<link href="/assets/css/code.css" rel="stylesheet" type="text/css">
<link href="/assets/css/colorbox.css" rel="stylesheet" type="text/css">
<link href="/assets/css/cerulean.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" href="/rss.xml">
<link rel="canonical" href="http://samsonwang.me/">
<link rel="icon" href="/favicon.ico" sizes="64x64">
<link rel="next" href="/index-8.html" type="text/html">
<!--[if lt IE 9]><script src="/assets/js/html5.js"></script><![endif]--><link rel="prefetch" href="/posts/notes-on-libshmcache/" type="text/html">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->
<nav class="navbar navbar-inverse navbar-fixed-top"><div class="container">
  <!-- This keeps the margins nice -->
    
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="http://samsonwang.me/">

        <span id="blog-title">Hack Note</span>
      </a>
    </div>
    
    <!-- /.navbar-header -->
    <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
      <ul class="nav navbar-nav">
<li>
<a href="/archive/">Archives</a>
                </li>
<li>
<a href="/tags/">Tags</a>
                </li>
<li>
<a href="/listings/">Listings</a>
                </li>
<li>
<a href="/galleries/">Galleries</a>
                </li>
<li>
<a href="/rss.xml">RSS Feed</a>

        
      </li>
</ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!-- /.navbar-collapse -->
  </div>
<!-- /.container -->
</nav><!-- End of Menubar --><div class="container" id="content" role="main">
  <div class="body-content">
    <!--Body content-->
    <div class="row">

      <div class="col-sm-9">
        
        


  



  

<div class="postindex">
  <article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/notes-on-libshmcache/" class="u-url">libshmcache源码阅读笔记</a></h1>
      <div class="metadata">
        
        
        <div class="date">
          <a href="/posts/notes-on-libshmcache/" rel="bookmark">
            <time class="published dt-published" datetime="2018-07-23T10:51:59+08:00" title="2018-07-23 10:51">2018-07-23 10:51
            </time></a>
        </div>
        
          <div class="comment">
            
        
    <a href="/posts/notes-on-libshmcache/#disqus_thread" data-disqus-identifier="cache/posts/notes-on-libshmcache.html">Comments</a>


          </div>

      </div>
    </header><div class="e-content entry-content">
      <div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">引言</h2>
<div class="outline-text-2" id="text-1">
<p>
由于在工作中需要开发一套内存缓存服务，使用了共享内存作为多进程间的数据共享。为了提高共享内存缓存服务的性能，我找了一个类似的较为成熟的开源项目 <a href="https://github.com/happyfish100/libshmcache">libshmcache</a> ，通过研究源码学习其中的优点并改进自己的模块。<br></p>

<p>
libshmcache与redis相似的是都使用内存进行数据缓存；与redis不同的是，redis使用的进程自己申请的动态内存，而libshmcache使用的是共享内存。使用共享内存就意味着libshmcache主要的应用场景是同一台主机上的数据缓存。<br></p>

<p>
我花了一周时间阅读了比较感兴趣的部分代码，收获不少，现就以下几个方面总结一下自己的心得：<br></p>
<ul class="org-ul">
<li>纯C语言开发的代码风格<br>
</li>
<li>hash table的原理和实现<br>
</li>
<li>gcc原子化操作接口<br>
</li>
<li>有锁写和无锁读的实现细节<br>
</li>
<li>共享内存的两套函数接口(POSIX和SystemV)<br>
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">纯C语言开发时的代码风格</h2>
<div class="outline-text-2" id="text-2">
<p>
我在工作中使用比较多的开发语言是C++，对于C语言编写的这样规模的项目，还是第一次仔细深入地研究。C语言使用 <code>struct</code> 作为大多数自定义数据结构的关键字，相对于C++能够使用成员函数能够对类进行功能拓展，C语言比较常用的是将这个对象作为输入参数传到函数中。<br></p>

<p>
纵观所有项目代码，我感受比较深的就是使用结构体中嵌套匿名结构体，这样做能够增强数据结构的层次感，示例代码如下：<br></p>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">shmcache_context</span> <span class="p">{</span>
    <span class="kt">pid_t</span> <span class="n">pid</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">lock_fd</span><span class="p">;</span>    <span class="c1">//for file lock</span>
    <span class="kt">int</span> <span class="n">detect_deadlock_clocks</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">shmcache_config</span> <span class="n">config</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">shm_memory_info</span> <span class="o">*</span><span class="n">memory</span><span class="p">;</span>
    <span class="k">struct</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">shmcache_segment_info</span> <span class="n">hashtable</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
	    <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	    <span class="k">struct</span> <span class="n">shmcache_segment_info</span> <span class="o">*</span><span class="n">items</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">values</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">segments</span><span class="p">;</span>

    <span class="k">struct</span> <span class="n">shmcache_value_allocator_context</span> <span class="n">value_allocator</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">shmcache_list</span> <span class="n">list</span><span class="p">;</span>   <span class="c1">//for value recycle</span>
    <span class="kt">bool</span> <span class="n">create_segment</span><span class="p">;</span>  <span class="c1">//if check segment size                                  </span>
<span class="p">};</span>
</pre></div>
<p>
注意 <code>shmcache_context</code> 中的匿名结构体 <code>segments</code> 和 <code>values</code> ，这样的写法体现了相互包含关系，也使后续的操作该数据结构的语句更加容易理解。<br></p>

<p>
另外对于联合体和位域这两种技术也是我在之前开发中使用比较少的，通过阅读源码能够让我对其有了更深刻的理解。示例代码如下：<br></p>
<div class="highlight"><pre><span></span><span class="k">union</span> <span class="n">shm_hentry_offset</span> <span class="p">{</span>
    <span class="kt">int64_t</span> <span class="n">offset</span><span class="p">;</span>
    <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="nl">index</span> <span class="p">:</span><span class="mi">16</span><span class="p">;</span>
	<span class="kt">int64_t</span> <span class="nl">offset</span> <span class="p">:</span><span class="mi">48</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">segment</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
<p>
这段代码使用了联合体赋予了 <code>shm_hentry_offset</code> 两种访问方式，又使用了位域将 <code>int64_t</code> 分割为两段。<br></p>
</div>
</div>


<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">hash table的原理和实现</h2>
<div class="outline-text-2" id="text-3">
<p>
libshmcache内部使用的是hash table做内部缓存的数据结构，这使查找的时间复杂度是O(1)。<br>
之前看过一些介绍hash table的资料，对hash table的工作原理是有过一个基础的了解的，这次通过阅读源码，能够了解到hash table在代码实现上更加细节的内容。<br>
对于hash计算中出现的hash值冲突，即在hash计算时出现了两个不同的key在经过hash计算后得到的bucket相同，libshmcache采用的解决方案是使用linked list来存放这些相同bucket对应的value。<br></p>
</div>
</div>


<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">gcc原子化操作接口</h2>
<div class="outline-text-2" id="text-4">
<p>
使用原子化操作接口能够解决一些并发读写问题，原子化操作相对于互斥锁执行更快。原子化操作也是一种无锁编程的方式。<br></p>
</div>
</div>


<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">有锁写和无锁读的实现</h2>
<div class="outline-text-2" id="text-5">
<p>
在libshmcache中，写操作通过 <code>pthread_mutex_t</code> 进行同步，而读操作是无锁的。<br>
对于写操作来说，需要对hash table进行操作，这肯定是需要同步的。<br>
将 <code>pthread_mutex_t</code> 保存在共享内存中，不同的进程通过映射共享内存就能获得同一个互斥量，通过这个互斥量就能完成进程间同步。<br></p>
</div>
</div>


<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">共享内存的两套函数接口(POSIX和SystemV)</h2>
<div class="outline-text-2" id="text-6">
<p>
在linux上使用共享内存时有两套接口 <code>mmap</code> 和 <code>shmget</code> 。 <code>mmap</code> 是 <code>POSIX</code> 标准的接口，而 <code>shmget</code> 是 <code>System V</code> 标准的接口，两者都能够实现进程间共享内存，但他们在使用上还是有些区别的。对于 <code>mmap</code> 来说，需要在硬盘上创建一个文件，再将该文件映射到内存中。对于 <code>shmget</code> 来说，需要指定一个key，不同的进程通过相同的key就能映射到同一片内存。<br></p>
</div>
</div>
    </div>
  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/bit-field/" class="u-url">C/C++中的位域</a></h1>
      <div class="metadata">
        
        
        <div class="date">
          <a href="/posts/bit-field/" rel="bookmark">
            <time class="published dt-published" datetime="2018-07-11T18:03:37+08:00" title="2018-07-11 18:03">2018-07-11 18:03
            </time></a>
        </div>
        
          <div class="comment">
            
        
    <a href="/posts/bit-field/#disqus_thread" data-disqus-identifier="cache/posts/bit-field.html">Comments</a>


          </div>

      </div>
    </header><div class="e-content entry-content">
      <div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">
<span class="section-number-2">1</span> 什么是位域</h2>
<div class="outline-text-2" id="text-1">
<p>
<a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E6%AE%B5">维基百科</a> 给出了以下解释<br></p>
<blockquote>
<p>
位域（或称“位段”，bit field）为一种数据结构，可以把数据以位的形式紧凑的储存，并允许程序员对此结构的位进行操作。<br></p>
</blockquote>

<p>
<a href="https://en.cppreference.com/w/cpp/language/bit_field">cppreference</a> 给出了以下定义<br></p>
<blockquote>
<p>
Declares a class data member with explicit size, in bits. Adjacent bit field members may be packed to share and straddle the individual bytes.<br></p>
</blockquote>

<p>
这种数据结构的好处：<br></p>
<ul class="org-ul">
<li>可以使数据单元节省储存空间，当程序需要成千上万个数据单元时，这种方法就显得尤为重要。<br>
</li>
<li>位段可以很方便的访问一个整数值的部分内容从而可以简化程序源代码。<br>
</li>
</ul>
<p>
而位域这种数据结构的缺点在于，其内存分配与内存对齐的实现方式依赖于具体的机器和系统，在不同的平台可能有不同的结果，这导致了位段在本质上是不可移植的。<br></p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">
<span class="section-number-2">2</span> 位域的语法</h2>
<div class="outline-text-2" id="text-2">
<div class="highlight"><pre><span></span><span class="n">identifier</span><span class="p">(</span><span class="n">optional</span><span class="p">)</span> <span class="n">attr</span><span class="p">(</span><span class="n">optional</span><span class="p">)</span> <span class="o">:</span> <span class="n">size</span>
</pre></div>

<p>
注意：<br></p>
<ul class="org-ul">
<li>size的大小不能超过identifier所包含最大比特位个数。<br>
</li>
<li>identifier为空时表示对应的size个数的比特位不使用<br>
</li>
<li>size为0时表示根据前类型强制补齐<br>
</li>
</ul>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">S1</span> <span class="p">{</span>
    <span class="c1">// will usually occupy 2 bytes:</span>
    <span class="c1">// 3 bits: value of b1</span>
    <span class="c1">// 2 bits: unused</span>
    <span class="c1">// 6 bits: value of b2</span>
    <span class="c1">// 2 bits: value of b3</span>
    <span class="c1">// 3 bits: unused</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nl">b1</span> <span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nl">b2</span> <span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="nl">b3</span> <span class="p">:</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">S2</span> <span class="p">{</span>
    <span class="c1">// will usually occupy 2 bytes:</span>
    <span class="c1">// 3 bits: value of b1</span>
    <span class="c1">// 5 bits: unused</span>
    <span class="c1">// 6 bits: value of b2</span>
    <span class="c1">// 2 bits: value of b3</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nl">b1</span> <span class="p">:</span> <span class="mi">3</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">:</span><span class="mi">0</span><span class="p">;</span> <span class="c1">// start a new byte</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nl">b2</span> <span class="p">:</span> <span class="mi">6</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nl">b3</span> <span class="p">:</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">
<span class="section-number-3">2.1</span> 在size取0时如何理解</h3>
<div class="outline-text-3" id="text-2-1">
<p>
对于size取0时的各种情况进行了尝试，详细用例如下。思路是使用联合体能比较方便地将内存分布表示出来。<br>
如下所示，定义了如下几种情况。<br></p>
</div>

<div id="outline-container-sec-2-1-1" class="outline-4">
<h4 id="sec-2-1-1">
<span class="section-number-4">2.1.1</span> case1</h4>
<div class="outline-text-4" id="text-2-1-1">
<div class="highlight"><pre><span></span><span class="k">union</span> <span class="n">un1</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n1</span><span class="p">;</span>
    <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="nl">nn1</span> <span class="p">:</span> <span class="mi">4</span><span class="p">;</span>
	<span class="kt">int</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="nl">nn2</span> <span class="p">:</span> <span class="mi">16</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">st</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
<p>
对联合体中的结构体位段进行赋值，并将联合体中的内容打印出来。<br></p>
<div class="highlight"><pre><span></span><span class="k">union</span> <span class="n">un1</span> <span class="n">u1</span><span class="p">;</span>
<span class="n">u1</span><span class="p">.</span><span class="n">st</span><span class="p">.</span><span class="n">nn1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">u1</span><span class="p">.</span><span class="n">st</span><span class="p">.</span><span class="n">nn2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"union u1.n1=0x%08x sizeof(un1)=%zu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">u1</span><span class="p">.</span><span class="n">n1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">un1</span><span class="p">));</span>
</pre></div>
<p>
输出结果为<br></p>
<div class="highlight"><pre><span></span><span class="k">union</span> <span class="n">un1</span><span class="p">.</span><span class="n">n1</span><span class="o">=</span><span class="mh">0x00000001</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">un1</span><span class="p">)</span><span class="o">=</span><span class="mi">8</span>
</pre></div>
</div>
</div>

<div id="outline-container-sec-2-1-2" class="outline-4">
<h4 id="sec-2-1-2">
<span class="section-number-4">2.1.2</span> case2</h4>
<div class="outline-text-4" id="text-2-1-2">
<div class="highlight"><pre><span></span><span class="k">union</span> <span class="n">un1</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n1</span><span class="p">;</span>
    <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="nl">nn1</span> <span class="p">:</span> <span class="mi">4</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="nl">nn2</span> <span class="p">:</span> <span class="mi">16</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">st</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
<p>
输出结果为<br></p>
<div class="highlight"><pre><span></span><span class="k">union</span> <span class="n">un1</span><span class="p">.</span><span class="n">n1</span><span class="o">=</span><span class="mh">0x00000101</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">un1</span><span class="p">)</span><span class="o">=</span><span class="mi">4</span>
</pre></div>
</div>
</div>

<div id="outline-container-sec-2-1-3" class="outline-4">
<h4 id="sec-2-1-3">
<span class="section-number-4">2.1.3</span> case3</h4>
<div class="outline-text-4" id="text-2-1-3">
<div class="highlight"><pre><span></span><span class="k">union</span> <span class="n">un1</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n1</span><span class="p">;</span>
    <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="nl">nn1</span> <span class="p">:</span> <span class="mi">4</span><span class="p">;</span>
	<span class="kt">short</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="nl">nn2</span> <span class="p">:</span> <span class="mi">16</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">st</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
<p>
输出结果为<br></p>
<div class="highlight"><pre><span></span><span class="k">union</span> <span class="n">un1</span><span class="p">.</span><span class="n">n1</span><span class="o">=</span><span class="mh">0x00010001</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">un1</span><span class="p">)</span><span class="o">=</span><span class="mi">4</span>
</pre></div>
</div>
</div>


<div id="outline-container-sec-2-1-4" class="outline-4">
<h4 id="sec-2-1-4">
<span class="section-number-4">2.1.4</span> case4</h4>
<div class="outline-text-4" id="text-2-1-4">
<div class="highlight"><pre><span></span><span class="k">union</span> <span class="n">un1</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n1</span><span class="p">;</span>
    <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="nl">nn1</span> <span class="p">:</span> <span class="mi">8</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="nl">nn2</span> <span class="p">:</span> <span class="mi">16</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">st</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
<p>
输出结果为<br></p>
<div class="highlight"><pre><span></span><span class="k">union</span> <span class="n">un1</span><span class="p">.</span><span class="n">n1</span><span class="o">=</span><span class="mh">0x00000101</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">un1</span><span class="p">)</span><span class="o">=</span><span class="mi">4</span>
</pre></div>
</div>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">
<span class="section-number-3">2.2</span> <code>struct</code> 标识符</h3>
<div class="outline-text-3" id="text-2-2">
<p>
多数例子都是以 <code>struct</code> 作为位域的组织标识，在C++中能否使用 <code>class</code> 作为位域的标识符。<br>
经过测试，是可以使用 <code>class</code> 的，但是需要注意 <code>class</code> 的默认访问控制属性为 <code>private</code><br></p>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">
<span class="section-number-2">3</span> 位域的常见应用场景</h2>
<div class="outline-text-2" id="text-3">
<p>
<b>为什么要使用位域？位域适合那些情况？</b><br>
位域的主要使用目的是节省对象的内存使用。在存放一些比较小的数据时，使用位域能够使字节中的每个比特位合理地利用起来，避免内存浪费。<br>
比较典型的应用是描述硬件寄存器。如果有32个一组的寄存器，每个寄存器代表一个比特位，就可以使用位域表示这组寄存器。<br></p>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">
<span class="section-number-2">4</span> C++中的位操作接口</h2>
<div class="outline-text-2" id="text-4">
<p>
C++中也提供了一套位操作的接口 <code>std::bitset</code> ，这套接口提供了指定比特位数据的操作接口。<br></p>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">
<span class="section-number-2">5</span> 参考资料</h2>
<div class="outline-text-2" id="text-5">
<ul class="org-ul">
<li>
<a href="https://zh.wikipedia.org/wiki/%25E4%25BD%258D%25E6%25AE%25B5">wikipedia bit-field</a><br>
</li>
<li>
<a href="https://en.cppreference.com/w/cpp/language/bit_field">cppreference bit-field</a><br>
</li>
<li>
<a href="https://msdn.microsoft.com/zh-cn/library/ewwyfdbe.aspx">microsoft msdn</a><br>
</li>
<li>
<a href="https://stackoverflow.com/questions/24933242/when-to-use-bit-fields-in-c">stackoverflow</a><br>
</li>
<li>
<a href="https://en.cppreference.com/w/cpp/utility/bitset">cppreference std::bitset</a><br>
</li>
</ul>
</div>
</div>
    </div>
  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/gcc-built-in-functions-for-atomic-memory-access/" class="u-url">GCC的内存原子化操作函数接口</a></h1>
      <div class="metadata">
        
        
        <div class="date">
          <a href="/posts/gcc-built-in-functions-for-atomic-memory-access/" rel="bookmark">
            <time class="published dt-published" datetime="2018-07-02T17:54:08+08:00" title="2018-07-02 17:54">2018-07-02 17:54
            </time></a>
        </div>
        
          <div class="comment">
            
        
    <a href="/posts/gcc-built-in-functions-for-atomic-memory-access/#disqus_thread" data-disqus-identifier="cache/posts/gcc-built-in-functions-for-atomic-memory-access.html">Comments</a>


          </div>

      </div>
    </header><div class="e-content entry-content">
      <div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">
<span class="section-number-2">1</span> 原子化操作</h2>
<div class="outline-text-2" id="text-1">
<p>
在并发编程中，一个操作或一组操作是原子操作、可线性化操作、不可分操作或不可中断操作（atomic, linearizable, indivisible, uniterruptible），表示该操作执行时不可被中断的。操作的原子性能够保证操作在执行时免受中断、信号、并发进程线程的影响。另外，原子操作大多只有两种结果，要么成功并改变系统中对应的状态，要么没有相关效果。<br></p>

<p>
原子化经常由互斥来保证，可以在硬件层面建立一个缓存一致性协议，也可以在软件层面使用信号量或加锁。因此，一个原子操作不是必须实际上马上生效，而操作系统让这个操作看起来是直接发生的，这能够让操作系统保持一致。正是如此，只要不影响性能，用户可以忽略较底层的实现细节。<br></p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">
<span class="section-number-2">2</span> 函数接口</h2>
<div class="outline-text-2" id="text-2">
<p>
GCC提供了原子化的操作接口，能够支持长度为1、2、4、8字节的整形变量或指针。<br></p>

<blockquote>
<p>
In most cases, these builtins are considered a full barrier. That is, no memory operand will be moved across the operation, either forward or backward. Further, instructions will be issued as necessary to prevent the processor from speculating loads across the operation and from queuing stores after the operation.<br></p>
</blockquote>
<p>
在大多数情况下，这些内建函数是完全内存栅栏（full barrier）的，以上摘自 GCC Manual。<br></p>

<p>
<b>取值并进行对应操作的接口</b> 如下所示：<br></p>
<div class="highlight"><pre><span></span><span class="n">type</span> <span class="n">__sync_fetch_and_add</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">type</span> <span class="n">__sync_fetch_and_sub</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">type</span> <span class="n">__sync_fetch_and_or</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">type</span> <span class="n">__sync_fetch_and_and</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">type</span> <span class="n">__sync_fetch_and_xor</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">type</span> <span class="n">__sync_fetch_and_nand</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
<p>
这些函数接口的执行逻辑如下：会执行名称相对应的运算，并将内存中之前存放的值取出并返回。<br></p>
<div class="highlight"><pre><span></span><span class="p">{</span> <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span> <span class="o">*</span><span class="n">ptr</span> <span class="n">op</span><span class="o">=</span> <span class="n">value</span><span class="p">;</span> <span class="k">return</span> <span class="n">tmp</span><span class="p">;</span> <span class="p">}</span>
<span class="p">{</span> <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">value</span><span class="p">);</span> <span class="k">return</span> <span class="n">tmp</span><span class="p">;</span> <span class="p">}</span>   <span class="c1">// nand</span>
</pre></div>
<p>
<b>需要注意的是</b> ：从GCC 4.4开始 <code>__sync_fetch_and_nand</code> 是按照 <code>*ptr = ~(*ptr &amp; value)</code> 实现的，而不是 <code>*ptr = ~*ptr &amp; value</code><br></p>

<p>
<b>直接操作并返回结果的接口</b> 如下所示：<br></p>
<div class="highlight"><pre><span></span><span class="n">type</span> <span class="n">__sync_add_and_fetch</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">type</span> <span class="n">__sync_sub_and_fetch</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">type</span> <span class="n">__sync_or_and_fetch</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">type</span> <span class="n">__sync_and_and_fetch</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">type</span> <span class="n">__sync_xor_and_fetch</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">type</span> <span class="n">__sync_nand_and_fetch</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">value</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
<p>
这些函数接口的执行逻辑如下：<br></p>
<div class="highlight"><pre><span></span><span class="p">{</span> <span class="o">*</span><span class="n">ptr</span> <span class="n">op</span><span class="o">=</span> <span class="n">value</span><span class="p">;</span> <span class="k">return</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span> <span class="p">}</span>
<span class="p">{</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="o">*</span><span class="n">ptr</span> <span class="o">&amp;</span> <span class="n">value</span><span class="p">);</span> <span class="k">return</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span> <span class="p">}</span>   <span class="c1">// nand</span>
</pre></div>
<p>
<b>需要注意的是</b> ：从GCC 4.4开始 <code>__sync_nand_and_fetch</code> 是按照 <code>*ptr = ~(*ptr &amp; value)</code> 实现的，而不是 <code>*ptr = ~*ptr &amp; value</code><br></p>

<p>
比较并交换的函数接口<br></p>
<div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="n">__sync_bool_compare_and_swap</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">oldval</span> <span class="n">type</span> <span class="n">newval</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">type</span> <span class="n">__sync_val_compare_and_swap</span> <span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">type</span> <span class="n">oldval</span> <span class="n">type</span> <span class="n">newval</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">
<span class="section-number-2">3</span> 内存栅栏（Memory Barrier）</h2>
<div class="outline-text-2" id="text-3">
<p>
在上面的说明中提到了memory barrier的概念，这个概念是CPU指令的一个术语。<br></p>

<p>
内存栅栏又叫内存屏障，是一种能够让CPU或编译器约束内存操作指令执行顺序的屏蔽指令。这表示在内存栅栏前的指令能够保证执行时先于内存栅栏后的指令。由于大多数现代CPU采用性能优化会导致指令执行变序时，所以内存栅栏是十分必要的。这样的指令变序对于单线程程序一般不会有很大影响，但是在并发编程情况下如果不加以控制就会导致不可预知的结果。<br></p>

<p>
内存栅栏的典型应用场景就是用于实现多设备之间的共享内存的底层机器码。这些代码包括原始同步机制、多核系统上的无锁数据结构、与计算机硬件交互的设备驱动。<br></p>

<p>
内存栅栏对于无锁编程来说十分重要的。<br></p>

<p>
<b>内存栅栏与volatile关键字</b><br>
内存栅栏分为读栅栏（read barrier）、写栅栏（write barrier）、获取栅栏（acquire barrier）、释放栅栏（release barrier）等。内存栅栏并不能保证数值的是“最新的”或“新鲜的”，它只能控制内存访问的相对顺序。<br></p>

<p>
“写栅栏”用于控制写操作的顺序。由于相对于CPU的执行速度来说，向内存中写入顺序是比较慢的，通常会有一个写入请求队列，所以实际的写入操作发生在指令发起之后，队列中指令的顺序可能会被重新排序。写栅栏能够防止指令变序。<br></p>

<p>
“读栅栏”用于控制读操作的顺序。由于预先执行（CPU会提前将内存中的数据读回来），并且CPU有缓存区（CPU会从缓存中而不是内存中读取数据），读操作可能会出现变序。<br></p>

<p>
volatile关键字值能通知编译器生成的输出码从内存中重新读取数据，但是不会告诉CPU在如何读取数据、在哪里读取数据。<br></p>

<p>
“获取栅栏”能够保证特定指令块之前的执行顺序。例如获取读，在向读队列中加入读操作，“获取栅栏”意味着在这条操作之后可以出现指令变序，而这条操作之前不会出现指令变序。<br></p>

<p>
“释放栅栏”能够保证特定指令块之后的执行顺序。例如释放写，在向写队列中加入写操作，“释放栅栏”意味着在这条写操作之前的指令不会变序到该指令之后，而这条该操作的之后的指令可能会变序到该指令之前。<br></p>

<p>
获取栅栏和释放栅栏是又叫半栅栏（half barrier），这是因为它们只能防止单方向的指令变序。<br></p>
</div>
</div>


<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">
<span class="section-number-2">4</span> 操作原子化能够解决多进程访问共享内存的问题吗？</h2>
<div class="outline-text-2" id="text-4">
<p>
原子化操作是对于CPU而言的指令操作，它不关心线程还是进程，它只关心这一系列的指令是不可分割的。所以，进程间可以使用原子操作完成内存的操作同步。<br></p>
</div>
</div>


<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">
<span class="section-number-2">5</span> 参考资料</h2>
<div class="outline-text-2" id="text-5">
<ul class="org-ul">
<li>
<a href="https://en.wikipedia.org/wiki/Linearizability">Wikipedia - Linearizability</a><br>
</li>
<li>
<a href="https://gcc.gnu.org/onlinedocs/gcc-4.4.3/gcc/Atomic-Builtins.html">GNU GCC online docs</a><br>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Memory_barrier">Wikipedia - Memory Barrier</a><br>
</li>
<li>
<a href="https://stackoverflow.com/questions/1787450/how-do-i-understand-read-memory-barriers-and-volatile">stackoverflow - memory barrier and volatile</a><br>
</li>
<li>
<a href="https://stackoverflow.com/questions/8160348/lock-freedom-atomic-operations-across-2-processes-instead-of-threads">stackoverflow - atomic operation in multi process</a><br>
</li>
<li>
<a href="https://en.cppreference.com/w/cpp/atomic">cppreference - atomic</a><br>
</li>
</ul>
</div>
</div>
    </div>
  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/gdb-display-contents-of-memory-address/" class="u-url">在gdb中查看指定内存地址的内容</a></h1>
      <div class="metadata">
        
        
        <div class="date">
          <a href="/posts/gdb-display-contents-of-memory-address/" rel="bookmark">
            <time class="published dt-published" datetime="2018-06-29T16:45:09+08:00" title="2018-06-29 16:45">2018-06-29 16:45
            </time></a>
        </div>
        
          <div class="comment">
            
        
    <a href="/posts/gdb-display-contents-of-memory-address/#disqus_thread" data-disqus-identifier="cache/posts/gdb-display-contents-of-memory-address.html">Comments</a>


          </div>

      </div>
    </header><div class="e-content entry-content">
      <div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">
<span class="section-number-2">1</span> 引言</h2>
<div class="outline-text-2" id="text-1">
<p>
调试 C/C++ 程序时，需要打印指定内存地址的内容。我最近调试程序中的序列化模块时，需要将类对象按照指定的格式转化为二进制流，为了验证转化结果，在调试时就需要将指定内存地址中的内容打印出来。<br></p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">
<span class="section-number-2">2</span> 指令语法</h2>
<div class="outline-text-2" id="text-2">
<p>
在gdb模式下，使用 <code>x</code> （ <code>examine</code> 的缩写）指令能够将指令内存地址中的信息打印出来。指令的语法如下。<br></p>
<div class="highlight"><pre><span></span>x/nfu addr
x addr
</pre></div>
<p>
其中 <code>n</code> 、 <code>f</code> 、 <code>u</code> 都是可选参数， <code>n</code> 表示重复次数， <code>f</code> 表示显示格式（format）， <code>u</code> 表示显示单元大小(unix size)。<br></p>

<p>
<code>f</code> <b>可以取如下值</b> ：<br>
x 按十六进制格式显示变量<br>
d 按十进制格式显示变量<br>
o 按八进制格式显示变量<br>
t 按二进制格式显示变量<br></p>

<p>
<code>u</code> <b>可以取如下值</b> ：<br>
b 表示单字节（byte）<br>
h 表示双字节（halfword）<br>
w 表示四字节(word)<br>
g 表示八字节(giant word)<br></p>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">
<span class="section-number-2">3</span> 示例</h2>
<div class="outline-text-2" id="text-3">
<p>
以下指令会以16进制格式显示addr开始的100字节信息<br></p>
<div class="highlight"><pre><span></span>x/100xb addr
</pre></div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">
<span class="section-number-2">4</span> 参考资料</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li>
<a href="ftp://ftp.gnu.org/old-gnu/Manuals/gdb/html_chapter/gdb_9.html#SEC56">GDB manual(gnu.org)</a><br>
</li>
<li>
<a href="https://sourceware.org/gdb/onlinedocs/gdb/Memory.html">GDB manual(sourceware.org)</a><br>
</li>
</ul>
</div>
</div>
    </div>
  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/asynchronous-synchronous-and-blocking-unblocking/" class="u-url">同步和异步、阻塞和非阻塞</a></h1>
      <div class="metadata">
        
        
        <div class="date">
          <a href="/posts/asynchronous-synchronous-and-blocking-unblocking/" rel="bookmark">
            <time class="published dt-published" datetime="2018-06-26T09:27:06+08:00" title="2018-06-26 09:27">2018-06-26 09:27
            </time></a>
        </div>
        
          <div class="comment">
            
        
    <a href="/posts/asynchronous-synchronous-and-blocking-unblocking/#disqus_thread" data-disqus-identifier="cache/posts/asynchronous-synchronous-and-blocking-unblocking.html">Comments</a>


          </div>

      </div>
    </header><div class="e-content entry-content">
      <div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">
<span class="section-number-2">1</span> 同步和异步</h2>
<div class="outline-text-2" id="text-1">
<p>
同步和异步指的是在进行I/O操作完成之前，是否允许其他处理步骤继续执行。<br>
计算机中的I/O操作相对于数据处理操作时十分耗时的。<br></p>

<p>
一个简单的I/O操作方式就是启动连接并等待操作完成，但是这样的操作（同步阻塞I/O）在通信过程中会阻塞进程的处理进度。<br>
相应的，可以在启动通信的同时进行其他的处理，并不需要等待I/O操作的完成，这样的操作就被称作是异步I/O。那些依赖于I/O操作执行完成的任务会阻塞等待I/O操作的完成，其他不依赖与I/O操作的任务能够继续执行。<br></p>

<p>
同步模型常用的函数接口： <code>read</code> , <code>write</code> , <code>send</code> , <code>recv</code><br>
异步模型常用的函数接口： <code>aio_write</code> , <code>aio_read</code><br></p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">
<span class="section-number-3">1.1</span> POSIX AIO</h3>
<div class="outline-text-3" id="text-1-1">
<p>
在头文件 <code>aio.h</code> 中定义，链接时使用 <code>-lrt</code><br></p>

<p>
<b>函数接口</b><br>
异步写操作<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">aio_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">aiocb</span><span class="o">*</span> <span class="n">aiocbp</span><span class="p">);</span>
</pre></div>

<p>
异步读操作<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">aio_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">aiocb</span><span class="o">*</span> <span class="n">aiocbp</span><span class="p">);</span>
</pre></div>

<p>
获取异步操作结果<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">aio_return</span><span class="p">(</span><span class="k">struct</span> <span class="n">aiocb</span><span class="o">*</span> <span class="n">aiocbp</span><span class="p">);</span>
</pre></div>

<p>
获取异步操作中的错误<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">aio_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">aiocb</span><span class="o">*</span> <span class="n">aiocbp</span><span class="p">);</span>
</pre></div>

<p>
示例代码： <a href="https://gist.github.com/rsms/771059">github gist</a><br></p>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">
<span class="section-number-3">1.2</span> Linux AIO</h3>
<div class="outline-text-3" id="text-1-2">
<p>
在头文件 <code>libaio.h</code> 中定义，链接时使用 <code>-laio</code><br></p>

<p>
<b>函数接口</b><br>
需要注意的是aio的函数接口需要借助 <code>syscall</code> 进行调用。<br>
创建aio context对象<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">io_setup</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">nr</span><span class="p">,</span> <span class="n">aio_context_t</span><span class="o">*</span> <span class="n">ctxp</span><span class="p">);</span>
</pre></div>
<p>
销毁aio context对象<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">io_destroy</span><span class="p">(</span><span class="n">aio_context_t</span> <span class="n">ctx</span><span class="p">);</span>
</pre></div>
<p>
提交异步操作<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">io_submit</span><span class="p">(</span><span class="n">aio_context_t</span> <span class="n">ctx</span><span class="p">,</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iocb</span><span class="o">**</span> <span class="n">iocbpp</span><span class="p">);</span>
</pre></div>
<p>
获取异步操作结果<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">io_getevents</span><span class="p">(</span><span class="n">aio_context_t</span> <span class="n">ctx</span><span class="p">,</span> <span class="kt">long</span> <span class="n">min_nr</span><span class="p">,</span> <span class="kt">long</span> <span class="n">max_nr</span><span class="p">,</span>
		 <span class="n">io_event</span><span class="o">*</span> <span class="n">events</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span><span class="o">*</span> <span class="n">timeout</span><span class="p">);</span>
</pre></div>

<p>
示例代码:<br></p>
<ul class="org-ul">
<li>
<i>github gist</i><br>
</li>
<li>
<a href="http://www.xmailserver.org/eventfd-aio-test.c">xmailserver.org</a><br>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">
<span class="section-number-3">1.3</span> POSIX AIO与Linux AIO的区别</h3>
<div class="outline-text-3" id="text-1-3">
<p>
摘自 <a href="https://stackoverflow.com/questions/8768083/difference-between-posix-aio-and-libaio-on-linux">stackoverflow.com</a><br></p>
<blockquote>
<p>
On linux, the two AIO implementations are fundamentally different.<br>
The POSIX AIO is a user-level implementation that performs normal blocking I/O in multiple threads, hence giving the illusion that the I/Os are asynchronous. The main reason to do this is that:<br></p>
<ul class="org-ul">
<li>it works with any filesystem<br>
</li>
<li>it works (essentially) on any operating system (keep in mind that gnu's libc is portable)<br>
</li>
<li>it works on files with buffering enabled (i.e. no O<sub>DIRECT</sub> flag set)<br>
</li>
</ul>
<p>
The main drawback is that your queue depth (i.e. the number of outstanding operations you can have in practice) is limited by the number of threads you choose to have, which also means that a slow operation on one disk may block an operation going to a different disk. It also affects which I/Os (or how many) is seen by the kernel and the disk scheduler as well.<br>
The kernel AIO (i.e. io<sub>submit</sub>() et.al.) is kernel support for asynchronous I/O operations, where the io requests are actually queued up in the kernel, sorted by whatever disk scheduler you have, presumably some of them are forwarded (in somewhat optimal order one would hope) to the actual disk as asynchronous operations (using TCQ or NCQ). The main restriction with this approach is that not all filesystems work that well or at all with async I/O (and may fall back to blocking semantics), files have to be opened with O<sub>DIRECT</sub> which comes with a whole lot of other restrictions on the I/O requests. If you fail to open your files with O<sub>DIRECT</sub>, it may still "work", as in you get the right data back, but it probably isn't done asynchronously, but is falling back to blocking semantics.<br>
Also keep in mind that io<sub>submit</sub>() can actually block on the disk under certain circumstances.<br></p>
</blockquote>
<p>
在Linux上两种AIO是完全不同的；<br>
POSIX AIO实现在用户层，实际上进行的操作是普通的多线程阻塞操作，表现为I/O操作是异步的，这种AIO的优点是兼容性和可移植性好，缺点是操作队列长度受限于最大线程数量。<br>
Linux AIO是内核提供的AIO函数接口，I/O操作请求的队列在内核中维护，这种AIO的缺点是并不支持所有的文件系统，Linux AIO在某些情况下的磁盘操作是会阻塞的。<br></p>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">
<span class="section-number-2">2</span> 阻塞和非阻塞</h2>
<div class="outline-text-2" id="text-2">
<p>
阻塞与非阻塞的概念针对的是函数是否会立即返回。<br>
非阻塞模型常与IO复用技术组合使用。<br>
可以通过函数将IO设备设置为非阻塞模式。<br></p>
</div>
</div>


<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">
<span class="section-number-2">3</span> 如何理解阻塞非阻塞与同步异步的区别</h2>
<div class="outline-text-2" id="text-3">
<p>
在处理 IO 的时候，阻塞和非阻塞都是同步 IO。<br>
只有使用了特殊的 API 才是异步 IO。<br></p>
</div>
</div>


<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">
<span class="section-number-2">4</span> 参考资料</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li>
<a href="https://blog.csdn.net/hguisu/article/details/38638183">csdn.net</a><br>
</li>
<li>
<a href="https://github.com/littledan/linux-aio%20repo">github.com linux-aio</a><br>
</li>
<li>
<a href="https://www.ibm.com/developerworks/linux/library/l-async/index.html">ibm developerworks</a><br>
</li>
</ul>
</div>
</div>
    </div>
  </article>
</div>



        
       <script>var disqus_shortname="samsonwang-me";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script>
</div>

      <div class="col-sm-3 sidebar">
       
<div class="sidebar-module sidebar-module-inset">
  <h4>About Me</h4>
  
<div class="sidebar-aboutme">
<p>Zeal for coding, C++ developer.</p>
<p>Focus on linux server dev.</p>
<p>I use EMACS, and I am learning python.</p>
<p>View my code on <a href="https://github.com/samsonwang"> Github</a></p>
</div>

</div>

       
<div class="sidebar-module">
  <h4>Categories</h4>
  
<ol class="list-unstyled sidebar-category">
<li>
<a href="/tags/category_cpp/">cpp</a>
</li>
<li>
<a href="/tags/category_emacs/">emacs</a>
</li>
<li>
<a href="/tags/category_linux/">linux</a>
</li>
<li>
<a href="/tags/category_windows/">windows</a>
</li>
</ol>
</div>

      </div>
<!--.sidebar-->
    </div>
<!--.row-->

    

        <nav class="postindexpager"><ul class="pager">
<li class="next">
                <a href="/index-8.html" rel="next">Older posts</a>
            </li>
        </ul></nav><!--End of body content--><footer id="footer"><div class="text-center">
<p>Contents © 2017-2018 <a href="mailto:zl.wang@foxmail.com">Samson Wang</a>
 - Powered by <a href="https://getnikola.com/" rel="nofollow">Nikola</a>
 - Hosted on <a href="https://pages.github.com/" rel="nofollow">Github Pages</a>
 - 
<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/"><img alt="知识共享许可协议" style="border-width:0; vertical-align:text-top;" src="https://i.creativecommons.org/l/by-nc/4.0/80x15.png"></a>
</p>
</div>

      
    </footer>
</div>
</div>


            <script src="/assets/js/jquery.min.js"></script><script src="/assets/js/bootstrap.min.js"></script><script src="/assets/js/moment-with-locales.min.js"></script><script src="/assets/js/fancydates.js"></script><script src="/assets/js/jquery.colorbox-min.js"></script><script>
    $('a.image-reference:not(.islink) img:not(.islink)').parent().colorbox({rel:"gal",maxWidth:"100%",maxHeight:"100%",scalePhotos:true});
  </script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(2, "YYYY-MM-DD HH:mm");
  </script><!-- end fancy dates --><!-- Baidu Analytics --><script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?7ec47c52179b8ca4f9aee81282bd7b20";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
</body>
</html>
