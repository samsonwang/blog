<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="Constraint &amp; Focus">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Hack Note</title>
<link href="/assets/css/bootstrap.min.css" rel="stylesheet" type="text/css">
<link href="/assets/css/font-awesome.min.css" rel="stylesheet" type="text/css">
<link href="/assets/css/code.css" rel="stylesheet" type="text/css">
<link href="/assets/css/colorbox.css" rel="stylesheet" type="text/css">
<link href="/assets/css/cerulean.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" href="/rss.xml">
<link rel="canonical" href="http://samsonwang.me/">
<link rel="icon" href="/favicon.ico" sizes="64x64">
<link rel="next" href="/index-7.html" type="text/html">
<!--[if lt IE 9]><script src="/assets/js/html5.js"></script><![endif]--><link rel="prefetch" href="/posts/asynchronous-synchronous-and-blocking-unblocking/" type="text/html">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->
<nav class="navbar navbar-inverse navbar-fixed-top"><div class="container">
  <!-- This keeps the margins nice -->
    
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="http://samsonwang.me/">

        <span id="blog-title">Hack Note</span>
      </a>
    </div>
    
    <!-- /.navbar-header -->
    <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
      <ul class="nav navbar-nav">
<li>
<a href="/archive/">Archives</a>
                </li>
<li>
<a href="/tags/">Tags</a>
                </li>
<li>
<a href="/listings/">Listings</a>
                </li>
<li>
<a href="/galleries/">Galleries</a>
                </li>
<li>
<a href="/rss.xml">RSS Feed</a>

        
      </li>
</ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!-- /.navbar-collapse -->
  </div>
<!-- /.container -->
</nav><!-- End of Menubar --><div class="container" id="content" role="main">
  <div class="body-content">
    <!--Body content-->
    <div class="row">

      <div class="col-sm-9">
        
        


  



  

<div class="postindex">
  <article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/asynchronous-synchronous-and-blocking-unblocking/" class="u-url">同步和异步、阻塞和非阻塞</a></h1>
      <div class="metadata">
        
        
        <div class="date">
          <a href="/posts/asynchronous-synchronous-and-blocking-unblocking/" rel="bookmark">
            <time class="published dt-published" datetime="2018-06-26T09:27:06+08:00" title="2018-06-26 09:27">2018-06-26 09:27
            </time></a>
        </div>
        
          <div class="comment">
            
        
    <a href="/posts/asynchronous-synchronous-and-blocking-unblocking/#disqus_thread" data-disqus-identifier="cache/posts/asynchronous-synchronous-and-blocking-unblocking.html">Comments</a>


          </div>

      </div>
    </header><div class="e-content entry-content">
      <div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">
<span class="section-number-2">1</span> 同步和异步</h2>
<div class="outline-text-2" id="text-1">
<p>
同步和异步指的是在进行I/O操作完成之前，是否允许其他处理步骤继续执行。<br>
计算机中的I/O操作相对于数据处理操作时十分耗时的。<br></p>

<p>
一个简单的I/O操作方式就是启动连接并等待操作完成，但是这样的操作（同步阻塞I/O）在通信过程中会阻塞进程的处理进度。<br>
相应的，可以在启动通信的同时进行其他的处理，并不需要等待I/O操作的完成，这样的操作就被称作是异步I/O。那些依赖于I/O操作执行完成的任务会阻塞等待I/O操作的完成，其他不依赖与I/O操作的任务能够继续执行。<br></p>

<p>
同步模型常用的函数接口： <code>read</code> , <code>write</code> , <code>send</code> , <code>recv</code><br>
异步模型常用的函数接口： <code>aio_write</code> , <code>aio_read</code><br></p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">
<span class="section-number-3">1.1</span> POSIX AIO</h3>
<div class="outline-text-3" id="text-1-1">
<p>
在头文件 <code>aio.h</code> 中定义，链接时使用 <code>-lrt</code><br></p>

<p>
<b>函数接口</b><br>
异步写操作<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">aio_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">aiocb</span><span class="o">*</span> <span class="n">aiocbp</span><span class="p">);</span>
</pre></div>

<p>
异步读操作<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">aio_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">aiocb</span><span class="o">*</span> <span class="n">aiocbp</span><span class="p">);</span>
</pre></div>

<p>
获取异步操作结果<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">aio_return</span><span class="p">(</span><span class="k">struct</span> <span class="n">aiocb</span><span class="o">*</span> <span class="n">aiocbp</span><span class="p">);</span>
</pre></div>

<p>
获取异步操作中的错误<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">aio_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">aiocb</span><span class="o">*</span> <span class="n">aiocbp</span><span class="p">);</span>
</pre></div>

<p>
示例代码： <a href="https://gist.github.com/rsms/771059">github gist</a><br></p>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">
<span class="section-number-3">1.2</span> Linux AIO</h3>
<div class="outline-text-3" id="text-1-2">
<p>
在头文件 <code>libaio.h</code> 中定义，链接时使用 <code>-laio</code><br></p>

<p>
<b>函数接口</b><br>
需要注意的是aio的函数接口需要借助 <code>syscall</code> 进行调用。<br>
创建aio context对象<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">io_setup</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">nr</span><span class="p">,</span> <span class="n">aio_context_t</span><span class="o">*</span> <span class="n">ctxp</span><span class="p">);</span>
</pre></div>
<p>
销毁aio context对象<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">io_destroy</span><span class="p">(</span><span class="n">aio_context_t</span> <span class="n">ctx</span><span class="p">);</span>
</pre></div>
<p>
提交异步操作<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">io_submit</span><span class="p">(</span><span class="n">aio_context_t</span> <span class="n">ctx</span><span class="p">,</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iocb</span><span class="o">**</span> <span class="n">iocbpp</span><span class="p">);</span>
</pre></div>
<p>
获取异步操作结果<br></p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">io_getevents</span><span class="p">(</span><span class="n">aio_context_t</span> <span class="n">ctx</span><span class="p">,</span> <span class="kt">long</span> <span class="n">min_nr</span><span class="p">,</span> <span class="kt">long</span> <span class="n">max_nr</span><span class="p">,</span>
		 <span class="n">io_event</span><span class="o">*</span> <span class="n">events</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span><span class="o">*</span> <span class="n">timeout</span><span class="p">);</span>
</pre></div>

<p>
示例代码:<br></p>
<ul class="org-ul">
<li>
<i>github gist</i><br>
</li>
<li>
<a href="http://www.xmailserver.org/eventfd-aio-test.c">xmailserver.org</a><br>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">
<span class="section-number-3">1.3</span> POSIX AIO与Linux AIO的区别</h3>
<div class="outline-text-3" id="text-1-3">
<p>
摘自 <a href="https://stackoverflow.com/questions/8768083/difference-between-posix-aio-and-libaio-on-linux">stackoverflow.com</a><br></p>
<blockquote>
<p>
On linux, the two AIO implementations are fundamentally different.<br>
The POSIX AIO is a user-level implementation that performs normal blocking I/O in multiple threads, hence giving the illusion that the I/Os are asynchronous. The main reason to do this is that:<br></p>
<ul class="org-ul">
<li>it works with any filesystem<br>
</li>
<li>it works (essentially) on any operating system (keep in mind that gnu's libc is portable)<br>
</li>
<li>it works on files with buffering enabled (i.e. no O<sub>DIRECT</sub> flag set)<br>
</li>
</ul>
<p>
The main drawback is that your queue depth (i.e. the number of outstanding operations you can have in practice) is limited by the number of threads you choose to have, which also means that a slow operation on one disk may block an operation going to a different disk. It also affects which I/Os (or how many) is seen by the kernel and the disk scheduler as well.<br>
The kernel AIO (i.e. io<sub>submit</sub>() et.al.) is kernel support for asynchronous I/O operations, where the io requests are actually queued up in the kernel, sorted by whatever disk scheduler you have, presumably some of them are forwarded (in somewhat optimal order one would hope) to the actual disk as asynchronous operations (using TCQ or NCQ). The main restriction with this approach is that not all filesystems work that well or at all with async I/O (and may fall back to blocking semantics), files have to be opened with O<sub>DIRECT</sub> which comes with a whole lot of other restrictions on the I/O requests. If you fail to open your files with O<sub>DIRECT</sub>, it may still "work", as in you get the right data back, but it probably isn't done asynchronously, but is falling back to blocking semantics.<br>
Also keep in mind that io<sub>submit</sub>() can actually block on the disk under certain circumstances.<br></p>
</blockquote>
<p>
在Linux上两种AIO是完全不同的；<br>
POSIX AIO实现在用户层，实际上进行的操作是普通的多线程阻塞操作，表现为I/O操作是异步的，这种AIO的优点是兼容性和可移植性好，缺点是操作队列长度受限于最大线程数量。<br>
Linux AIO是内核提供的AIO函数接口，I/O操作请求的队列在内核中维护，这种AIO的缺点是并不支持所有的文件系统，Linux AIO在某些情况下的磁盘操作是会阻塞的。<br></p>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">
<span class="section-number-2">2</span> 阻塞和非阻塞</h2>
<div class="outline-text-2" id="text-2">
<p>
阻塞与非阻塞的概念针对的是函数是否会立即返回。<br>
非阻塞模型常与IO复用技术组合使用。<br>
可以通过函数将IO设备设置为非阻塞模式。<br></p>
</div>
</div>


<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">
<span class="section-number-2">3</span> 如何理解阻塞非阻塞与同步异步的区别</h2>
<div class="outline-text-2" id="text-3">
<p>
在处理 IO 的时候，阻塞和非阻塞都是同步 IO。<br>
只有使用了特殊的 API 才是异步 IO。<br></p>
</div>
</div>


<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">
<span class="section-number-2">4</span> 参考资料</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li>
<a href="https://blog.csdn.net/hguisu/article/details/38638183">csdn.net</a><br>
</li>
<li>
<a href="https://github.com/littledan/linux-aio%20repo">github.com linux-aio</a><br>
</li>
<li>
<a href="https://www.ibm.com/developerworks/linux/library/l-async/index.html">ibm developerworks</a><br>
</li>
</ul>
</div>
</div>
    </div>
  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/check-system-information-on-linux/" class="u-url">查看Linux系统的相关信息</a></h1>
      <div class="metadata">
        
        
        <div class="date">
          <a href="/posts/check-system-information-on-linux/" rel="bookmark">
            <time class="published dt-published" datetime="2018-06-20T10:30:50+08:00" title="2018-06-20 10:30">2018-06-20 10:30
            </time></a>
        </div>
        
          <div class="comment">
            
        
    <a href="/posts/check-system-information-on-linux/#disqus_thread" data-disqus-identifier="cache/posts/check-system-information-on-linux.html">Comments</a>


          </div>

      </div>
    </header><div class="e-content entry-content">
      <p>
查看Linux系统相关信息有助于排查和解决软件和硬件的兼容性问题。系统信息包括硬件信息和软件信息，硬件信息主要有CPU信息、内存信息、PCI信息、USB信息、硬盘信息等等。软件信息主要有系统版本、分区使用状态等等。本文主要介绍了获取当前Linux系统信息的命令。<br></p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">查看系统相关信息</h2>
<div class="outline-text-2" id="text-1">
<p>
<code>uname</code> 指令提供了查询系统信息的功能，使用该命令能够快速获取操作系统信息概览。<br></p>

<p>
查看内核名称<br></p>
<div class="highlight"><pre><span></span>uname -s
</pre></div>

<p>
查看处理器类型<br></p>
<div class="highlight"><pre><span></span>uname -p
</pre></div>

<p>
查看硬件架构<br></p>
<div class="highlight"><pre><span></span>uname -i
</pre></div>

<p>
查看所有的系统信息<br></p>
<div class="highlight"><pre><span></span>uname -a
</pre></div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">查看CPU相关信息</h2>
<div class="outline-text-2" id="text-2">
<p>
<code>lscpu</code> 指令能够查看当前系统中CPU的详细信息，包括型号、主频、构架、大小端等信息。<br></p>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">查看硬盘相关信息</h2>
<div class="outline-text-2" id="text-3">
<p>
<code>lsblk</code> 指令能够查看块设备（block device）的详细信息，块设备主要指系统中的存储设备如硬盘和闪存。<br></p>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">查看PCI设备的相关信息</h2>
<div class="outline-text-2" id="text-4">
<p>
<code>lspci</code> 指令能够查看PCI设备的信息，PCI设备包括USB、显卡、串口、网卡等其他外围设备。<br></p>

<p>
输出树形结果<br></p>
<div class="highlight"><pre><span></span>lspci -t
</pre></div>

<p>
输出详细信息<br></p>
<div class="highlight"><pre><span></span>lspci -v
lspci -vv
</pre></div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">查看USB设备的相关信息</h2>
<div class="outline-text-2" id="text-5">
<p>
<code>lsusb</code> 指令能够查看USBS设备的信息。<br></p>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">查看文件系统相关信息</h2>
<div class="outline-text-2" id="text-6">
<p>
<code>fdisk</code> 命令能够查看和操作linux系统的分区表。<br></p>

<p>
查看文件系统信息<br></p>
<div class="highlight"><pre><span></span>fdisk -l
</pre></div>

<p>
<code>df</code> 命令能够查看分区信息和硬盘使用信息<br></p>

<p>
使输出信息更容易理解<br></p>
<div class="highlight"><pre><span></span>df -h
</pre></div>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">参考资料</h2>
<div class="outline-text-2" id="text-7">
<ul class="org-ul">
<li>
<a href="https://www.tecmint.com/commands-to-collect-system-and-hardware-information-in-linux/">tecmint.com</a><br>
</li>
<li>
<a href="https://www.binarytides.com/linux-commands-hardware-info/">binarytides.com</a><br>
</li>
</ul>
</div>
</div>
    </div>
  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/cloud-server-security/" class="u-url">云服务器安全相关配置</a></h1>
      <div class="metadata">
        
        
        <div class="date">
          <a href="/posts/cloud-server-security/" rel="bookmark">
            <time class="published dt-published" datetime="2018-06-07T14:12:38+08:00" title="2018-06-07 14:12">2018-06-07 14:12
            </time></a>
        </div>
        
          <div class="comment">
            
        
    <a href="/posts/cloud-server-security/#disqus_thread" data-disqus-identifier="cache/posts/cloud-server-security.html">Comments</a>


          </div>

      </div>
    </header><div class="e-content entry-content">
      <p>
我所租用的云服务器操作系统为CentOS Linux，在使用云服务器的过程中为了保证服务器的安全，进行了一些简单的配置，这样能够增加服务器被破解的难度。<br></p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">使用denyhosts防止暴力破解登录密码</h2>
<div class="outline-text-2" id="text-1">
<p>
登入服务器主要是使用用户名和密码，而且linux的root用户拥有最高权限。可以使用denyhosts，防止暴力破解用户名和密码。denyhosts的原理是在多次输入错误的用户名和密码时，屏蔽该登录ip，限制密码的尝试次数。<br></p>

<p>
<b>安装denyhosts</b><br>
可以使用自带的包管理器安装denyhost，这样是比较方便的，后续的配置工作也会简单一些。<br></p>
<div class="highlight"><pre><span></span>yum install denyhosts
</pre></div>

<p>
<b>编辑配置文件</b><br>
安装好denyhosts之后，它的默认配置文件为 <code>/etc/denyhosts.conf</code> 。该配置文件有很好的注释，对于每个配置项的作用都有很好的说明。可能需要修改的相关配置项有如下几个。denyhosts可以分别配置root用户、普通用户、无效用户用户名的尝试次数。<br></p>
<div class="highlight"><pre><span></span>DENY_THRESHOLD_INVALID = 5
DENY_THRESHOLD_VALID = 10
DENY_THRESHOLD_ROOT = 5
</pre></div>

<p>
<b>启动denyhosts</b><br>
使用以下命令启动denyhosts，查看denyhosts的运行状态。<br></p>
<div class="highlight"><pre><span></span>service denyhosts start
service denyhosts status
</pre></div>

<p>
使用以下命令让denyhosts能够随系统自启动。<br></p>
<div class="highlight"><pre><span></span>chkconfig denyhosts on
</pre></div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">更改sshd的端口号</h2>
<div class="outline-text-2" id="text-2">
<p>
sshd的默认端口号为22，很多暴力破解程序会直接对该端口进行登录尝试，通过修改默认的sshd的端口号，可以增加破解难度。需要注意的是，在修改sshd端口号之后，自己使用shell工具登录服务器也需要端口号进行修改。<br></p>

<p>
<b>编辑配置文件</b><br>
sshd的配置文件为 <code>/etc/ssh/sshd_config</code> ，端口号配置为这一行 <code># Port 22</code> ，删去井号然后将22改为需要的端口号。<br></p>

<p>
<b>重启sshd服务</b><br>
更改配置文件后，需要重启服务使配置文件生效。<br></p>
<div class="highlight"><pre><span></span>service sshd restart
</pre></div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">使用 <code>last</code> 和 <code>lastb</code> 查看系统登录记录</h2>
<div class="outline-text-2" id="text-3">
<p>
<code>last</code> 指令能够查看登录成功的记录，而 <code>lastb</code> 指令能够查看登录失败的记录。通过查看登录失败的记录，能够判断出服务器是否有被暴力破解的记录。需要注意的是这两个命令均需要管理员权限才能够执行。<br></p>
</div>
</div>
    </div>
  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/c-style-and-cpp-style-file-api/" class="u-url">C风格和C++风格的文件操作库函数总结</a></h1>
      <div class="metadata">
        
        
        <div class="date">
          <a href="/posts/c-style-and-cpp-style-file-api/" rel="bookmark">
            <time class="published dt-published" datetime="2018-05-16T18:06:45+08:00" title="2018-05-16 18:06">2018-05-16 18:06
            </time></a>
        </div>
        
          <div class="comment">
            
        
    <a href="/posts/c-style-and-cpp-style-file-api/#disqus_thread" data-disqus-identifier="cache/posts/c-style-and-cpp-style-file-api.html">Comments</a>


          </div>

      </div>
    </header><div class="e-content entry-content">
      <p>
由于C++是兼容C的，所以使用C++进行文件操作时，会发现有两套库函数可以使用，它们分别是C风格的和C++风格的。<br></p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">C风格的文件操作函数</h2>
<div class="outline-text-2" id="text-1">
<p>
<b>打开文件，关闭文件</b><br></p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="kt">FILE</span><span class="o">*</span> <span class="nf">fopen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">path</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">mode</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">fclose</span><span class="p">(</span><span class="kt">FILE</span><span class="o">*</span> <span class="n">fp</span><span class="p">);</span>
</pre></div>

<p>
<b>读取文件，写入文件</b><br></p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="kt">size_t</span> <span class="nf">fread</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nmemb</span><span class="p">,</span> <span class="kt">FILE</span><span class="o">*</span> <span class="n">stream</span><span class="p">);</span>
<span class="kt">size_t</span> <span class="nf">fwrite</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nmemb</span><span class="p">,</span> <span class="kt">FILE</span><span class="o">*</span> <span class="n">stream</span><span class="p">);</span>
</pre></div>
<p>
关于fread中两个表示大小的参数，在这个 <a href="https://stackoverflow.com/questions/8589425/how-does-fread-really-work">stackoverflow</a> 问题中得到了比较好的解答。<br></p>


<p>
<b>改变文件指示器的位置</b><br></p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">fseek</span><span class="p">(</span><span class="kt">FILE</span><span class="o">*</span> <span class="n">stream</span><span class="p">,</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">whence</span><span class="p">);</span>
<span class="kt">long</span> <span class="nf">ftell</span><span class="p">(</span><span class="kt">FILE</span><span class="o">*</span> <span class="n">stream</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">rewind</span><span class="p">(</span><span class="kt">FILE</span><span class="o">*</span> <span class="n">stream</span><span class="p">);</span>
</pre></div>
</div>
</div>


<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">C++风格的文件操作函数</h2>
<div class="outline-text-2" id="text-2">
<p>
C++将文件操作函数封装为 <code>fstream</code> 操作类，一个文件实际上就会对应一个 <code>fstream</code> 对象，一下函数都是 <code>fstream</code> 的成员函数。<br>
文件打开和关闭<br></p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">filename</span><span class="p">,</span> <span class="n">ios_base</span><span class="o">::</span><span class="n">openmode</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">ios_base</span><span class="o">::</span><span class="n">in</span><span class="o">|</span><span class="n">ios_base</span><span class="o">::</span><span class="n">out</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">open</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="n">ios_base</span><span class="o">::</span><span class="n">openmode</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">ios_base</span><span class="o">::</span><span class="n">in</span><span class="o">|</span><span class="n">ios_base</span><span class="o">::</span><span class="n">out</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">close</span><span class="p">();</span>
</pre></div>

<p>
对于文件的读写可以才采用流运算符重载的方法完成。<br></p>
<div class="highlight"><pre><span></span><span class="k">friend</span> <span class="n">fstream</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">fstream</span><span class="o">&amp;</span> <span class="n">ofs</span><span class="p">,</span> <span class="k">const</span> <span class="n">CRecord</span><span class="o">&amp;</span> <span class="n">objRecord</span><span class="p">);</span>
<span class="k">friend</span> <span class="n">fstream</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">fstream</span><span class="o">&amp;</span> <span class="n">ifs</span><span class="p">,</span> <span class="n">CRecord</span><span class="o">&amp;</span> <span class="n">objRecord</span><span class="p">);</span>
</pre></div>
</div>
</div>


<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">题外话</h2>
<div class="outline-text-2" id="text-3">
<p>
在liunx下，可以使用wc命令查看文件中的相关信息。wc命令会打印出该文件的行数、单词数、字符数。<br></p>
</div>
</div>
    </div>
  </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="/posts/endianness-and-union-type/" class="u-url">字节序与union类型</a></h1>
      <div class="metadata">
        
        
        <div class="date">
          <a href="/posts/endianness-and-union-type/" rel="bookmark">
            <time class="published dt-published" datetime="2018-05-11T09:55:34+08:00" title="2018-05-11 09:55">2018-05-11 09:55
            </time></a>
        </div>
        
          <div class="comment">
            
        
    <a href="/posts/endianness-and-union-type/#disqus_thread" data-disqus-identifier="cache/posts/endianness-and-union-type.html">Comments</a>


          </div>

      </div>
    </header><div class="e-content entry-content">
      <div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">字节序</h2>
<div class="outline-text-2" id="text-1">
<p>
字节序是指在数据传输时，高位字节存储在内存中的较高位地址还是较低位地址。<br>
字节序分为大端字节序和小端字节序，两种字节序不能混用。<br><b>大端字节序</b> ：高位字节保存在较低位地址的内存中<br><b>小端字节序</b> ：高位字节保存在较高位地址的内存中<br></p>

<p>
以 <code>int n = 0x12345678</code> 为例，大端字节序内存中的存储的顺序为 <code>0x12 0x34 0x56 0x78</code> ，小端字节序内存中的存储顺序为 <code>0x78 0x56 0x34 0x12</code> 。<br>
很明显可以看出大端字节序更符合人类的阅读习惯。<br></p>

<p>
常见的大端系统CPU：IBM z/Atchitecture<br>
常见的小端系统CPU：intel x86 处理器<br></p>

<p>
网络字节序使用的大端字节序，常用网络协议如IPv4、IPv6、TCP和UDP协议都是使用大端字节序完成数据传输的。<br></p>
</div>
</div>


<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">union类型</h2>
<div class="outline-text-2" id="text-2">
<p>
可以使用union类型验证字节序，以下示例代码在不同的字节序下会有不同的输出。<br></p>

<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">un</span>
<span class="p">{</span>
    <span class="kt">int32_t</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">ch</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="p">}</span><span class="n">un</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">un</span> <span class="n">u</span><span class="p">;</span>
    <span class="n">u</span><span class="p">.</span><span class="n">ch</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">u</span><span class="p">.</span><span class="n">ch</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">u</span><span class="p">.</span><span class="n">ch</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="n">u</span><span class="p">.</span><span class="n">ch</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"u.x=0x%x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
    </div>
  </article>
</div>



        
       <script>var disqus_shortname="samsonwang-me";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script>
</div>

      <div class="col-sm-3 sidebar">
       
<div class="sidebar-module sidebar-module-inset">
  <h4>About Me</h4>
  
<div class="sidebar-aboutme">
<p>Zeal for coding, C++ developer.</p>
<p>Focus on linux server dev.</p>
<p>I use EMACS, and I am learning python.</p>
<p>View my code on <a href="https://github.com/samsonwang"> Github</a></p>
</div>

</div>

       
<div class="sidebar-module">
  <h4>Categories</h4>
  
<ol class="list-unstyled sidebar-category">
<li>
<a href="/tags/category_cpp/">cpp</a>
</li>
<li>
<a href="/tags/category_emacs/">emacs</a>
</li>
<li>
<a href="/tags/category_linux/">linux</a>
</li>
<li>
<a href="/tags/category_windows/">windows</a>
</li>
</ol>
</div>

      </div>
<!--.sidebar-->
    </div>
<!--.row-->

    

        <nav class="postindexpager"><ul class="pager">
<li class="next">
                <a href="/index-7.html" rel="next">Older posts</a>
            </li>
        </ul></nav><!--End of body content--><footer id="footer"><div class="text-center">
<p>Contents © 2017-2018 <a href="mailto:zl.wang@foxmail.com">Samson Wang</a>
 - Powered by <a href="https://getnikola.com/" rel="nofollow">Nikola</a>
 - Hosted on <a href="https://pages.github.com/" rel="nofollow">Github Pages</a>
 - 
<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/"><img alt="知识共享许可协议" style="border-width:0; vertical-align:text-top;" src="https://i.creativecommons.org/l/by-nc/4.0/80x15.png"></a>
</p>
</div>

      
    </footer>
</div>
</div>


            <script src="/assets/js/jquery.min.js"></script><script src="/assets/js/bootstrap.min.js"></script><script src="/assets/js/moment-with-locales.min.js"></script><script src="/assets/js/fancydates.js"></script><script src="/assets/js/jquery.colorbox-min.js"></script><script>
    $('a.image-reference:not(.islink) img:not(.islink)').parent().colorbox({rel:"gal",maxWidth:"100%",maxHeight:"100%",scalePhotos:true});
  </script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(2, "YYYY-MM-DD HH:mm");
  </script><!-- end fancy dates --><!-- Baidu Analytics --><script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?7ec47c52179b8ca4f9aee81282bd7b20";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
</body>
</html>
